# Translation of R-stats.pot to French
# Copyright (C) 2005 The R Foundation
# This file is distributed under the same license as the stats R package.
# Philippe Grosjean <phgrosjean@sciviews.org>, 2005.
#
msgid ""
msgstr ""
"Project-Id-Version: R 4.0.4\n"
"Report-Msgid-Bugs-To: bugs.r-project.org\n"
"POT-Creation-Date: 2025-06-04 19:56\n"
"PO-Revision-Date: 2023-04-14 03:05+0000\n"
"Last-Translator: Hugo Gruson <hugo.gruson@normalesup.org>\n"
"Language-Team: French <R-core@r-project.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 2.4.2\n"

#. R/xtabs.R: gettextf("%s applies only to two-way tables", "xtabs(*, sparse=TRUE)")
#: R/xtabs.R:0
msgid "%s applies only to two-way tables"
msgstr "%s est seulement applicable sur des tables de contingence à deux entrées"

#. R/family.R: gettextf("%s link not recognised", sQuote(link))
#: R/family.R:0
msgid "%s link not recognised"
msgstr "lien %s non reconnu"

#. R/stl.R: gettextf("%s must be 0 or 1", degname)
#: R/stl.R:0
msgid "%s must be 0 or 1"
msgstr "%s doit être 0 ou 1"

#. R/contrast.R: gettextf("%s needs package 'Matrix' correctly installed", "contr*(.., sparse=TRUE)")
#. R/xtabs.R: gettextf("%s needs package 'Matrix' correctly installed", "xtabs(*, sparse=TRUE)")
#: R/contrast.R:0 R/xtabs.R:0
msgid "%s needs package 'Matrix' correctly installed"
msgstr "%s nécessite le package 'Matrix' correctement installé"

#. R/lm.R: gettextf("%s: NAs produced for non-estimable cases", msg1)
#: R/lm.R:0
msgid "%s: NAs produced for non-estimable cases"
msgstr ""

#. R/lm.R: gettextf("%s; attr(*, \"non-estim\") has doubtful cases", msg1)
#: R/lm.R:0
msgid "%s; attr(*, \"non-estim\") has doubtful cases"
msgstr ""

#. R/lm.R: gettextf("%s; consider predict(., rankdeficient=\"NA\")", msg1)
#: R/lm.R:0
msgid "%s; consider predict(., rankdeficient=\"NA\")"
msgstr ""

#. R/nlsFunc.R: gettextf("'%s' cannot be of mode '%s'", deparse1(substitute(object)),     mode(object))
#: R/nlsFunc.R:0
msgid "'%s' cannot be of mode '%s'"
msgstr "'%s' ne peut être de mode '%s'"

#. R/models.R: gettextf("'%s' must be a character string", "response")
#. R/reshape.R: gettextf("'%s' must be a character string", "sep")
#: R/models.R:0 R/reshape.R:0
#, fuzzy
msgid "'%s' must be a character string"
msgstr "'sep' doit être une chaîne de caractères"

#. R/power.R: gettextf("'%s' must be numeric in [0, 1]", deparse1(substitute(x)))
#: R/power.R:0
#, fuzzy
msgid "'%s' must be numeric in [0, 1]"
msgstr "'sig.level' doit être numerique et dans [0, 1]"

#. R/addmargins.R: stop("'A' must be an array or table")
#: R/addmargins.R:0
msgid "'A' must be an array or table"
msgstr "'A' doit être une matrice (array) ou un tableau de données (table)"

#. R/dendrogram.R: stop("'ColSideColors' must be a character vector of length ncol(x)")
#: R/dendrogram.R:0
msgid "'ColSideColors' must be a character vector of length ncol(x)"
msgstr "'ColSideColors' doit être un vecteur de caractères de longueur ncol(x)"

#. R/anova.R: stop("'P.values' is TRUE, but 'has.Pvalue' is not")
#: R/anova.R:0
msgid "'P.values' is TRUE, but 'has.Pvalue' is not"
msgstr "'P.values' est TRUE, mais 'has.Pvalue' ne l'est pas"

#. R/dendrogram.R: stop("'RowSideColors' must be a character vector of length nrow(x)")
#: R/dendrogram.R:0
msgid "'RowSideColors' must be a character vector of length nrow(x)"
msgstr "'RowSideColors' doit être un vecteur de caractères de longueur nrow(x)"

#. R/poisson.test.R: stop("'T' must be nonnegative")
#: R/poisson.test.R:0
msgid "'T' must be nonnegative"
msgstr "'T' doit être positif ou nul"

#. R/cor.R: stop("'V' is not a square numeric matrix")
#: R/cor.R:0
msgid "'V' is not a square numeric matrix"
msgstr "'V' n'est pas une matrice carrée numérique"

#. R/dendrogram.R: stop("'X' is not a dendrogram")
#: R/dendrogram.R:0
msgid "'X' is not a dendrogram"
msgstr "'X' n'est pas un dendrogramme"

#. R/lsfit.R: warning("'X' matrix was collinear")
#: R/lsfit.R:0
msgid "'X' matrix was collinear"
msgstr "la matrice 'X' est collinéaire"

#. R/ARMAtheory.R: stop("'acf' must be of length two or more")
#: R/ARMAtheory.R:0
msgid "'acf' must be of length two or more"
msgstr "'acf' doit être de longueur deux ou plus"

#. R/smspline.R: warning("'all.knots' is TRUE; 'nknots' specification is disregarded")
#: R/smspline.R:0
msgid "'all.knots' is TRUE; 'nknots' specification is disregarded"
msgstr "'all.knots' est vrai (TRUE) ; la valeur fournie pour 'nknots' est ignorée"

#. R/smspline.R: warning("'all.knots' is vector of knots; 'nknots' specification is disregarded")
#: R/smspline.R:0
msgid "'all.knots' is vector of knots; 'nknots' specification is disregarded"
msgstr "'all.knots' est un vecteur de nœuds ; la valeur fournie pour 'nknots' est ignorée"

#. R/HoltWinters.R: stop("'alpha', 'beta' and 'gamma' must be within the unit interval")
#: R/HoltWinters.R:0
msgid "'alpha', 'beta' and 'gamma' must be within the unit interval"
msgstr "'alpha', 'beta' et 'gamma' doivent être dans un intervale d'une unité"

#. R/nls.R: stop("'anova' is only defined for sequences of \"nls\" objects")
#: R/nls.R:0
msgid "'anova' is only defined for sequences of \"nls\" objects"
msgstr "'anova' n'est définie que pour des suites d'objets \"nls\""

#. R/anova.R: stop("'anova' object must have colnames")
#: R/anova.R:0
msgid "'anova' object must have colnames"
msgstr "l'objet 'anova' doit avoir des noms de colonnes"

#. R/approx.R: stop("'approx' requires n >= 1")
#: R/approx.R:0
msgid "'approx' requires n >= 1"
msgstr "'approx' nécessite n >= 1"

#. R/ts.R: stop("'ar' part of model is not stationary")
#: R/ts.R:0
msgid "'ar' part of model is not stationary"
msgstr "la partie 'ar' du mopdèle n'est pas stationaire"

#. R/density.R: stop("'bw' is not positive.")
#: R/density.R:0
msgid "'bw' is not positive."
msgstr "'bw' n'est pas positive."

#. R/aggregate.R: stop("'by' must be a list")
#: R/aggregate.R:0
msgid "'by' must be a list"
msgstr "'by' doit être une liste"

#. R/kmeans.R: stop("'centers' must be a number or a matrix")
#: R/kmeans.R:0
msgid "'centers' must be a number or a matrix"
msgstr "'centers' doit être une matrice numérique"

#. R/filter.R: stop("'circular' must be logical and not NA")
#: R/filter.R:0
msgid "'circular' must be logical and not NA"
msgstr "'circular' doit être une valeur logique et pas NA"

#. R/kernel.R: stop("'coef' does not have the correct length")
#: R/kernel.R:0
msgid "'coef' does not have the correct length"
msgstr "la longueur de 'coef' est incorrecte"

#. R/kernel.R: stop("'coef' must be a vector")
#: R/kernel.R:0
msgid "'coef' must be a vector"
msgstr "'coef' doit être un vecteur"

#. R/aov.R: stop("'coef' must define a contrast, i.e., sum to 0")
#: R/aov.R:0
msgid "'coef' must define a contrast, i.e., sum to 0"
msgstr "'coef' doit définir un constrate, i.e., sa somme doit être 0"

#. R/aov.R: stop("'coef' must have same length as 'contrast.obj'")
#: R/aov.R:0
msgid "'coef' must have same length as 'contrast.obj'"
msgstr "'coef' doit être de la même longueur que 'contrast.obj'"

#. R/ftable.R: stop("'col.vars' missing or incorrect")
#: R/ftable.R:0
msgid "'col.vars' missing or incorrect"
msgstr "'col.vars' manquant ou incorrect"

#. R/qqplot.R: stop("'conf.level' is not a probability")
#: R/qqplot.R:0
msgid "'conf.level' is not a probability"
msgstr ""

#. R/ansari.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/binom.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/cor.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/fisher.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/mantelhaen.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/prop.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/t.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/var.test.R: stop("'conf.level' must be a single number between 0 and 1")
#. R/wilcox.test.R: stop("'conf.level' must be a single number between 0 and 1")
#: R/ansari.test.R:0 R/binom.test.R:0 R/cor.test.R:0 R/fisher.test.R:0
#: R/mantelhaen.test.R:0 R/prop.test.R:0 R/t.test.R:0 R/var.test.R:0
#: R/wilcox.test.R:0
msgid "'conf.level' must be a single number between 0 and 1"
msgstr "'conf.level' doit être un nombre compris entre 0 et 1"

#. R/models.R: stop("'contrasts.arg' argument must be named")
#: R/models.R:0
msgid "'contrasts.arg' argument must be named"
msgstr "l'argument 'contrasts.arg' doit être nommé"

#. R/nlminb.R: stop("'control' argument must be a named list")
#. R/nls.R: stop("'control' argument must be a named list")
#: R/nlminb.R:0 R/nls.R:0
msgid "'control' argument must be a named list"
msgstr "l'argument 'control' doit être une liste nommée"

#. R/factanal.R: stop("'covmat' is not a valid covariance list")
#. R/princomp.R: stop("'covmat' is not a valid covariance list")
#: R/factanal.R:0 R/princomp.R:0
msgid "'covmat' is not a valid covariance list"
msgstr "'covmat' n'est pas une liste de covariances correcte"

#. R/factanal.R: stop("'covmat' is of unknown type")
#. R/princomp.R: stop("'covmat' is of unknown type")
#: R/factanal.R:0 R/princomp.R:0
msgid "'covmat' is of unknown type"
msgstr "'covmat' est de type inconnu"

#. R/model.tables.R: stop("'cterms' argument must match terms in model object")
#: R/model.tables.R:0
msgid "'cterms' argument must match terms in model object"
msgstr "l'argument 'cterms' doit correspondre aux termes de l'objet modèle"

#. R/symnum.R: gettext("'cutpoints' must be unique in 0 < cuts < 1, but are = ")
#: R/symnum.R:0
msgid "'cutpoints' must be unique in 0 < cuts < 1, but are ="
msgstr "'cutpoints' doivent être uniques dans 0 < cuts < 1, mais ils sont ="

#. R/symnum.R: gettext("'cutpoints' must be unique, but are = ")
#: R/symnum.R:0
msgid "'cutpoints' must be unique, but are ="
msgstr "'cutpoints' doivent être uniques, mais ils sont ="

#. R/smspline.R: stop("'cv' must not be NA when 'df' is specified")
#: R/smspline.R:0
msgid "'cv' must not be NA when 'df' is specified"
msgstr "'cv' ne peut être NA lorsque 'df' est spécifié"

#. R/models.R: stop("'data' must be a data.frame, environment, or list")
#: R/models.R:0
msgid "'data' must be a data.frame, environment, or list"
msgstr "'data' doit être un data frame, un environnement ou une liste"

#. R/models.R: stop("'data' must be a data.frame, not a matrix or an array")
#: R/models.R:0
msgid "'data' must be a data.frame, not a matrix or an array"
msgstr "'data' doit être un tableau de données et non pas une matrice ou un tableau"

#. R/nls.R: stop("'data' must be a list or an environment")
#: R/nls.R:0
msgid "'data' must be a list or an environment"
msgstr "'data' doit être une liste ou un environnement"

#. R/loess.R: stop("'degree' must be 0, 1 or 2")
#: R/loess.R:0
msgid "'degree' must be 0, 1 or 2"
msgstr "'degree' doit être 0, 1 ou 2"

#. R/contr.poly.R: stop("'degree' must be at least 1")
#: R/contr.poly.R:0
msgid "'degree' must be at least 1"
msgstr "'degree' doit valoir au moins 1"

#. R/contr.poly.R: stop("'degree' must be less than number of unique points")
#: R/contr.poly.R:0
msgid "'degree' must be less than number of unique points"
msgstr "'degree' doit être inférieur au nombre de points uniques"

#. R/splinefun.R: stop("'deriv' must be between 0 and 3")
#: R/splinefun.R:0
msgid "'deriv' must be between 0 and 3"
msgstr "'deriv' doit être compris entre 0 et 3"

#. R/ts.R: stop("'end' must be a whole number of cycles after 'start'")
#: R/ts.R:0
msgid "'end' must be a whole number of cycles after 'start'"
msgstr "'end' doit être un nombre entier de cycles après 'start'"

#. R/ts.R: warning("'end' value not changed")
#: R/ts.R:0
msgid "'end' value not changed"
msgstr "valeur de 'end' inchangée"

#. R/glm.R: stop("'family' argument seems not to be a valid family object",     call. = FALSE)
#: R/glm.R:0
msgid "'family' argument seems not to be a valid family object"
msgstr "l'argument 'family' ne semble pas être un objet famille correcte"

#. R/glm.R: stop("'family' not recognized")
#: R/glm.R:0
msgid "'family' not recognized"
msgstr "'family' non reconnu"

#. R/ftable.R: stop("'file' must be a character string or connection")
#: R/ftable.R:0
msgid "'file' must be a character string or connection"
msgstr "'file' doit être une chaîne de caractères ou une connexion"

#. R/filter.R: stop("'filter' is longer than time series")
#: R/filter.R:0
msgid "'filter' is longer than time series"
msgstr "'filter' est plus long que la série temporelle"

#. R/ftable.R: stop("'formula' has '.' in both left and right hand sides")
#: R/ftable.R:0
msgid "'formula' has '.' in both left and right hand sides"
msgstr "'formula' a '.' dans ses deux membres"

#. R/quade.test.R: stop("'formula' missing")
#: R/quade.test.R:0
msgid "'formula' missing"
msgstr "'formula' manquante"

#. R/ansari.test.R: stop("'formula' missing or incorrect")
#. R/bartlett.test.R: stop("'formula' missing or incorrect")
#. R/fligner.test.R: stop("'formula' missing or incorrect")
#. R/ftable.R: stop("'formula' missing or incorrect")
#. R/kruskal.test.R: stop("'formula' missing or incorrect")
#. R/ks.test.R: stop("'formula' missing or incorrect")
#. R/mood.test.R: stop("'formula' missing or incorrect")
#. R/oneway.test.R: stop("'formula' missing or incorrect")
#. R/t.test.R: stop("'formula' missing or incorrect")
#. R/var.test.R: stop("'formula' missing or incorrect")
#. R/wilcox.test.R: stop("'formula' missing or incorrect")
#. R/xtabs.R: stop("'formula' missing or incorrect")
#: R/ansari.test.R:0 R/bartlett.test.R:0 R/fligner.test.R:0 R/ftable.R:0
#: R/kruskal.test.R:0 R/ks.test.R:0 R/mood.test.R:0 R/oneway.test.R:0
#: R/t.test.R:0 R/var.test.R:0 R/wilcox.test.R:0 R/xtabs.R:0
msgid "'formula' missing or incorrect"
msgstr "'formula' manquante ou incorrecte"

#. R/cor.test.R: stop("'formula' missing or invalid")
#: R/cor.test.R:0
msgid "'formula' missing or invalid"
msgstr "'formula' manquante ou incorrecte"

#. R/ftable.R: stop("'formula' must have both left and right hand sides")
#: R/ftable.R:0
msgid "'formula' must have both left and right hand sides"
msgstr "'formula' doit avoir un membre de gauche et un membre de droite"

#. R/bartlett.test.R: stop("'formula' should be of the form response ~ group")
#. R/fligner.test.R: stop("'formula' should be of the form response ~ group")
#. R/kruskal.test.R: stop("'formula' should be of the form response ~ group")
#: R/bartlett.test.R:0 R/fligner.test.R:0 R/kruskal.test.R:0
msgid "'formula' should be of the form response ~ group"
msgstr "'formula' doit être de la forme réponse ~ groupe"

#. R/ts.R: stop("'frequency' and 'deltat' are both not NULL and are inconsistent")
#: R/ts.R:0
msgid "'frequency' and 'deltat' are both not NULL and are inconsistent"
msgstr "'frequency' et 'deltat' sont tous les deux non NULL et sont incompatibles"

#. R/ts.R: warning("'frequency' not changed")
#: R/ts.R:0
msgid "'frequency' not changed"
msgstr "'frequency' inchangée"

#. R/dendrogram.R: gettextf("'height' must be at least %g, the maximal height of its components",     h.max)
#: R/dendrogram.R:0
msgid "'height' must be at least %g, the maximal height of its components"
msgstr "'height' doit être au moins %g, la hauteur maximale de ses composants"

#. R/fisher.test.R: warning("'hybrid' is ignored for a 2 x 2 table")
#: R/fisher.test.R:0
msgid "'hybrid' is ignored for a 2 x 2 table"
msgstr "'hybrid' est ignoré pour une table 2 x 2"

#. R/plot.lm.R: gettextf("'id.n' must be in {1,..,%d}", n)
#: R/plot.lm.R:0
msgid "'id.n' must be in {1,..,%d}"
msgstr "'id.n' doit appartenir à {1,..,%d}"

#. R/reshape.R: stop("'idvar' must uniquely identify records")
#: R/reshape.R:0
msgid "'idvar' must uniquely identify records"
msgstr "'idvar' doivent identifier les enregistrement de manière unique"

#. R/arima.R: stop("'init' is of the wrong length")
#. R/arma0.R: stop("'init' is of the wrong length")
#: R/arima.R:0 R/arma0.R:0
msgid "'init' is of the wrong length"
msgstr "'init' n'a pas la bonne longueur"

#. R/nlm.R: stop("'interval' must be a vector of length 2")
#: R/nlm.R:0
msgid "'interval' must be a vector of length 2"
msgstr "'interval' doit être un vecteur de longueur 2"

#. R/kmeans.R: stop("'iter.max' must be positive")
#: R/kmeans.R:0
msgid "'iter.max' must be positive"
msgstr "'iter.max' doit être positif"

#. R/identify.hclust.R: stop("'k' and 'h' must be a scalar")
#: R/identify.hclust.R:0
msgid "'k' and 'h' must be a scalar"
msgstr "'k' et 'h' doivent être des scalaires"

#. R/runmed.R: gettextf("'k' is bigger than 'n'!  Changing 'k' to %d", k <- as.integer(1 +     2 * ((n - 1)%/%2)))
#: R/runmed.R:0
msgid "'k' is bigger than 'n'!  Changing 'k' to %d"
msgstr "'k' est plus grand que 'n' ! La valeur de 'k' est remplacée par %d"

#. R/kernel.R: stop("'k' is not a kernel")
#: R/kernel.R:0
msgid "'k' is not a kernel"
msgstr "'k' n'est pas un noyau"

#. R/lag.R: warning("'k' is not an integer")
#: R/lag.R:0
msgid "'k' is not an integer"
msgstr "'k' n'est pas un entier"

#. R/cmdscale.R: stop("'k' must be in {1, 2, ..  n - 1}")
#: R/cmdscale.R:0
msgid "'k' must be in {1, 2, ..  n - 1}"
msgstr "'k' doit être dans {1, 2, ..  n - 1}"

#. R/runmed.R: gettextf("'k' must be odd!  Changing 'k' to %d", k <- as.integer(1 +     2 * (k%/%2)))
#: R/runmed.R:0
msgid "'k' must be odd!  Changing 'k' to %d"
msgstr "'k' doit être impair ! La valeur de 'k' est remplacée par %d"

#. R/runmed.R: stop("'k' must be positive")
#: R/runmed.R:0
msgid "'k' must be positive"
msgstr "'k' doit être positif"

#. R/kernel.R: stop("'kernapply' is not available for object 'x'")
#: R/kernel.R:0
msgid "'kernapply' is not available for object 'x'"
msgstr "'kernapply' n'est pas disponible pour l'objet 'x'"

#. R/acf.R: stop("'lag.max' must be at least 0")
#: R/acf.R:0
msgid "'lag.max' must be at least 0"
msgstr "'lag.max' doit valoir au moins 0"

#. R/acf.R: stop("'lag.max' must be at least 1")
#: R/acf.R:0
msgid "'lag.max' must be at least 1"
msgstr "'lag.max' doit valoir au moins 1"

#. R/reshape.R: stop("'lengths(varying)' must all match 'length(times)'")
#: R/reshape.R:0
msgid "'lengths(varying)' must all match 'length(times)'"
msgstr "tous les 'lengths(varying)' doivent correspondre à 'length(times)'"

#. R/logLik.R: stop("'logLik.lm' does not support multiple responses")
#: R/logLik.R:0
msgid "'logLik.lm' does not support multiple responses"
msgstr "'logLik.lm' n'est pas implémenté pour les réponses multiples"

#. R/mad.R: stop("'low' and 'high' cannot be both TRUE")
#: R/mad.R:0
msgid "'low' and 'high' cannot be both TRUE"
msgstr "'low' et 'high' ne peuvent pas être vrais tous les deux simultanément"

#. R/optim.R: stop("'lower' and 'upper' must be finite values")
#: R/optim.R:0
msgid "'lower' and 'upper' must be finite values"
msgstr "'lower' et 'upper' doivent être des valeurs finies"

#. R/kernel.R: stop("'m' is less than 1")
#: R/kernel.R:0
msgid "'m' is less than 1"
msgstr "'m' est inférieur à 1"

#. R/kernel.R: stop("'m' must be numeric with non-negative integers")
#: R/kernel.R:0
msgid "'m' must be numeric with non-negative integers"
msgstr "'m' doit être numérique et contenir des entiers non négatifs"

#. R/termplot.R: stop("'main' must be TRUE, FALSE, NULL or character (vector).")
#: R/termplot.R:0
msgid "'main' must be TRUE, FALSE, NULL or character (vector)."
msgstr "'main' doit être TRUE, FALSE, NULL or caractère (vecteur)."

#. R/loglin.R: stop("'margin' must contain names or numbers corresponding to 'table'")
#: R/loglin.R:0
msgid "'margin' must contain names or numbers corresponding to 'table'"
msgstr "'margin' doit contenir les noms ou des nombres correspondant à 'table'"

#. R/dendrogram.R: stop("'margins' must be a numeric vector of length 2")
#: R/dendrogram.R:0
msgid "'margins' must be a numeric vector of length 2"
msgstr "'margins' doit être un vecteur numérique de longueur 2"

#. R/mlm.R: stop("'mlm' objects with weights are not supported")
#: R/mlm.R:0
msgid "'mlm' objects with weights are not supported"
msgstr "les objets 'mlm' pondérés ne sont pas supportés"

#. R/ts.R: stop("'model$order' must be of length 3")
#: R/ts.R:0
msgid "'model$order' must be of length 3"
msgstr "'model$order' doit être de longueur 3"

#. R/ts.R: stop("'model' must be list")
#: R/ts.R:0
msgid "'model' must be list"
msgstr "'model' doit être une liste"

#. R/model.tables.R: stop("'model.tables' is not implemented for multiple responses")
#: R/model.tables.R:0
msgid "'model.tables' is not implemented for multiple responses"
msgstr "'model.tables' n'est pas implémenté pour les réponses multiples"

#. R/t.test.R: stop("'mu' must be a single number")
#. R/wilcox.test.R: stop("'mu' must be a single number")
#: R/t.test.R:0 R/wilcox.test.R:0
msgid "'mu' must be a single number"
msgstr "'mu' doit être un nombre"

#. R/fisher.test.R: stop("'mult' must be integer >= 2, typically = 30")
#: R/fisher.test.R:0
msgid "'mult' must be integer >= 2, typically = 30"
msgstr "'mult' doit être un entier >= 2, typiquement = 30"

#. R/binom.test.R: stop("'n' must be a positive integer >= 'x'")
#: R/binom.test.R:0
msgid "'n' must be a positive integer >= 'x'"
msgstr "'n' doit être un entier positif >= 'x'"

#. R/ts.R: stop("'n' must be strictly positive")
#: R/ts.R:0
msgid "'n' must be strictly positive"
msgstr "'n' doit être un nombre strictement positif"

#. R/ar.R: stop("'n.ahead' must be at least 1")
#: R/ar.R:0
msgid "'n.ahead' must be at least 1"
msgstr "'n.ahead' doit valoir au moins 1"

#. R/prcomp.R: stop("'newdata' does not have named columns matching one or more of the original columns")
#. R/princomp-add.R: stop("'newdata' does not have named columns matching one or more of the original columns")
#: R/prcomp.R:0 R/princomp-add.R:0
msgid "'newdata' does not have named columns matching one or more of the original columns"
msgstr "'newdata' n'a pas de colonnes dont les noms correspondent à des colonnes d'origine"

#. R/prcomp.R: stop("'newdata' does not have the correct number of columns")
#. R/princomp-add.R: stop("'newdata' does not have the correct number of columns")
#: R/prcomp.R:0 R/princomp-add.R:0
msgid "'newdata' does not have the correct number of columns"
msgstr "'newdata' n'a pas le bon nombre de colonnes"

#. R/prcomp.R: stop("'newdata' must be a matrix or data frame")
#. R/princomp-add.R: stop("'newdata' must be a matrix or data frame")
#: R/prcomp.R:0 R/princomp-add.R:0
msgid "'newdata' must be a matrix or data frame"
msgstr "'newdata' doit être une matrice ou un tableau de données"

#. R/smspline.R: stop("'nknots' must be at least 1")
#: R/smspline.R:0
msgid "'nknots' must be at least 1"
msgstr "'nknots' doit valoir au moins 1"

#. R/smspline.R: stop("'nknots' must be numeric (in {1,..,n})")
#: R/smspline.R:0
msgid "'nknots' must be numeric (in {1,..,n})"
msgstr "'nknots' doit être numérique (dans {1, ..., n})"

#. R/ppr.R: stop("'nterms' is missing with no default")
#: R/ppr.R:0
msgid "'nterms' is missing with no default"
msgstr "'nterms' manque, sans valeur par défaut"

#. R/aov.R: stop("'object' does not include an error 'qr' component")
#: R/aov.R:0
msgid "'object' does not include an error 'qr' component"
msgstr "'object' ne contient pas de composante d'erreur 'qr'"

#. R/lm.R: stop("'object' has no 'effects' component")
#: R/lm.R:0
msgid "'object' has no 'effects' component"
msgstr "'object' n'a pas de composante 'effects'"

#. R/models.R: stop("'offset' must be numeric")
#: R/models.R:0
msgid "'offset' must be numeric"
msgstr "'offset' doit être numérique"

#. R/fisher.test.R: stop("'or' must be a single number between 0 and Inf")
#: R/fisher.test.R:0
msgid "'or' must be a single number between 0 and Inf"
msgstr "'or' doit être un nombre positif ou nul"

#. R/arima.R: stop("'order' must be a non-negative numeric vector of length 3")
#. R/arma0.R: stop("'order' must be a non-negative numeric vector of length 3")
#: R/arima.R:0 R/arma0.R:0
msgid "'order' must be a non-negative numeric vector of length 3"
msgstr "'order' doit être un vecteur numérique positif ou nul de longueur 3"

#. R/dendrogram.R: stop("'order.dendrogram' requires a dendrogram")
#: R/dendrogram.R:0
msgid "'order.dendrogram' requires a dendrogram"
msgstr "'order.dendrogram' nécessite un dendrogramme"

#. R/ar.R: stop("'order.max' must be < 'n.obs'")
#: R/ar.R:0
msgid "'order.max' must be < 'n.obs'"
msgstr "'order.max' doit être < 'n.obs'"

#. R/ar.R: stop("'order.max' must be < 'n.used'")
#: R/ar.R:0
msgid "'order.max' must be < 'n.used'"
msgstr "'order.max' doit être < 'n.used'"

#. R/ar.R: stop("'order.max' must be >= 0")
#: R/ar.R:0
msgid "'order.max' must be >= 0"
msgstr "'order.max' doit être >= 0"

#. R/ar.R: stop("'order.max' must be >= 1")
#: R/ar.R:0
msgid "'order.max' must be >= 1"
msgstr "'order.max' doit être >= 1"

#. R/binom.test.R: stop("'p' must be a single number between 0 and 1")
#: R/binom.test.R:0
msgid "'p' must be a single number between 0 and 1"
msgstr "'p' doit être un nombre unique entre 0 et 1"

#. R/spectrum.R: stop("'p' must be between 0 and 0.5")
#: R/spectrum.R:0
msgid "'p' must be between 0 and 0.5"
msgstr "'p' doit être compris entre 0 et 0.5"

#. R/prop.test.R: stop("'p' must have the same length as 'x' and 'n'")
#: R/prop.test.R:0
msgid "'p' must have the same length as 'x' and 'n'"
msgstr "'p' doit avoir la même longueur que 'x' et 'n'"

#. R/nls-profile.R: stop("'params' has wrong length")
#: R/nls-profile.R:0
msgid "'params' has wrong length"
msgstr "'params' n'a pas la bonne longueur"

#. R/stepfun.R: stop("'plot.stepfun' called with wrong type of argument 'x'")
#: R/stepfun.R:0
msgid "'plot.stepfun' called with wrong type of argument 'x'"
msgstr "appel à 'plot.stepfun' avec un argument 'x' de type incorrect"

#. R/ppr.R: stop("'ppr' applies only to numerical variables")
#: R/ppr.R:0
msgid "'ppr' applies only to numerical variables"
msgstr "'ppr' ne s'applique qu'aux variables numériques"

#. R/princomp.R: stop("'princomp' can only be used with more units than variables")
#: R/princomp.R:0
msgid "'princomp' can only be used with more units than variables"
msgstr "'princomp' ne peut être utilisé que si le nombre d'unités est supérieur au nombre de variables"

#. R/nlm.R: stop("'print.level' must be in {0,1,2}")
#: R/nlm.R:0
msgid "'print.level' must be in {0,1,2}"
msgstr "'print.level' doit appartenir à {0,1,2}"

#. R/distn.R: stop("'prob' and 'mu' both specified")
#: R/distn.R:0
msgid "'prob' and 'mu' both specified"
msgstr "'prob' et 'mu' spécifiés tous les deux"

#. R/quantile.R: stop("'probs' outside [0,1]")
#: R/quantile.R:0
msgid "'probs' outside [0,1]"
msgstr "'probs' en dehors de [0,1]"

#. R/proj.R: stop("'proj' is not implemented for multiple responses")
#: R/proj.R:0
msgid "'proj' is not implemented for multiple responses"
msgstr "'proj' n'est pas implémenté pour les réponses multiples"

#. R/kernel.R: stop("'r' is less than 0")
#: R/kernel.R:0
msgid "'r' is less than 0"
msgstr "'r' est inférieur à 0"

#. R/kernel.R: stop("'r' is less than 1")
#: R/kernel.R:0
msgid "'r' is less than 1"
msgstr "'r' est inférieur à 1"

#. R/poisson.test.R: stop("'r' must be a single positive number")
#: R/poisson.test.R:0
msgid "'r' must be a single positive number"
msgstr "'r' doit être un nombre positif"

#. R/var.test.R: stop("'ratio' must be a single positive number")
#: R/var.test.R:0
msgid "'ratio' must be a single positive number"
msgstr "'ratio' doit être un nombre positif"

#. R/relevel.R: stop("'ref' must be an existing level")
#: R/relevel.R:0
msgid "'ref' must be an existing level"
msgstr "'ref' doit être un niveau existant"

#. R/relevel.R: stop("'ref' must be of length one")
#: R/relevel.R:0
msgid "'ref' must be of length one"
msgstr "'ref' doit être de longueur un"

#. R/relevel.R: stop("'relevel' only for (unordered) factors")
#: R/relevel.R:0
msgid "'relevel' only for (unordered) factors"
msgstr "'relevel' n'est utilisable que pour des facteurs (non ordonnés)"

#. R/relevel.R: stop("'relevel' only for unordered factors")
#: R/relevel.R:0
msgid "'relevel' only for unordered factors"
msgstr "'relevel' n'est utilisable que pour des facteurs non ordonnés"

#. R/dendrogram.R: stop("'reorder.dendrogram' requires a dendrogram")
#: R/dendrogram.R:0
msgid "'reorder.dendrogram' requires a dendrogram"
msgstr "'reorder.dendrogram' nécessite un dendrogramme"

#. R/ftable.R: stop("'row.var.names' missing")
#: R/ftable.R:0
msgid "'row.var.names' missing"
msgstr "'row.var.names' manquant"

#. R/acf.R: stop("'sampleT' and 'nser' must be integer")
#: R/acf.R:0
msgid "'sampleT' and 'nser' must be integer"
msgstr "'sampleT' et 'nser' doivent être des entiers"

#. R/biplot.R: warning("'scale' is outside [0, 1]")
#: R/biplot.R:0
msgid "'scale' is outside [0, 1]"
msgstr "'scale' est en dehors de [0, 1]"

#. R/contr.poly.R: stop("'scores' argument is of the wrong length")
#: R/contr.poly.R:0
msgid "'scores' argument is of the wrong length"
msgstr "l'argument 'scores' n'a pas la bonne longueur"

#. R/contr.poly.R: stop("'scores' must all be different numbers")
#: R/contr.poly.R:0
msgid "'scores' must all be different numbers"
msgstr "'scores' doivent être des nombres tous différents"

#. R/ar.R: warning("'se.fit' not yet implemented for multivariate models")
#: R/ar.R:0
msgid "'se.fit' not yet implemented for multivariate models"
msgstr "'se.fit' n'est pas encore implémenté pour des modèles multivariés"

#. R/arima.R: stop("'seasonal$order' must be a non-negative numeric vector of length 3")
#. R/arma0.R: stop("'seasonal$order' must be a non-negative numeric vector of length 3")
#: R/arima.R:0 R/arma0.R:0
msgid "'seasonal$order' must be a non-negative numeric vector of length 3"
msgstr "'seasonal$order' doit être un vecteur numérique positif ou nul de longueur 3"

#. R/arima.R: stop("'seasonal' is neither a list with component 'order' nor a numeric vector of length 3")
#. R/arma0.R: stop("'seasonal' is neither a list with component 'order' nor a numeric vector of length 3")
#: R/arima.R:0 R/arma0.R:0
#, fuzzy
msgid "'seasonal' is neither a list with component 'order' nor a numeric vector of length 3"
msgstr "'seasonal' doit être une liste possédant une composante 'order'"

#. R/arima.R: stop("'seasonal' must be a list with component 'order'")
#. R/arma0.R: stop("'seasonal' must be a list with component 'order'")
#: R/arima.R:0 R/arma0.R:0
msgid "'seasonal' must be a list with component 'order'"
msgstr "'seasonal' doit être une liste possédant une composante 'order'"

#. R/smspline.R: stop("'span' must be between 0 and 1.")
#: R/smspline.R:0
msgid "'span' must be between 0 and 1."
msgstr "'span' doit être compris entre 0 et 1."

#. R/smspline.R: stop("'spar' must be of length 1")
#: R/smspline.R:0
msgid "'spar' must be of length 1"
msgstr "'spar' doit être de longueur 1"

#. R/spline.R: stop("'spline' requires n >= 1")
#: R/spline.R:0
msgid "'spline' requires n >= 1"
msgstr "'spline' nécessite n >= 1"

#. R/ts.R: stop("'start' > 'end'")
#: R/ts.R:0
msgid "'start' > 'end'"
msgstr "'start' > 'end'"

#. R/loglin.R: stop("'start' and 'table' must be same length")
#: R/loglin.R:0
msgid "'start' and 'table' must be same length"
msgstr "'start' et 'table' doivent avoir la même longueur"

#. R/ts.R: stop("'start' cannot be after 'end'")
#: R/ts.R:0
msgid "'start' cannot be after 'end'"
msgstr "'start' ne peut pas être après 'end'"

#. R/ts.R: warning("'start' value not changed")
#: R/ts.R:0
msgid "'start' value not changed"
msgstr "valeur de 'start' inchangée"

#. R/models.R: stop("'termlabels' must be a character vector")
#: R/models.R:0
#, fuzzy
msgid "'termlabels' must be a character vector"
msgstr "'termlabels' doit être un vecteur de caractères de longueur >= 1"

#. R/models.R: gettextf("'termobj' must be a object of class %s", dQuote("terms"))
#: R/models.R:0
msgid "'termobj' must be a object of class %s"
msgstr "'termobj' doit être un objet de classe %s"

#. R/approx.R: stop("'ties' is not \"ordered\", a function, or list(<string>, <function>)")
#: R/approx.R:0
msgid "'ties' is not \"ordered\", a function, or list(<string>, <function>)"
msgstr "'ties' n’est pas \"ordered\", une function, ou une list(<string>, <function>)"

#. R/smspline.R: stop("'tol' must be strictly positive and finite")
#: R/smspline.R:0
msgid "'tol' must be strictly positive and finite"
msgstr "'top' doit être un nombre positif et non infini"

#. R/optim.R: stop("'trace != 0' needs 'REPORT >= 1'")
#: R/optim.R:0
msgid "'trace != 0' needs 'REPORT >= 1'"
msgstr "'trace != 0' nécessite 'REPORT >= 1'"

#. R/ts.R: stop("'ts' object must have one or more observations")
#: R/ts.R:0
msgid "'ts' object must have one or more observations"
msgstr "un objet 'ts' doit avoir au moins une observation"

#. R/quantile.R: stop("'type' must be 1 or 3 for ordered factors")
#: R/quantile.R:0
msgid "'type' must be 1 or 3 for ordered factors"
msgstr "'type' doit être 1 ou 3 pour les facteurs ordonnés"

#. R/quantile.R: stop("'type' must be an integer in 1..9")
#: R/quantile.R:0
#, fuzzy
msgid "'type' must be an integer in 1..9"
msgstr "'y' doit être plus long que 'x' de un"

#. R/family.R: gettextf("'variance' \"%s\" is invalid: possible values are \"mu(1-mu)\", \"mu\", \"mu^2\", \"mu^3\" and \"constant\"",     vtemp)
#: R/family.R:0
msgid "'variance' \"%s\" is invalid: possible values are \"mu(1-mu)\", \"mu\", \"mu^2\", \"mu^3\" and \"constant\""
msgstr "'variance' \"%s\" est incorrecte : les valeurs possibles sont \"mu(1-mu)\", \"mu\", \"mu^2\", \"mu^3\" et \"constant\""

#. R/reshape.R: stop("'varying' arguments must be the same length")
#: R/reshape.R:0
msgid "'varying' arguments must be the same length"
msgstr "les arguments varying doivent avoir la même longueur"

#. R/nls-profile.R: stop("'varying' has wrong length")
#: R/nls-profile.R:0
msgid "'varying' has wrong length"
msgstr "'varying' n'a pas la bonne longueur"

#. R/nls-profile.R: stop("'varying' must be in seq_along(pars)")
#: R/nls-profile.R:0
msgid "'varying' must be in seq_along(pars)"
msgstr "'varying' doit appartenir à seq_along(pars)"

#. R/nls-profile.R: stop("'varying' must be logical, integer or character")
#: R/nls-profile.R:0
msgid "'varying' must be logical, integer or character"
msgstr "'varying' doit être logique, entier ou caractère"

#. R/reshape.R: stop("'varying' must be nonempty list or vector")
#: R/reshape.R:0
msgid "'varying' must be nonempty list or vector"
msgstr "'varying' doit être une liste ou un vecteur non vide"

#. R/lm.R: stop("'weights' as formula should be one-sided")
#: R/lm.R:0
msgid "'weights' as formula should be one-sided"
msgstr "'weights' comme formule ne peut avoir qu'un seul membre"

#. R/density.R: stop("'weights' must all be finite")
#: R/density.R:0
msgid "'weights' must all be finite"
msgstr "tous les poids ('weights' doivent être des valeurs finies"

#. R/glm.R: stop("'weights' must be a numeric vector")
#. R/lm.R: stop("'weights' must be a numeric vector")
#: R/glm.R:0 R/lm.R:0
msgid "'weights' must be a numeric vector"
msgstr "'weights' doit être un vecteur numérique"

#. R/density.R: stop("'weights' must not be negative")
#: R/density.R:0
msgid "'weights' must not be negative"
msgstr "'weights' ne peuvent être négatifs"

#. R/plot.lm.R: stop("'which' must be in 1:6")
#: R/plot.lm.R:0
msgid "'which' must be in 1:6"
msgstr "'which' doit être 1:6"

#. R/TukeyHSD.R: stop("'which' specified no factors")
#: R/TukeyHSD.R:0
msgid "'which' specified no factors"
msgstr "'which' ne spécifie aucun facteur"

#. R/TukeyHSD.R: warning("'which' specified some non-factors which will be dropped")
#: R/TukeyHSD.R:0
msgid "'which' specified some non-factors which will be dropped"
msgstr "'which' spécifie des variables non facteurs qui seront éliminées"

#. R/poisson.test.R: stop("'x' and 'T' have incompatible length")
#: R/poisson.test.R:0
msgid "'x' and 'T' have incompatible length"
msgstr "'x' et 'T' n'ont pas la même longueur"

#. R/bartlett.test.R: stop("'x' and 'g' must have the same length")
#. R/fligner.test.R: stop("'x' and 'g' must have the same length")
#. R/kruskal.test.R: stop("'x' and 'g' must have the same length")
#: R/bartlett.test.R:0 R/fligner.test.R:0 R/kruskal.test.R:0
msgid "'x' and 'g' must have the same length"
msgstr "'x' et 'g' doivent avoir la même longueur"

#. R/pairwise.R: stop("'x' and 'n' must have the same length")
#. R/prop.test.R: stop("'x' and 'n' must have the same length")
#: R/pairwise.R:0 R/prop.test.R:0
msgid "'x' and 'n' must have the same length"
msgstr "'x' et 'n' doivent avoir la même longueur"

#. R/chisq.test.R: stop("'x' and 'p' must have the same number of elements")
#: R/chisq.test.R:0
msgid "'x' and 'p' must have the same number of elements"
msgstr "'x' and 'p' doivent avoir le même nombre d'éléments"

#. R/weighted.mean.R: stop("'x' and 'w' must have the same length")
#: R/weighted.mean.R:0
msgid "'x' and 'w' must have the same length"
msgstr "'x' et 'w' doivent avoir la même longueur"

#. R/density.R: stop("'x' and 'weights' have unequal length")
#: R/density.R:0
msgid "'x' and 'weights' have unequal length"
msgstr "'x' et 'weights' n'ont pas la même longueur"

#. R/chisq.test.R: stop("'x' and 'y' must have at least 2 levels")
#. R/fisher.test.R: stop("'x' and 'y' must have at least 2 levels")
#. R/mantelhaen.test.R: stop("'x' and 'y' must have at least 2 levels")
#: R/chisq.test.R:0 R/fisher.test.R:0 R/mantelhaen.test.R:0
msgid "'x' and 'y' must have at least 2 levels"
msgstr "'x' et 'y' doivent avoir au moins 2 niveaux"

#. R/chisq.test.R: stop("'x' and 'y' must have the same length")
#. R/cor.test.R: stop("'x' and 'y' must have the same length")
#. R/fisher.test.R: stop("'x' and 'y' must have the same length")
#. R/mcnemar.test.R: stop("'x' and 'y' must have the same length")
#. R/wilcox.test.R: stop("'x' and 'y' must have the same length")
#: R/chisq.test.R:0 R/cor.test.R:0 R/fisher.test.R:0 R/mcnemar.test.R:0
#: R/wilcox.test.R:0
msgid "'x' and 'y' must have the same length"
msgstr "'x' et 'y' doivent avoir la même longueur"

#. R/mcnemar.test.R: stop("'x' and 'y' must have the same number of levels (minimum 2)")
#: R/mcnemar.test.R:0
msgid "'x' and 'y' must have the same number of levels (minimum 2)"
msgstr "'x' et 'y' doivent avoir le même nombre de niveaux (minimum 2)"

#. R/density.R: stop("'x' contains missing values")
#: R/density.R:0
msgid "'x' contains missing values"
msgstr "'x' contient une valeur manquante"

#. R/fisher.test.R: gettextf("'x' has been rounded to integer: %s", ax)
#: R/fisher.test.R:0
msgid "'x' has been rounded to integer: %s"
msgstr "'x' a été arrondi à un entier : %s"

#. R/fisher.test.R: stop("'x' has entries too large to be integer")
#: R/fisher.test.R:0
msgid "'x' has entries too large to be integer"
msgstr "'x' contient des valeurs trop grandes pour des entiers"

#. R/cancor.R: stop("'x' has rank 0")
#: R/cancor.R:0
msgid "'x' has rank 0"
msgstr "'x' est de rang 0"

#. R/kruskal.test.R: warning("'x' is a list, so ignoring argument 'g'")
#: R/kruskal.test.R:0
msgid "'x' is a list, so ignoring argument 'g'"
msgstr "'x' est une liste, donc l’argument 'g' est ignoré"

#. R/cor.R: stop("'x' is empty")
#: R/cor.R:0
msgid "'x' is empty"
msgstr "'x' est vide"

#. R/kernel.R: stop("'x' is not a kernel")
#: R/kernel.R:0
msgid "'x' is not a kernel"
msgstr "'x' n'est pas un noyau"

#. R/diffinv.R: stop("'x' is not a vector")
#. R/kernel.R: stop("'x' is not a vector")
#: R/diffinv.R:0 R/kernel.R:0
msgid "'x' is not a vector"
msgstr "'x' n'est pas un vecteur"

#. R/diffinv.R: stop("'x' is not a vector or matrix")
#. R/embed.R: stop("'x' is not a vector or matrix")
#: R/diffinv.R:0 R/embed.R:0
msgid "'x' is not a vector or matrix"
msgstr "'x' n'est pas un vecteur ou une matrice"

#. R/kernel.R: stop("'x' is shorter than kernel 'k'")
#: R/kernel.R:0
msgid "'x' is shorter than kernel 'k'"
msgstr "'x' est plus court que le noyau 'k'"

#. R/chisq.test.R: stop("'x' must at least have 2 elements")
#: R/chisq.test.R:0
msgid "'x' must at least have 2 elements"
msgstr "'x' doit avoir au moins 2 éléments"

#. R/splinefun.R: stop("'x' must be *strictly* increasing (non - NA)")
#: R/splinefun.R:0
msgid "'x' must be *strictly* increasing (non - NA)"
msgstr "'x' doit être *strictement* croissant (non - NA)"

#. R/mantelhaen.test.R: stop("'x' must be a 3-dimensional array")
#: R/mantelhaen.test.R:0
msgid "'x' must be a 3-dimensional array"
msgstr "'x' doit être un tableau de dimension 3"

#. R/bartlett.test.R: stop("'x' must be a list with at least 2 elements")
#. R/fligner.test.R: stop("'x' must be a list with at least 2 elements")
#. R/kruskal.test.R: stop("'x' must be a list with at least 2 elements")
#: R/bartlett.test.R:0 R/fligner.test.R:0 R/kruskal.test.R:0
msgid "'x' must be a list with at least 2 elements"
msgstr "'x' doit être une liste à 2 éléments"

#. R/lm.R: stop("'x' must be a matrix")
#: R/lm.R:0
msgid "'x' must be a matrix"
msgstr "'x' doit être une matrice"

#. R/cov.wt.R: stop("'x' must be a matrix or a data frame")
#: R/cov.wt.R:0
msgid "'x' must be a matrix or a data frame"
msgstr "'x' doit être une matrice ou un tableau de données"

#. R/dendrogram.R: stop("'x' must be a numeric matrix")
#: R/dendrogram.R:0
msgid "'x' must be a numeric matrix"
msgstr "'x' doit être une matrice numérique"

#. R/cor.test.R: stop("'x' must be a numeric vector")
#: R/cor.test.R:0
msgid "'x' must be a numeric vector"
msgstr "'x' doit être un vecteur numérique"

#. R/spectrum.R: stop("'x' must be a time series or an ar() fit")
#: R/spectrum.R:0
msgid "'x' must be a time series or an ar() fit"
msgstr "'x' doit être une série temporelle ou un ajustement ar()"

#. R/ftable.R: stop("'x' must be an \"ftable\" object")
#: R/ftable.R:0
msgid "'x' must be an \"ftable\" object"
msgstr "'x' doit être un objet \"ftable\""

#. R/symnum.R: gettextf("'x' must be between %s and %s", format(minc), format(maxc))
#: R/symnum.R:0
msgid "'x' must be between %s and %s"
msgstr "'x' doit être compris entre %s et %s"

#. R/symnum.R: gettext("'x' must be between -1 and 1")
#: R/symnum.R:0
msgid "'x' must be between -1 and 1"
msgstr "'x' doit être compris entre -1 et 1"

#. R/smspline.R: stop("'x' must be between 0 and 1 for periodic smooth")
#: R/smspline.R:0
msgid "'x' must be between 0 and 1 for periodic smooth"
msgstr "'x' doit être compris entre 0 et 1 pour un lissage périodique"

#. R/anova.R: stop("'x' must be coefficient matrix/data frame")
#: R/anova.R:0
msgid "'x' must be coefficient matrix/data frame"
msgstr "'x' doit être une matrice / un tableau de données contenant les coefficients"

#. R/poisson.test.R: stop("'x' must be finite, nonnegative, and integer")
#: R/poisson.test.R:0
msgid "'x' must be finite, nonnegative, and integer"
msgstr "'x' doit être un entier positif, fini ou nul"

#. R/distn.R: stop("'x' must be non-negative")
#: R/distn.R:0
msgid "'x' must be non-negative"
msgstr "'x' doit être positif ou nul"

#. R/binom.test.R: stop("'x' must be nonnegative and integer")
#: R/binom.test.R:0
msgid "'x' must be nonnegative and integer"
msgstr "'x' doit être un entier positif ou nul"

#. R/StructTS.R: stop("'x' must be numeric")
#. R/acf.R: stop("'x' must be numeric")
#. R/ar.R: stop("'x' must be numeric")
#. R/arima.R: stop("'x' must be numeric")
#. R/arma0.R: stop("'x' must be numeric")
#. R/cor.R: stop("'x' must be numeric")
#. R/wilcox.test.R: stop("'x' must be numeric")
#: R/StructTS.R:0 R/acf.R:0 R/ar.R:0 R/arima.R:0 R/arma0.R:0 R/cor.R:0
#: R/wilcox.test.R:0
msgid "'x' must be numeric"
msgstr "'x' doit être numérique"

#. R/mcnemar.test.R: stop("'x' must be square with at least two rows and columns")
#: R/mcnemar.test.R:0
msgid "'x' must be square with at least two rows and columns"
msgstr "'x' doit être carrée avec au moins deux lignes et deux colonnes"

#. R/cov.wt.R: stop("'x' must contain finite values only")
#: R/cov.wt.R:0
msgid "'x' must contain finite values only"
msgstr "'x' ne doit contenir que des valeurs définies"

#. R/ecdf.R: stop("'x' must have 1 or more non-missing values")
#: R/ecdf.R:0
msgid "'x' must have 1 or more non-missing values"
msgstr "'x' doit avoir au moins une valeur non manquante"

#. R/pairwise.R: stop("'x' must have 2 columns")
#. R/prop.test.R: stop("'x' must have 2 columns")
#: R/pairwise.R:0 R/prop.test.R:0
msgid "'x' must have 2 columns"
msgstr "'x' doit avoir 2 colonnes"

#. R/dendrogram.R: stop("'x' must have at least 2 rows and 2 columns")
#: R/dendrogram.R:0
msgid "'x' must have at least 2 rows and 2 columns"
msgstr "'x' doit avoir au moins 2 lignes et 2 colonnes"

#. R/fisher.test.R: stop("'x' must have at least 2 rows and columns")
#: R/fisher.test.R:0
msgid "'x' must have at least 2 rows and columns"
msgstr "'x' doit avoir au moins 2 lignes et colonnes"

#. R/stepfun.R: stop("'x' must have length >= 1")
#: R/stepfun.R:0
msgid "'x' must have length >= 1"
msgstr "'x' doit être de longueur >= 1"

#. R/mantelhaen.test.R: stop("'x', 'y', and 'z' must have the same length")
#: R/mantelhaen.test.R:0
msgid "'x', 'y', and 'z' must have the same length"
msgstr "'x', 'y', et 'z' doivent avoir la même longueur"

#. R/diffinv.R: stop("'xi' does not have the right length")
#: R/diffinv.R:0
msgid "'xi' does not have the right length"
msgstr "'xi' n'a pas la bonne longueur"

#. R/arima.R: stop("'xreg' and 'newxreg' have different numbers of columns")
#. R/arma0.R: stop("'xreg' and 'newxreg' have different numbers of columns")
#: R/arima.R:0 R/arma0.R:0
msgid "'xreg' and 'newxreg' have different numbers of columns"
msgstr "'xreg' et 'newxreg' ont des nombres de colonnes différents"

#. R/arma0.R: stop("'xreg' is collinear")
#: R/arma0.R:0
msgid "'xreg' is collinear"
msgstr "'xreg' est collinéaire"

#. R/ts.R: stop("'xy.labels' must be logical or character")
#: R/ts.R:0
msgid "'xy.labels' must be logical or character"
msgstr "'xy.labels' doit être logique ou caractère"

#. R/cancor.R: stop("'y' has rank 0")
#: R/cancor.R:0
msgid "'y' has rank 0"
msgstr "'y' est de rang 0"

#. R/t.test.R: stop("'y' is missing for paired test")
#. R/wilcox.test.R: stop("'y' is missing for paired test")
#: R/t.test.R:0 R/wilcox.test.R:0
msgid "'y' is missing for paired test"
msgstr "'y' est manquant pour un test apparié"

#. R/cor.test.R: stop("'y' must be a numeric vector")
#: R/cor.test.R:0
msgid "'y' must be a numeric vector"
msgstr "'y' doit être un vecteur numérique"

#. R/spline.R: stop("'y' must be increasing or decreasing")
#. R/splinefun.R: stop("'y' must be increasing or decreasing")
#: R/spline.R:0 R/splinefun.R:0
msgid "'y' must be increasing or decreasing"
msgstr "'y' doit être croissant ou décroissant"

#. R/cor.R: stop("'y' must be numeric")
#. R/wilcox.test.R: stop("'y' must be numeric")
#: R/cor.R:0 R/wilcox.test.R:0
msgid "'y' must be numeric"
msgstr "'y' doit être numérique"

#. R/ks.test.R: stop("'y' must be numeric or a function or a string naming a valid function")
#: R/ks.test.R:0
msgid "'y' must be numeric or a function or a string naming a valid function"
msgstr "'y' doit être numérique ou une fonction ou bien une chaîne de caractères donnant le nom d'une fonction adéquate"

#. R/smspline.R: stop("'y' must be numeric vector")
#: R/smspline.R:0
msgid "'y' must be numeric vector"
msgstr "'y' doit être un vecteur numérique"

#. R/stepfun.R: stop("'y' must be one longer than 'x'")
#: R/stepfun.R:0
msgid "'y' must be one longer than 'x'"
msgstr "'y' doit être plus long que 'x' de un"

#. R/friedman.test.R: stop("'y', 'groups' and 'blocks' must have the same length")
#. R/quade.test.R: stop("'y', 'groups' and 'blocks' must have the same length")
#: R/friedman.test.R:0 R/quade.test.R:0
msgid "'y', 'groups' and 'blocks' must have the same length"
msgstr "'y', 'groups' et 'blocks' doivent avoir la même longueur"

#. R/quantile.R: stop("(unordered) factors are not allowed")
#: R/quantile.R:0
msgid "(unordered) factors are not allowed"
msgstr "les facteurs (non ordonnés) ne sont pas autorisés"

#. R/lm.R: stop("0 (non-NA) cases")
#: R/lm.R:0
msgid "0 (non-NA) cases"
msgstr "aucun cas ne contient autre chose que des valeurs manquantes (NA)"

#. R/glm.R: stop("0s in V(mu)")
#: R/glm.R:0
msgid "0s in V(mu)"
msgstr "0 dans V(mu)"

#. R/add.R: stop("AIC is -infinity for this model, so 'step' cannot proceed")
#: R/add.R:0
msgid "AIC is -infinity for this model, so 'step' cannot proceed"
msgstr "AIC vaut -infini pour ce modèle, donc 'step' ne peut poursuivre"

#. R/add.R: stop("AIC is not defined for this model, so 'step' cannot proceed")
#: R/add.R:0
msgid "AIC is not defined for this model, so 'step' cannot proceed"
msgstr "AIC n'est pas défini pour ce modèle, donc 'step' ne peut poursuivre"

#. R/lm.R: warning("ANOVA F-tests on an essentially perfect fit are unreliable")
#: R/lm.R:0
msgid "ANOVA F-tests on an essentially perfect fit are unreliable"
msgstr "Les tests F d'ANOVA sur un ajustement pratiquement parfait ne sont pas fiables"

#. R/lm.R: warning("Assuming constant prediction variance even though model fit is weighted\n")
#: R/lm.R:0
msgid "Assuming constant prediction variance even though model fit is weighted"
msgstr "Hypothèse d'une variance constante des prédictions, bien que le modèle ajusté soit pondéré"

#. R/constrOptim.R: gettext("Barrier algorithm ran out of iterations and did not converge")
#: R/constrOptim.R:0
msgid "Barrier algorithm ran out of iterations and did not converge"
msgstr "L’algorithme de barrière a atteint le nombre maximal d'itérations sans avoir convergé"

#. R/cor.test.R: warning("Cannot compute exact p-value with ties")
#: R/cor.test.R:0
msgid "Cannot compute exact p-value with ties"
msgstr "Impossible de calculer la p-value exacte avec des ex-aequos"

#. R/chisq.test.R: warning("Chi-squared approximation may be incorrect")
#. R/prop.test.R: warning("Chi-squared approximation may be incorrect")
#: R/chisq.test.R:0 R/prop.test.R:0
msgid "Chi-squared approximation may be incorrect"
msgstr "L’approximation du Chi-2 est peut-être incorrecte"

#. R/dendrogram.R: stop("Colv = \"Rowv\" but nrow(x) != ncol(x)")
#: R/dendrogram.R:0
msgid "Colv = \"Rowv\" but nrow(x) != ncol(x)"
msgstr "Colv = \"Rowv\" mais nrow(x) != ncol(x)"

#. R/hclust.R: gettextf("\n Consider providing an as.hclust.%s() method", oldClass(x)[1L])
#: R/hclust.R:0
msgid "Consider providing an as.hclust.%s() method"
msgstr "Envisagez de fournir une méthode as.hclust.%s()"

#. R/model.tables.R: message("Design is unbalanced - use se.contrast() for se's")
#: R/model.tables.R:0
msgid "Design is unbalanced - use se.contrast() for se's"
msgstr "Le plan n'est pas équilibré - utilisez se.contrast() pour les erreur-types"

#. R/aov.R: warning("Error() model is singular")
#: R/aov.R:0
msgid "Error() model is singular"
msgstr "Le modèle Error() est singulier (bizarre)"

#. R/add.R: gettextf("F test assumes 'quasi%s' family", fam)
#: R/add.R:0
msgid "F test assumes 'quasi%s' family"
msgstr "Le test F implique une famille 'quasi%s'"

#. R/add.R: gettextf("F test assumes quasi%s family", fam)
#: R/add.R:0
msgid "F test assumes quasi%s family"
msgstr "Le test F implique une famille quasi%s"

#. R/arima.R: warning("MA part of model is not invertible")
#. R/arma0.R: warning("MA part of model is not invertible")
#: R/arima.R:0 R/arma0.R:0
msgid "MA part of model is not invertible"
msgstr "La partie MA du modèle est non inversible"

#. R/ar.R: stop("MLE only implemented for univariate series")
#: R/ar.R:0
msgid "MLE only implemented for univariate series"
msgstr "MLE n'est implémenté que pour des séries univariées"

#. R/smspline.R: stop("NA lev[]; probably smoothing parameter 'spar' way too large!")
#: R/smspline.R:0
msgid "NA lev[]; probably smoothing parameter 'spar' way too large!"
msgstr "NA lev[] ; le paramètre de lissage 'spar' est probablement beaucoup trop grand !"

#. R/cmdscale.R: stop("NA values not allowed in 'd'")
#: R/cmdscale.R:0
msgid "NA values not allowed in 'd'"
msgstr "NA non autorisées dans 'd'"

#. R/friedman.test.R: stop("NA's are not allowed in 'groups' or 'blocks'")
#. R/quade.test.R: stop("NA's are not allowed in 'groups' or 'blocks'")
#: R/friedman.test.R:0 R/quade.test.R:0
msgid "NA's are not allowed in 'groups' or 'blocks'"
msgstr "Les NAs ne sont pas autorisés dans 'groups' ou 'blocks'"

#. R/mantelhaen.test.R: stop("NAs are not allowed")
#: R/mantelhaen.test.R:0
msgid "NAs are not allowed"
msgstr "NA non autorisés"

#. R/arima.R: gettextf("NAs in '%s'", "phi")
#. R/arima.R: gettextf("NAs in '%s'", "theta")
#: R/arima.R:0
msgid "NAs in '%s'"
msgstr "NAs dans '%s'"

#. R/acf.R: stop("NAs in 'x'")
#. R/ar.R: stop("NAs in 'x'")
#: R/acf.R:0 R/ar.R:0
msgid "NAs in 'x'"
msgstr "NAs dans 'x'"

#. R/ar.R: stop("NAs in 'x' must be the same row-wise")
#: R/ar.R:0
msgid "NAs in 'x' must be the same row-wise"
msgstr "L’es Nos dans 'x' doivent être les mêmes selon les lignes"

#. R/glm.R: stop("NAs in V(mu)")
#: R/glm.R:0
msgid "NAs in V(mu)"
msgstr "NA dans V(mu)"

#. R/glm.R: stop("NAs in d(mu)/d(eta)")
#: R/glm.R:0
msgid "NAs in d(mu)/d(eta)"
msgstr "NA dans d(mu)/d(eta)"

#. R/arma0.R: warning("NAs present: setting 'delta' to -1")
#: R/arma0.R:0
msgid "NAs present: setting 'delta' to -1"
msgstr "Présence de NAs : 'delta' fixé à -1"

#. R/power.R: warning("No p1 in [0, p2] can be found to achieve the desired power")
#: R/power.R:0
msgid "No p1 in [0, p2] can be found to achieve the desired power"
msgstr "Aucun p1 trouvé dans [0, p2] pour obtenir la puissance désirée"

#. R/power.R: warning("No p2 in [p1, 1] can be found to achieve the desired power")
#: R/power.R:0
msgid "No p2 in [p1, 1] can be found to achieve the desired power"
msgstr "Aucun p2 trouvé dans [p1, 0] pour obtenir la puissance désirée"

#. R/power.R: warning("No significance level [0, 1] can be found to achieve the desired power")
#: R/power.R:0
msgid "No significance level [0, 1] can be found to achieve the desired power"
msgstr "Aucun niveau significatif [0, 1] n’est trouvé pour obtenir la puissance désirée"

#. R/smspline.R: stop("Numeric 'all.knots' must be strictly increasing")
#: R/smspline.R:0
msgid "Numeric 'all.knots' must be strictly increasing"
msgstr "Les nombres 'all.knots' doivent être strictement croissants"

#. R/constrOptim.R: gettextf("Objective function decreased at outer iteration %d",     i)
#: R/constrOptim.R:0
msgid "Objective function decreased at outer iteration %d"
msgstr "La fonction objective a diminué dans l'itération externe %d"

#. R/constrOptim.R: gettextf("Objective function increased at outer iteration %d",     i)
#: R/constrOptim.R:0
msgid "Objective function increased at outer iteration %d"
msgstr "La fonction objective a augmenté dans l'itération externe %d"

#. R/prcomp.R: stop("PCA applies only to numerical variables")
#. R/princomp.R: stop("PCA applies only to numerical variables")
#: R/prcomp.R:0 R/princomp.R:0
msgid "PCA applies only to numerical variables"
msgstr "L’ACP ne s'applique qu'à des valeurs numériques"

#. R/acf.R: gettextf("Page [%d,%d]: i =%s; j =%s", I, J, paste(iind, collapse = ","),     paste(jind, collapse = ","))
#: R/acf.R:0
msgid "Page [%d,%d]: i =%s; j =%s"
msgstr "Page [%d,%d] : i =%s ; j =%s"

#. R/ks.test.R: gettextf("Parameter(s) %s ignored", paste(names(args), collapse = ", "))
#: R/ks.test.R:0
#, fuzzy
msgid "Parameter(s) %s ignored"
msgstr "paramètres à ajuster"

#. R/glm-profile.R: gettext("\nParameter: ", domain = "R-stats")
#: R/glm-profile.R:0
msgid "Parameter:"
msgstr ""

#. R/kmeans.R: gettextf("Quick-TRANSfer stage steps exceeded maximum (= %d)",     isteps.Qtran)
#: R/kmeans.R:0
msgid "Quick-TRANSfer stage steps exceeded maximum (= %d)"
msgstr "Les étapes de transfer (quick-TRANSfer stage) ont dépassé le maximum (= %d)"

#. R/aov.R: message("Refitting model to allow projection")
#: R/aov.R:0
msgid "Refitting model to allow projection"
msgstr "Réajustement du modèle pour permettre la projection"

#. R/confint.R: gettextf("Reprofiling for %s  statistic. Waiting...", test)
#: R/confint.R:0
msgid "Reprofiling for %s  statistic. Waiting..."
msgstr ""

#. R/wilcox.test.R: warning("Requested conf.level not achievable")
#: R/wilcox.test.R:0
msgid "Requested conf.level not achievable"
msgstr "Requête 'conf.level' impossible à atteindre"

#. R/model.tables.R: gettextf("SEs for type '%s' are not yet implemented", type)
#: R/model.tables.R:0
msgid "SEs for type '%s' are not yet implemented"
msgstr "Les erreur-types pour le type '%s' ne sont pas encore implémentées"

#. R/density.R: warning("Selecting bandwidth *not* using 'weights'")
#: R/density.R:0
msgid "Selecting bandwidth *not* using 'weights'"
msgstr ""

#. R/model.tables.R: message("Standard error information not returned as design is unbalanced. \nStandard errors can be obtained through 'se.contrast'.")
#: R/model.tables.R:0
msgid ""
"Standard error information not returned as design is unbalanced. \n"
"Standard errors can be obtained through 'se.contrast'."
msgstr ""
"Erreur-type non retournée car le plan est déséquilibré. \n"
"L'erreur-type peut être obtenue grâce à 'se.contrast'."

#. R/hclust.R: message("The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\"")
#: R/hclust.R:0
msgid "The \"ward\" method has been renamed to \"ward.D\"; note new \"ward.D2\""
msgstr "La méthode \"ward\" a été renommée \"ward.D\"; notez la nouvelle méthode \"ward.D2\""

#. R/models.R: sprintf("Unparseable 'response' \"%s\"; use is deprecated.  Use as.name(.) or `..`!",     response)
#: R/models.R:0
msgid "Unparseable 'response' \"%s\"; use is deprecated.  Use as.name(.) or `..`!"
msgstr "Impossible d’analyser le code de la reponse \"%s\" ; cet usage est obsolète. Utilisez as.name(.) ou `..` !"

#. R/confint.R: message("Waiting for profiling to be done...")
#: R/confint.R:0
msgid "Waiting for profiling to be done..."
msgstr ""

#. R/mlm.R: stop("X does not define a subspace of M")
#: R/mlm.R:0
msgid "X does not define a subspace of M"
msgstr "X ne défini pas un sous-espace de M"

#. R/integrate.R: stop("a limit is NA or NaN")
#: R/integrate.R:0
msgid "a limit is NA or NaN"
msgstr "une limite est NA ou NaN"

#. R/oneway.test.R: stop("a two-sided formula is required")
#: R/oneway.test.R:0
msgid "a two-sided formula is required"
msgstr "une formule à deux membres est requise"

#. R/shapiro.test.R: stop("all 'x' values are identical")
#: R/shapiro.test.R:0
msgid "all 'x' values are identical"
msgstr "toutes les valeurs de 'x' sont identiques"

#. R/zzModels.R: stop("all 'x' values must be non-negative to fit the Weibull growth model")
#: R/zzModels.R:0
msgid "all 'x' values must be non-negative to fit the Weibull growth model"
msgstr "toutes les valeurs de 'x' doivent être positives ou nulles pour ajuster le modèle de croissance de Weibull"

#. R/identify.hclust.R: gettextf("all elements of 'which' must be between 1 and %d",     k)
#: R/identify.hclust.R:0
msgid "all elements of 'which' must be between 1 and %d"
msgstr "tous les éléments de 'which' doivent être compris entre 1 et %d"

#. R/chisq.test.R: stop("all entries of 'x' must be nonnegative and finite")
#. R/fisher.test.R: stop("all entries of 'x' must be nonnegative and finite")
#. R/mcnemar.test.R: stop("all entries of 'x' must be nonnegative and finite")
#: R/chisq.test.R:0 R/fisher.test.R:0 R/mcnemar.test.R:0
msgid "all entries of 'x' must be nonnegative and finite"
msgstr "toutes les valeurs de 'x' doivent être positives ou nulles et définies"

#. R/fligner.test.R: stop("all groups must contain data")
#. R/kruskal.test.R: stop("all groups must contain data")
#: R/fligner.test.R:0 R/kruskal.test.R:0
msgid "all groups must contain data"
msgstr "tous les groupes doivent contenir des données"

#. R/bartlett.test.R: stop("all observations are in the same group")
#. R/fligner.test.R: stop("all observations are in the same group")
#. R/kruskal.test.R: stop("all observations are in the same group")
#: R/bartlett.test.R:0 R/fligner.test.R:0 R/kruskal.test.R:0
msgid "all observations are in the same group"
msgstr "toutes les observations appartiennent au même groupe"

#. R/StructTS.R: stop("all parameters were fixed")
#. R/arma0.R: stop("all parameters were fixed")
#: R/StructTS.R:0 R/arma0.R:0
msgid "all parameters were fixed"
msgstr "tous les paramètres étaient fixés"

#. R/na.ts.R: stop("all times contain an NA")
#. R/ts.R: stop("all times contain an NA")
#: R/na.ts.R:0 R/ts.R:0
msgid "all times contain an NA"
msgstr "toutes les dates contiennent un NA"

#. R/smspline.R: stop("all weights should be non-negative")
#: R/smspline.R:0
msgid "all weights should be non-negative"
msgstr "tous les poids doivent être non négatifs"

#. R/fisher.test.R: stop("alternative must be \"two.sided\", \"less\" or \"greater\"")
#: R/fisher.test.R:0
msgid "alternative must be \"two.sided\", \"less\" or \"greater\""
msgstr "l'alternative doit être \"two.sided\", \"less\" or \"greater\""

#. R/hclust.R: stop("ambiguous clustering method", paste("", method))
#: R/hclust.R:0
msgid "ambiguous clustering method"
msgstr "méthode de classification ambigüe"

#. R/dist.R: stop("ambiguous distance method")
#: R/dist.R:0
msgid "ambiguous distance method"
msgstr "méthode de calcul de distance ambigüe"

#. R/nls.R: stop("anova is only defined for sequences of \"nls\" objects")
#: R/nls.R:0
msgid "anova is only defined for sequences of \"nls\" objects"
msgstr "anova n'est définie que pour des suites d'objets \"nls\""

#. R/nls.R: warning("argument 'na.action' will be ignored")
#: R/nls.R:0
msgid "argument 'na.action' will be ignored"
msgstr "l'argument 'na.action' sera ignoré"

#. R/selfStart.R: stop("argument 'object' has an impossible length")
#: R/selfStart.R:0
msgid "argument 'object' has an impossible length"
msgstr "la longueur de l'argument 'object' est incorrecte"

#. R/ks.test.R: stop("argument 'p' must be numeric")
#: R/ks.test.R:0
#, fuzzy
msgid "argument 'p' must be numeric"
msgstr "l'argument 'x' doit être numérique"

#. R/ks.test.R: stop("argument 'q' must be numeric")
#: R/ks.test.R:0
#, fuzzy
msgid "argument 'q' must be numeric"
msgstr "l'argument 'x' doit être numérique"

#. R/filter.R: stop("argument 'sides' must be 1 or 2")
#: R/filter.R:0
msgid "argument 'sides' must be 1 or 2"
msgstr "l'argument 'sides' doit valoir 1 ou 2"

#. R/ks.test.R: stop("argument 'sizes' must be a vector of length 2")
#: R/ks.test.R:0
#, fuzzy
msgid "argument 'sizes' must be a vector of length 2"
msgstr "'interval' doit être un vecteur de longueur 2"

#. R/nls.R: warning("argument 'subset' will be ignored")
#: R/nls.R:0
msgid "argument 'subset' will be ignored"
msgstr "l'argument 'subset' sera ignoré"

#. R/hclust.R: gettextf("argument 'x' cannot be coerced to class %s", dQuote("hclust"))
#: R/hclust.R:0
msgid "argument 'x' cannot be coerced to class %s"
msgstr "l'argument 'x' ne peut pas être converti automatiquement en objet de classe %s"

#. R/aggregate.R: stop("argument 'x' is  missing -- it has been renamed from 'formula'")
#: R/aggregate.R:0
#, fuzzy
msgid "argument 'x' is  missing -- it has been renamed from 'formula'"
msgstr "l'argument 'x' doit être numérique"

#. R/aggregate.R: stop("argument 'x' must be a formula")
#: R/aggregate.R:0
#, fuzzy
msgid "argument 'x' must be a formula"
msgstr "l'argument 'x' doit être numérique"

#. R/density.R: stop("argument 'x' must be numeric")
#: R/density.R:0
msgid "argument 'x' must be numeric"
msgstr "l'argument 'x' doit être numérique"

#. R/proj.R: stop("argument does not include a 'qr' component")
#: R/proj.R:0
msgid "argument does not include a 'qr' component"
msgstr "l'argument ne contient pas de composante 'qr'"

#. R/proj.R: stop("argument does not include an 'effects' component")
#: R/proj.R:0
msgid "argument does not include an 'effects' component"
msgstr "l'argument ne contient pas de composante 'effects'"

#. R/r2dtable.R: stop("arguments 'r' and 'c' must have the same sums")
#: R/r2dtable.R:0
msgid "arguments 'r' and 'c' must have the same sums"
msgstr "les arguments 'r' et 'c' doivent avoir la même somme"

#. R/aggregate.R: stop("arguments must have same length")
#: R/aggregate.R:0
msgid "arguments must have same length"
msgstr "les arguments doivent avoir la même longueur"

#. R/contr.poly.R: stop("arguments must have the same length")
#: R/contr.poly.R:0
msgid "arguments must have the same length"
msgstr "les arguments doivent avoir la même longueur"

#. R/lm.R: warning("assuming prediction variance inversely proportional to weights used for fitting\n")
#: R/lm.R:0
msgid "assuming prediction variance inversely proportional to weights used for fitting"
msgstr "l'hypothèse d'une variance des prédictions inversement proportionnelle aux poids est utilisée lors de l'ajustement"

#. R/chisq.test.R: stop("at least one entry of 'x' must be positive")
#: R/chisq.test.R:0
msgid "at least one entry of 'x' must be positive"
msgstr "au moins une valeur de 'x' doit être positive"

#. R/smooth.R: stop("attempt to smooth NA values")
#: R/smooth.R:0
msgid "attempt to smooth NA values"
msgstr "tentative de lisser des valeurs NA"

#. R/smooth.R: stop("attempt to smooth non-numeric values")
#: R/smooth.R:0
msgid "attempt to smooth non-numeric values"
msgstr "tentative de lisser des valeurs non numériques"

#. R/add.R: warning("attempting model selection on an essentially perfect fit is nonsense",     call. = FALSE)
#: R/add.R:0
msgid "attempting model selection on an essentially perfect fit is nonsense"
msgstr "tenter une sélection de modèle à partir d'un ajustement pratiquement parfait n'a pas de sens"

#. R/ts.R: stop("bad value for 'end'")
#: R/ts.R:0
msgid "bad value for 'end'"
msgstr "valeur de 'end' incorrecte"

#. R/diffinv.R: stop("bad value for 'lag' or 'differences'")
#. R/ts.R: stop("bad value for 'lag' or 'differences'")
#: R/diffinv.R:0 R/ts.R:0
msgid "bad value for 'lag' or 'differences'"
msgstr "valeur incorrecte de 'lag' ou 'differences'"

#. R/ts.R: stop("bad value for 'start'")
#: R/ts.R:0
msgid "bad value for 'start'"
msgstr "valeur de 'start' incorrecte"

#. R/runmed.R: stop("bandwidth 'k' must be >= 1 and odd!")
#: R/runmed.R:0
msgid "bandwidth 'k' must be >= 1 and odd!"
msgstr "la largeur de fenêtre 'k' doit être >=1 et impaire !"

#. R/contrast.R: stop("baseline group number out of range")
#: R/contrast.R:0
msgid "baseline group number out of range"
msgstr "nombre de groupe de base en dehors de l'intervalle"

#. R/biplot.R: stop("biplots are not defined for complex PCA")
#: R/biplot.R:0
msgid "biplots are not defined for complex PCA"
msgstr "les biplots ne sont pas définis pour une ACP complexe"

#. R/loess.R: warning("both 'span' and 'enp.target' specified: 'span' will be used")
#: R/loess.R:0
msgid "both 'span' and 'enp.target' specified: 'span' will be used"
msgstr "'span' et 'enp.target' ont tous deux été spécifiés : 'span' sera utilisé"

#. R/princomp.R: warning("both 'x' and 'covmat' were supplied: 'x' will be ignored")
#: R/princomp.R:0
msgid "both 'x' and 'covmat' were supplied: 'x' will be ignored"
msgstr "'x' et 'covmat' fournis tous les deux : 'x' sera ignoré"

#. R/cor.R: stop("both 'x' and 'y' must be non-empty")
#: R/cor.R:0
msgid "both 'x' and 'y' must be non-empty"
msgstr "'x' et 'y' ne peuvent être vides"

#. R/optim.R: warning("bounds can only be used with method L-BFGS-B (or Brent)")
#: R/optim.R:0
msgid "bounds can only be used with method L-BFGS-B (or Brent)"
msgstr "des bornes ne peuvent être fixées que pour la méthode L-BFGS-B (ou Brent)"

#. R/ts.R: stop("burn-in 'n.start' must be as long as 'ar + ma'")
#: R/ts.R:0
msgid "burn-in 'n.start' must be as long as 'ar + ma'"
msgstr "le burn-in 'n.start' doit être aussi long que 'ar + ma'"

#. R/lm.R: warning("calling anova.lm(<fake-lm-object>) ...")
#: R/lm.R:0
msgid "calling anova.lm(<fake-lm-object>) ..."
msgstr "appel à anova.lm(<faux-objet-lm>) ..."

#. R/lm.R: warning("calling predict.lm(<fake-lm-object>) ...")
#: R/lm.R:0
msgid "calling predict.lm(<fake-lm-object>) ..."
msgstr "appel à predict.lm(<faux-objet-lm>) ..."

#. R/lm.R: warning("calling summary.lm(<fake-lm-object>) ...")
#: R/lm.R:0
msgid "calling summary.lm(<fake-lm-object>) ..."
msgstr "appel à summary.lm(<faux-objet-lm>) ..."

#. R/acf.R: warning("can use ci.type=\"ma\" only if first lag is 0")
#: R/acf.R:0
msgid "can use ci.type=\"ma\" only if first lag is 0"
msgstr "ci.type=\"ma\" ne peut être utilisé que si le premier décalage vaut 0"

#. R/nls.R: stop("cannot calculate REML log-likelihood for \"nls\" objects")
#: R/nls.R:0
msgid "cannot calculate REML log-likelihood for \"nls\" objects"
msgstr "impossible de calculer la log-vraisemblance REML pour les objets \"nls\""

#. R/aggregate.R: gettextf("cannot change frequency from %g to %g", ofrequency,     nfrequency)
#: R/aggregate.R:0
msgid "cannot change frequency from %g to %g"
msgstr "impossible de changer la fréquence de %g à %g"

#. R/ansari.test.R: warning("cannot compute asymptotic confidence set or estimator")
#: R/ansari.test.R:0
msgid "cannot compute asymptotic confidence set or estimator"
msgstr "impossible de calculer l'intervalle de confiance asymptotique ou l'estimateur"

#. R/wilcox.test.R: warning("cannot compute confidence interval when all observations are tied",     call. = FALSE)
#: R/wilcox.test.R:0
msgid "cannot compute confidence interval when all observations are tied"
msgstr "impossible de calculer un intervalle de confiance avec des observations toutes égales"

#. R/wilcox.test.R: warning("cannot compute confidence interval when all observations are zero or tied",     call. = FALSE)
#: R/wilcox.test.R:0
msgid "cannot compute confidence interval when all observations are zero or tied"
msgstr "impossible de calculer un intervalle de confiance avec des observations toutes égales ou valant toutes zéro"

#. R/ansari.test.R: warning("cannot compute confidence set, returning NA")
#: R/ansari.test.R:0
msgid "cannot compute confidence set, returning NA"
msgstr "impossible de calculer l'intervalle de confiance, NA est renvoyé"

#. R/ansari.test.R: warning("cannot compute estimate, returning NA")
#: R/ansari.test.R:0
msgid "cannot compute estimate, returning NA"
msgstr "impossible de calculer l'estimation, NA est renvoyé"

#. R/wilcox.test.R: warning("cannot compute exact confidence interval with ties")
#: R/wilcox.test.R:0
msgid "cannot compute exact confidence interval with ties"
msgstr "impossible de calculer un intervalle de confiance exact avec des ex-aequos"

#. R/wilcox.test.R: warning("cannot compute exact confidence interval with zeroes")
#: R/wilcox.test.R:0
msgid "cannot compute exact confidence interval with zeroes"
msgstr "impossible de calculer un intervalle de confiance exact avec des zéros"

#. R/ansari.test.R: warning("cannot compute exact confidence intervals with ties")
#. R/wilcox.test.R: warning("cannot compute exact confidence intervals with ties")
#: R/ansari.test.R:0 R/wilcox.test.R:0
msgid "cannot compute exact confidence intervals with ties"
msgstr "impossible de calculer les intervalles de confiance exacts avec des ex-aequos"

#. R/ansari.test.R: warning("cannot compute exact p-value with ties")
#. R/wilcox.test.R: warning("cannot compute exact p-value with ties")
#: R/ansari.test.R:0 R/wilcox.test.R:0
msgid "cannot compute exact p-value with ties"
msgstr "impossible de calculer la p-value exacte avec des ex-aequos"

#. R/wilcox.test.R: warning("cannot compute exact p-value with zeroes")
#: R/wilcox.test.R:0
msgid "cannot compute exact p-value with zeroes"
msgstr "impossible de calculer une p-value exacte avec des zéros"

#. R/chisq.test.R: warning("cannot compute simulated p-value with zero marginals")
#: R/chisq.test.R:0
msgid "cannot compute simulated p-value with zero marginals"
msgstr "impossible de calculer la valeur de p simulée avec des marges nulles"

#. R/models.R: stop("cannot create a formula from a zero-column data frame")
#: R/models.R:0
msgid "cannot create a formula from a zero-column data frame"
msgstr "impossible de créer une formule à partir d'une tableau de données à zéro colonnes"

#. R/family.R: stop("cannot find valid starting values: please specify some")
#. R/glm.R: stop("cannot find valid starting values: please specify some",     call. = FALSE)
#: R/family.R:0 R/glm.R:0
msgid "cannot find valid starting values: please specify some"
msgstr "impossible de trouver des valeurs initiales correctes : prière d'en fournir"

#. R/zzModels.R: stop("cannot fit an asymptotic regression model to these data")
#: R/zzModels.R:0
msgid "cannot fit an asymptotic regression model to these data"
msgstr "impossible d'ajuster un modèle de régression asymptotique a ces données"

#. R/HoltWinters.R: stop("cannot fit models without level ('alpha' must not be 0 or FALSE)")
#: R/HoltWinters.R:0
msgid "cannot fit models without level ('alpha' must not be 0 or FALSE)"
msgstr "ajustement du modèle impossible sans un niveau ('alpha' ne doit pas être zéro ou FALSE)"

#. R/cor.R: stop("cannot handle 'pairwise.complete.obs'")
#: R/cor.R:0
msgid "cannot handle 'pairwise.complete.obs'"
msgstr "impossible de gérer 'pairwise.complete.obs'"

#. R/ts.R: stop("cannot plot more than 10 series as \"multiple\"")
#: R/ts.R:0
msgid "cannot plot more than 10 series as \"multiple\""
msgstr "impossible de tracer plus de 10 séries comme \"multiple\""

#. R/nls-profile.R: stop("cannot recognize parameter name")
#: R/nls-profile.R:0
msgid "cannot recognize parameter name"
msgstr "nom de paramètre inconnu"

#. R/prcomp.R: stop("cannot rescale a constant/zero column to unit variance")
#: R/prcomp.R:0
msgid "cannot rescale a constant/zero column to unit variance"
msgstr "impossible de standardiser une constante/une colonne nulle"

#. R/family.R: stop("cannot simulate from non-integer prior.weights")
#: R/family.R:0
msgid "cannot simulate from non-integer prior.weights"
msgstr "impossible de réaliser des simulations à l'aide de prior.weights non entiers"

#. R/princomp.R: stop("cannot use 'cor = TRUE' with a constant variable")
#: R/princomp.R:0
msgid "cannot use 'cor = TRUE' with a constant variable"
msgstr "impossible d'utiliser 'cor=TRUE' avec une variable constante"

#. R/t.test.R: stop("cannot use 'paired' in formula method")
#. R/wilcox.test.R: stop("cannot use 'paired' in formula method")
#: R/t.test.R:0 R/wilcox.test.R:0
#, fuzzy
msgid "cannot use 'paired' in formula method"
msgstr "impossible d'utiliser des points dans la formule avec les données indiquées"

#. R/ftable.R: stop("cannot use dots in formula with given data")
#: R/ftable.R:0
msgid "cannot use dots in formula with given data"
msgstr "impossible d'utiliser des points dans la formule avec les données indiquées"

#. R/smspline.R: stop("cannot use more inner knots than unique 'x' values")
#: R/smspline.R:0
msgid "cannot use more inner knots than unique 'x' values"
msgstr "impossible d'utiliser un nombre de noeuds internes supérieur au nombre de valeurs différentes de 'x'"

#. R/kernel.R: stop("coefficients do not add to 1")
#: R/kernel.R:0
msgid "coefficients do not add to 1"
msgstr "la somme des coefficients n'est pas égale à 1"

#. R/approx.R: warning("collapsing to unique 'x' values")
#: R/approx.R:0
msgid "collapsing to unique 'x' values"
msgstr "suppression des ex-aequos de 'x'"

#. R/dendrogram.R: stop("column dendrogram ordering gave index of wrong length")
#: R/dendrogram.R:0
msgid "column dendrogram ordering gave index of wrong length"
msgstr "longueur incorrecte pour l'indice d'ordre des colonnes dans le dendrogramme"

#. R/aov.R: stop("columns of 'contrast.obj' must define a contrast (sum to zero)")
#: R/aov.R:0
msgid "columns of 'contrast.obj' must define a contrast (sum to zero)"
msgstr "les colonnes de 'contrast.obj' doivent définir un contraste (somme nulle)"

#. R/aov.R: stop("columns of 'contrast.obj' must define a contrast(sum to zero)")
#: R/aov.R:0
msgid "columns of 'contrast.obj' must define a contrast(sum to zero)"
msgstr "les colonnes de 'contrast.obj' doivent définir un contraste (somme nulle)"

#. R/ks.test.R: warning("computation of exact probability failed, returning Monte Carlo approximation")
#: R/ks.test.R:0
msgid "computation of exact probability failed, returning Monte Carlo approximation"
msgstr ""

#. R/contrast.R: stop("contrasts apply only to factors")
#: R/contrast.R:0
msgid "contrasts apply only to factors"
msgstr "les contrastes s'appliquent uniquement aux facteurs"

#. R/contrast.R: stop("contrasts can be applied only to factors with 2 or more levels")
#: R/contrast.R:0
msgid "contrasts can be applied only to factors with 2 or more levels"
msgstr "les contrastes ne peuvent être appliqués qu'aux facteurs ayant au moins deux niveaux"

#. R/models.R: gettextf("contrasts dropped from factor %s", nm)
#: R/models.R:0
#, fuzzy
msgid "contrasts dropped from factor %s"
msgstr "les contrastes s'appliquent uniquement aux facteurs"

#. R/models.R: gettextf("contrasts dropped from factor %s due to missing levels",     nm)
#: R/models.R:0
#, fuzzy
msgid "contrasts dropped from factor %s due to missing levels"
msgstr "les contrastes ne peuvent être appliqués qu'aux facteurs ayant au moins deux niveaux"

#. R/contr.poly.R: gettextf("contrasts not defined for %d degrees of freedom", n -     1)
#. R/contrast.R: gettextf("contrasts not defined for %d degrees of freedom", n -     1L)
#: R/contr.poly.R:0 R/contrast.R:0
msgid "contrasts not defined for %d degrees of freedom"
msgstr "contrastes indéfinis pour %d degrés de liberté"

#. R/nlm.R: stop("convergence problem in zero finding: ", conditionMessage(val))
#: R/nlm.R:0
msgid "convergence problem in zero finding:"
msgstr "problème de convergence dans la recherche de zéro :"

#. R/arma0.R: warning("converting non-invertible initial MA values")
#: R/arma0.R:0
msgid "converting non-invertible initial MA values"
msgstr "conversion des valeurs MA initales non inversibles"

#. R/princomp.R: stop("covariance matrix is not non-negative definite")
#: R/princomp.R:0
msgid "covariance matrix is not non-negative definite"
msgstr "la matrice de covariance contient des valeurs négatives définies"

#. R/spectrum.R: stop("coverage probability out of range [0,1)")
#: R/spectrum.R:0
msgid "coverage probability out of range [0,1)"
msgstr "probabilité de l'intervalle en dehors des limites [0,1)"

#. R/smspline.R: warning("cross-validation with non-unique 'x' values seems doubtful")
#: R/smspline.R:0
msgid "cross-validation with non-unique 'x' values seems doubtful"
msgstr "la validation croisée avec des valeurs de 'x' non uniques paraît douteuse"

#. R/t.test.R: stop("data are essentially constant")
#: R/t.test.R:0
msgid "data are essentially constant"
msgstr "les données sont pratiquement constantes"

#. R/HoltWinters.R: stop("data must be non-zero for multiplicative Holt-Winters")
#: R/HoltWinters.R:0
msgid "data must be non-zero for multiplicative Holt-Winters"
msgstr "les données ne peuvent être négatives dans un modèle de Holt-Winters multiplicatif"

#. R/dendrogram.R: gettextf("dendrogram entries must be 1,2,..,%d (in any order), to be coercible to \"hclust\"",     n)
#: R/dendrogram.R:0
msgid "dendrogram entries must be 1,2,..,%d (in any order), to be coercible to \"hclust\""
msgstr "les entrées du dendrogramme doivent être 1,2,..,%d (dans n’importe quel ordre), pour être convertible en “hclust”"

#. R/dendrogram.R: stop("dendrogram node with non-positive #{branches}")
#: R/dendrogram.R:0
msgid "dendrogram node with non-positive #{branches}"
msgstr "un noeud du dendrogramme a un nombre de branches < 1"

#. R/dendrogram.R: stop("dendrogram non-leaf node with non-positive #{branches}")
#: R/dendrogram.R:0
msgid "dendrogram non-leaf node with non-positive #{branches}"
msgstr "un noeud du dendrogramme qui n'est pas une feuille a un nombre de branches < 1"

#. R/model.tables.R: stop("design is unbalanced so cannot proceed")
#: R/model.tables.R:0
msgid "design is unbalanced so cannot proceed"
msgstr "le plan n'est pas balancé et ne peut être utilisé"

#. R/smspline.R: stop("df.offset must be numeric and >= 0")
#: R/smspline.R:0
#, fuzzy
msgid "df.offset must be numeric and >= 0"
msgstr "'offset' doit être numérique"

#. R/cor.R: warning("diag(V) had non-positive or NA entries; the non-finite result may be dubious")
#: R/cor.R:0
#, fuzzy
msgid "diag(V) had non-positive or NA entries; the non-finite result may be dubious"
msgstr "diag(.) à 0 ou NA entrées ; les résultats non finis sont douteux"

#. R/nlm.R: if (doX) "did not succeed extending the interval endpoints for f(lower) * f(upper) <= 0" else "f() values at end points not of opposite sign"
#: R/nlm.R:0
msgid "did not succeed extending the interval endpoints for f(lower) * f(upper) <= 0"
msgstr "impossible d'étendre l'intervalle des points extrêmes pour f(lower) * f(upper) <= 0"

#. R/cancor.R: stop("dimension 0 in 'x' or 'y'")
#: R/cancor.R:0
msgid "dimension 0 in 'x' or 'y'"
msgstr "dimension 0 dans 'x' ou 'y'"

#. R/cmdscale.R: stop("distances must be result of 'dist' or a square matrix")
#: R/cmdscale.R:0
msgid "distances must be result of 'dist' or a square matrix"
msgstr "les distances doivent provenir de 'dist' ou d'une matrice carrée"

#. R/mantelhaen.test.R: stop("each dimension in table must be >= 2")
#: R/mantelhaen.test.R:0
msgid "each dimension in table must be >= 2"
msgstr "toutes les dimensions de la table doivent être >= 2"

#. R/aov.R: gettextf("each element of '%s' must be logical", substitute(contrasts.list))
#. R/aov.R: gettextf("each element of '%s' must be logical", substitute(contrasts.obj))
#: R/aov.R:0
msgid "each element of '%s' must be logical"
msgstr "tous les éléments de '%s' doivent être des logiques"

#. R/model.tables.R: stop("eff.aovlist: non-orthogonal contrasts would give an incorrect answer")
#: R/model.tables.R:0
msgid "eff.aovlist: non-orthogonal contrasts would give an incorrect answer"
msgstr "eff.aovlist : des contrastes non orthogonaux donneraient un résultat incorrect"

#. R/cmdscale.R: warning("eig=TRUE is disregarded when list.=FALSE")
#: R/cmdscale.R:0
msgid "eig=TRUE is disregarded when list.=FALSE"
msgstr "eig=TRUE n’est pas utilisé lorsque list.=FALSE"

#. R/cutree.R: stop("either 'k' or 'h' must be specified")
#: R/cutree.R:0
msgid "either 'k' or 'h' must be specified"
msgstr "'k' ou 'h' doivent être spécifiés"

#. R/cutree.R: gettextf("elements of 'k' must be between 1 and %d", n)
#: R/cutree.R:0
msgid "elements of 'k' must be between 1 and %d"
msgstr "les éléments de 'k' doivent être compris entre 1 et %d"

#. R/prop.test.R: stop("elements of 'n' must be positive")
#: R/prop.test.R:0
msgid "elements of 'n' must be positive"
msgstr "les éléments de 'n' doivent être positifs"

#. R/prop.test.R: stop("elements of 'p' must be in (0,1)")
#: R/prop.test.R:0
msgid "elements of 'p' must be in (0,1)"
msgstr "les éléments de 'p' doivent appartenir à (0,1)"

#. R/prop.test.R: stop("elements of 'x' must be nonnegative")
#: R/prop.test.R:0
msgid "elements of 'x' must be nonnegative"
msgstr "les éléments de 'x' doivent être positifs ou nuls"

#. R/prop.test.R: stop("elements of 'x' must not be greater than those of 'n'")
#: R/prop.test.R:0
msgid "elements of 'x' must not be greater than those of 'n'"
msgstr "les éléments de 'x' ne doivent pas être supérieurs à ceux de 'n'"

#. R/kmeans.R: stop("empty cluster: try a better set of initial centers", call. = FALSE)
#. R/kmeans.R: warning("empty cluster: try a better set of initial centers",     call. = FALSE)
#: R/kmeans.R:0
msgid "empty cluster: try a better set of initial centers"
msgstr "classe vide : essayez un jeu de centres meilleur"

#. R/ARMAtheory.R: stop("empty model supplied")
#: R/ARMAtheory.R:0
msgid "empty model supplied"
msgstr "modèle fourni vide"

#. R/lm.R: warning("essentially perfect fit: summary may be unreliable")
#: R/lm.R:0
msgid "essentially perfect fit: summary may be unreliable"
msgstr "ajustement pratiquement parfait : le résumé n’est peut-être pas fiable"

#. R/power.anova.test.R: stop("exactly one of 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' must be NULL")
#: R/power.anova.test.R:0
msgid "exactly one of 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' must be NULL"
msgstr "un et un seul parmi 'groups', 'n', 'between.var', 'within.var', 'power', and 'sig.level' doit être NULL"

#. R/power.R: stop("exactly one of 'n', 'delta', 'sd', 'power', and 'sig.level' must be NULL")
#: R/power.R:0
msgid "exactly one of 'n', 'delta', 'sd', 'power', and 'sig.level' must be NULL"
msgstr "un et un seul parmi 'n', 'delta', 'sd', 'power', et 'sig.level' doit être NULL"

#. R/power.R: stop("exactly one of 'n', 'p1', 'p2', 'power', and 'sig.level' must be NULL")
#: R/power.R:0
msgid "exactly one of 'n', 'p1', 'p2', 'power', and 'sig.level' must be NULL"
msgstr "un et un seul parmi 'n', 'p1', 'p2', 'power', et 'sig.level' doit être NULL"

#. R/ts.R: warning("extending time series when replacing values", call. = FALSE)
#: R/ts.R:0
msgid "extending time series when replacing values"
msgstr "rallongement de la série temporelle au cours du remplacement des valeurs"

#. R/logLik.R: warning("extra arguments discarded")
#: R/logLik.R:0
msgid "extra arguments discarded"
msgstr "arguments supplémentaires ignorés"

#. R/nlm.R: if (doX) "did not succeed extending the interval endpoints for f(lower) * f(upper) <= 0" else "f() values at end points not of opposite sign"
#: R/nlm.R:0
msgid "f() values at end points not of opposite sign"
msgstr "les valeurs de f() aux points extrêmes ne sont pas de signe opposé"

#. R/nlm.R: stop("f.lower = f(lower) is NA")
#: R/nlm.R:0
msgid "f.lower = f(lower) is NA"
msgstr "f.lower = f(lower) est NA"

#. R/nlm.R: stop("f.upper = f(upper) is NA")
#: R/nlm.R:0
msgid "f.upper = f(upper) is NA"
msgstr "f.upper = f(upper) est NA"

#. R/factanal.R: stop("factor analysis applies only to numerical variables")
#: R/factanal.R:0
msgid "factor analysis applies only to numerical variables"
msgstr "l'analyse factorielle ne s'applique qu'à des valeurs numériques"

#. R/factanal.R: stop("factor analysis requires at least three variables")
#: R/factanal.R:0
msgid "factor analysis requires at least three variables"
msgstr "l'analyse factorielle nécessite au moins trois variables"

#. R/reshape.R: stop("failed to guess time-varying variables from their names")
#: R/reshape.R:0
msgid "failed to guess time-varying variables from their names"
msgstr "impossible de déterminer les variables dépendant du temps depuis leurs noms"

#. R/lm.R: gettextf("family '%s' not implemented", fam)
#: R/lm.R:0
msgid "family '%s' not implemented"
msgstr "famille '%s' non implémentée"

#. R/loess.R: stop("first argument must be a \"loess\" object")
#: R/loess.R:0
msgid "first argument must be a \"loess\" object"
msgstr "le premier argument doit être un objet \"loess\""

#. R/glm.R: warning("fitting to calculate the null deviance did not converge -- increase 'maxit'?")
#: R/glm.R:0
msgid "fitting to calculate the null deviance did not converge -- increase 'maxit'?"
msgstr "le calcul de dédéviation nulle n'a pas convergé lors de l'ajustement -- augmentez 'maxit' ?"

#. R/family.R: gettextf("for the '%s' family, y must be a vector of 0 and 1's\nor a 2 column matrix where col 1 is no. successes and col 2 is no. failures",     FAMILY)
#: R/family.R:0
msgid ""
"for the '%s' family, y must be a vector of 0 and 1's\n"
"or a 2 column matrix where col 1 is no. successes and col 2 is no. failures"
msgstr ""
"pour la famille '%s', y doit être un vecteur de 0 ou de 1\n"
"ou une matrice à 2 colonnes où la col. 1 est le nombre de succès et la col. 2 le nombre d'échecs"

#. R/nlsFunc.R: gettextf("formula '%s' must be of the form '~expr'", deparse1(object))
#: R/nlsFunc.R:0
msgid "formula '%s' must be of the form '~expr'"
msgstr "la formule '%s' doit être de la forme '~expr'"

#. R/aggregate.R: stop("formula 'x' must have both left and right hand sides")
#: R/aggregate.R:0
#, fuzzy
msgid "formula 'x' must have both left and right hand sides"
msgstr "'formula' doit avoir un membre de gauche et un membre de droite"

#. R/friedman.test.R: stop("formula missing")
#: R/friedman.test.R:0
msgid "formula missing"
msgstr "formule manquante"

#. R/StructTS.R: stop("frequency must be a positive integer >= 2 for BSM")
#: R/StructTS.R:0
msgid "frequency must be a positive integer >= 2 for BSM"
msgstr "la fréquence doit être un entier >= 2 pour BSM"

#. R/glm.R: warning("glm.fit: algorithm did not converge", call. = FALSE)
#: R/glm.R:0
msgid "glm.fit: algorithm did not converge"
msgstr "glm.fit : l'algorithme n'a pas convergé"

#. R/glm.R: warning("glm.fit: algorithm stopped at boundary value", call. = FALSE)
#: R/glm.R:0
msgid "glm.fit: algorithm stopped at boundary value"
msgstr "glm.fit : l'algorithme s'est arrêté à la valeur limite"

#. R/glm.R: warning("glm.fit: fitted probabilities numerically 0 or 1 occurred",     call. = FALSE)
#: R/glm.R:0
msgid "glm.fit: fitted probabilities numerically 0 or 1 occurred"
msgstr "glm.fit: des probabilités ont été ajustées numériquement à 0 ou 1"

#. R/glm.R: warning("glm.fit: fitted rates numerically 0 occurred", call. = FALSE)
#: R/glm.R:0
msgid "glm.fit: fitted rates numerically 0 occurred"
msgstr "glm.fit: des taux ont été ajustés numériquement à 0"

#. R/ansari.test.R: stop("grouping factor must have exactly 2 levels")
#. R/ks.test.R: stop("grouping factor must have exactly 2 levels")
#. R/mood.test.R: stop("grouping factor must have exactly 2 levels")
#. R/t.test.R: stop("grouping factor must have exactly 2 levels")
#. R/var.test.R: stop("grouping factor must have exactly 2 levels")
#. R/wilcox.test.R: stop("grouping factor must have exactly 2 levels")
#: R/ansari.test.R:0 R/ks.test.R:0 R/mood.test.R:0 R/t.test.R:0 R/var.test.R:0
#: R/wilcox.test.R:0
msgid "grouping factor must have exactly 2 levels"
msgstr "le facteur de regroupement doit avoir exactement 2 niveaux"

#. R/plot.lm.R: gettextf("hat values (leverages) are all = %s\n and there are no factor predictors; no plot no. 5",     format(mean(r.hat)))
#: R/plot.lm.R:0
msgid ""
"hat values (leverages) are all = %s\n"
" and there are no factor predictors; no plot no. 5"
msgstr ""
"les valeurs estimées (\"leverages\") sont tous = %s\n"
" et il n'y a aucune variable dépendante facteur ; aucun graphe no. 5"

#. R/fisher.test.R: stop("if 'x' is not a matrix, 'y' must be given")
#. R/mcnemar.test.R: stop("if 'x' is not a matrix, 'y' must be given")
#: R/fisher.test.R:0 R/mcnemar.test.R:0
msgid "if 'x' is not a matrix, 'y' must be given"
msgstr "si 'x' n'est pas une matrice, 'y' doit être donné"

#. R/mantelhaen.test.R: stop("if 'x' is not an array, 'y' must be given")
#: R/mantelhaen.test.R:0
msgid "if 'x' is not an array, 'y' must be given"
msgstr "si 'x' n'est pas un tableau, 'y' doit être donné"

#. R/mantelhaen.test.R: stop("if 'x' is not an array, 'z' must be given")
#: R/mantelhaen.test.R:0
msgid "if 'x' is not an array, 'z' must be given"
msgstr "si 'x' n'est pas un tableau, 'z' doit être donné"

#. R/arima.R: stop("if not a list, 'seasonal' must be a non-negative numeric vector of length 3")
#. R/arma0.R: stop("if not a list, 'seasonal' must be a non-negative numeric vector of length 3")
#: R/arima.R:0 R/arma0.R:0
#, fuzzy
msgid "if not a list, 'seasonal' must be a non-negative numeric vector of length 3"
msgstr "'seasonal$order' doit être un vecteur numérique positif ou nul de longueur 3"

#. R/family.R: warning("ignoring prior weights")
#: R/family.R:0
msgid "ignoring prior weights"
msgstr "les pondération initiales sont ignorées"

#. R/lm.R: stop("incompatible dimensions")
#: R/lm.R:0
msgid "incompatible dimensions"
msgstr "dimensions incompatibles"

#. R/ts.R: stop("inconsistent specification of 'ar' order")
#: R/ts.R:0
msgid "inconsistent specification of 'ar' order"
msgstr "l'ordre de 'ar' spécifié est incohérent"

#. R/ts.R: stop("inconsistent specification of 'ma' order")
#: R/ts.R:0
msgid "inconsistent specification of 'ma' order"
msgstr "l'ordre de 'ma' spécifié est incohérent"

#. R/diffinv.R: stop("incorrect dimensions for 'xi'")
#: R/diffinv.R:0
msgid "incorrect dimensions for 'xi'"
msgstr "dimensions incorrectes pour 'xi'"

#. R/binom.test.R: stop("incorrect length of 'x'")
#: R/binom.test.R:0
msgid "incorrect length of 'x'"
msgstr "la longueur de 'x' est incorrecte"

#. R/ftable.R: stop("incorrect specification for 'col.vars'")
#: R/ftable.R:0
msgid "incorrect specification for 'col.vars'"
msgstr "'col.vars' incorrect"

#. R/friedman.test.R: stop("incorrect specification for 'formula'")
#. R/quade.test.R: stop("incorrect specification for 'formula'")
#: R/friedman.test.R:0 R/quade.test.R:0
msgid "incorrect specification for 'formula'"
msgstr "'formula' incorrecte"

#. R/ftable.R: stop("incorrect specification for 'row.vars'")
#: R/ftable.R:0
msgid "incorrect specification for 'row.vars'"
msgstr "'row.vars' incorrect"

#. R/ftable.R: stop("incorrect variable names in lhs of formula")
#: R/ftable.R:0
msgid "incorrect variable names in lhs of formula"
msgstr "noms de variables incorrectes dans le membre de gauche de la formule"

#. R/ftable.R: stop("incorrect variable names in rhs of formula")
#: R/ftable.R:0
msgid "incorrect variable names in rhs of formula"
msgstr "noms de variables incorrectes dans le membre de droite de la formule"

#. R/bandwidths.R: gettextf("increasing bw.SJ() search interval (%d) to [%.4g,%.4g]",     itry, lower, upper)
#: R/bandwidths.R:0
msgid "increasing bw.SJ() search interval (%d) to [%.4g,%.4g]"
msgstr "augmentation de l'intervalle de recherche (%d) bw.SJ() à [%.4g,%.4g]"

#. R/kmeans.R: stop("initial centers are not distinct")
#: R/kmeans.R:0
msgid "initial centers are not distinct"
msgstr "les centres initiaux ne sont pas distincts"

#. R/constrOptim.R: stop("initial value is not in the interior of the feasible region")
#: R/constrOptim.R:0
msgid "initial value is not in the interior of the feasible region"
msgstr "la valeur initiale ne se trouve pas à l'intérieur de la région admissible"

#. R/glm.R: stop("inner loop 1; cannot correct step size", call. = FALSE)
#: R/glm.R:0
msgid "inner loop 1; cannot correct step size"
msgstr "boucle interne 1 ; impossible de corriger le pas"

#. R/glm.R: stop("inner loop 2; cannot correct step size", call. = FALSE)
#: R/glm.R:0
msgid "inner loop 2; cannot correct step size"
msgstr "boucle interne 2 ; impossible de corriger le pas"

#. R/ftable.R: stop("interactions are not allowed")
#. R/xtabs.R: stop("interactions are not allowed")
#: R/ftable.R:0 R/xtabs.R:0
msgid "interactions are not allowed"
msgstr "les interactions ne sont pas autorisées"

#. R/nls.R: stop("invalid  'attr(rhs, \"gradient\")'")
#: R/nls.R:0
msgid "invalid  'attr(rhs, \"gradient\")'"
msgstr "'attr(rhs, \"gradient\")' incorrect"

#. R/arima.R: stop("invalid 'SSinit'")
#: R/arima.R:0
msgid "invalid 'SSinit'"
msgstr "'SSinit' incorrect"

#. R/symnum.R: stop("invalid 'abbr.colnames'")
#: R/symnum.R:0
msgid "invalid 'abbr.colnames'"
msgstr "'abbr.colnames' incorrect"

#. R/loess.R: stop("invalid 'control' argument")
#: R/loess.R:0
msgid "invalid 'control' argument"
msgstr "argument 'control' incorrect"

#. R/smspline.R: stop("invalid 'control.spar'")
#: R/smspline.R:0
msgid "invalid 'control.spar'"
msgstr "'control.spar' incorrect"

#. R/models.R: stop("invalid 'data' argument")
#: R/models.R:0
msgid "invalid 'data' argument"
msgstr "argument 'data' incorrect"

#. R/smooth.R: stop("invalid 'endrule' argument")
#: R/smooth.R:0
msgid "invalid 'endrule' argument"
msgstr "argument 'endrule' incorrect"

#. R/nlm.R: stop("invalid 'extendInt'; please report")
#: R/nlm.R:0
msgid "invalid 'extendInt'; please report"
msgstr "argument 'extendInt' incorrect; veuillez envoyer un rapport de bug"

#. R/smspline.R: stop("invalid 'keep.stuff'")
#: R/smspline.R:0
msgid "invalid 'keep.stuff'"
msgstr "'keep.stuff' incorrect"

#. R/lm.R: stop("invalid 'lm' object:  no 'terms' component")
#: R/lm.R:0
msgid "invalid 'lm' object:  no 'terms' component"
msgstr "objet 'lm' incorrect : pas de composantes 'terms'"

#. R/glm.R: stop("invalid 'method' argument")
#: R/glm.R:0
msgid "invalid 'method' argument"
msgstr "argument 'method' incorrect"

#. R/bandwidths.R: stop("invalid 'nb'")
#: R/bandwidths.R:0
msgid "invalid 'nb'"
msgstr "'nb' incorrect"

#. R/cutree.R: stop("invalid 'tree' ('merge' component)")
#: R/cutree.R:0
msgid "invalid 'tree' ('merge' component)"
msgstr "'tree' incorrect (composante 'merge')"

#. R/cor.R: stop("invalid 'use' argument")
#: R/cor.R:0
msgid "invalid 'use' argument"
msgstr "argument 'use' incorrect"

#. R/bandwidths.R: stop("invalid 'x'")
#. R/chisq.test.R: stop("invalid 'x'")
#. R/loess.R: stop("invalid 'x'")
#: R/bandwidths.R:0 R/chisq.test.R:0 R/loess.R:0
msgid "invalid 'x'"
msgstr "'x' incorrect"

#. R/loess.R: stop("invalid 'y'")
#: R/loess.R:0
msgid "invalid 'y'"
msgstr "'y' incorrect"

#. R/dendrogram.R: stop("invalid (length 0) node in dendrogram")
#: R/dendrogram.R:0
msgid "invalid (length 0) node in dendrogram"
msgstr "noeud incorrect (longueur 0) dans le dendrogramme"

#. R/loess.R: stop("invalid NCOL(X)")
#: R/loess.R:0
msgid "invalid NCOL(X)"
msgstr "incorrect NCOL(X)"

#. R/loess.R: stop("invalid NROW(X)")
#: R/loess.R:0
msgid "invalid NROW(X)"
msgstr "la valeur de NROW(X) est incorrecte"

#. R/r2dtable.R: stop("invalid argument 'c'")
#: R/r2dtable.R:0
msgid "invalid argument 'c'"
msgstr "argument 'c' incorrect"

#. R/loess.R: stop("invalid argument 'cell'")
#: R/loess.R:0
msgid "invalid argument 'cell'"
msgstr "argument 'cell' incorrect"

#. R/loess.R: stop("invalid argument 'degree'")
#: R/loess.R:0
msgid "invalid argument 'degree'"
msgstr "argument 'degree' incorrect"

#. R/family.R: stop("invalid argument 'lambda'")
#: R/family.R:0
msgid "invalid argument 'lambda'"
msgstr "argument 'lambda' incorrect"

#. R/r2dtable.R: stop("invalid argument 'n'")
#: R/r2dtable.R:0
msgid "invalid argument 'n'"
msgstr "argument 'n' incorrect"

#. R/nafns.R: stop("invalid argument 'omit'")
#: R/nafns.R:0
msgid "invalid argument 'omit'"
msgstr "argument 'omit' incorrect"

#. R/r2dtable.R: stop("invalid argument 'r'")
#: R/r2dtable.R:0
msgid "invalid argument 'r'"
msgstr "argument 'r' incorrect"

#. R/loess.R: stop("invalid argument 'span'")
#: R/loess.R:0
msgid "invalid argument 'span'"
msgstr "argument 'span' incorrect"

#. R/nls-profile.R: stop("invalid argument to 'getProfile'")
#: R/nls-profile.R:0
msgid "invalid argument to 'getProfile'"
msgstr "argument de 'getProfile' incorrect"

#. R/ks.test.R: stop("invalid arguments")
#: R/ks.test.R:0
#, fuzzy
msgid "invalid arguments"
msgstr "argument 'n' incorrect"

#. R/hclust.R: stop("invalid clustering method", paste("", method))
#: R/hclust.R:0
msgid "invalid clustering method"
msgstr "méthode de classification incorrecte"

#. R/hclust.R: stop("invalid dissimilarities")
#: R/hclust.R:0
msgid "invalid dissimilarities"
msgstr "dissimilarités incorrectes"

#. R/dist.R: stop("invalid distance method")
#: R/dist.R:0
msgid "invalid distance method"
msgstr "méthode de calcul de distance incorrecte"

#. R/glm.R: stop("invalid fitted means in empty model", call. = FALSE)
#: R/glm.R:0
msgid "invalid fitted means in empty model"
msgstr "moyennes ajustées incorrectes dans le modèle vide"

#. R/cor.test.R: stop("invalid formula")
#. R/models.R: stop("invalid formula")
#: R/cor.test.R:0 R/models.R:0
msgid "invalid formula"
msgstr "'formula' incorrecte"

#. R/models.R: gettextf("invalid formula %s", deparse2(x))
#: R/models.R:0
msgid "invalid formula %s"
msgstr "formule %s incorrecte"

#. R/models.R: gettextf("invalid formula %s: assignment is deprecated", deparse2(x))
#: R/models.R:0
msgid "invalid formula %s: assignment is deprecated"
msgstr "formule %s incorrecte : l’assignation est obsolète"

#. R/models.R: gettextf("invalid formula %s: extraneous call to `%s` is deprecated",     deparse2(x), as.character(c.))
#: R/models.R:0
msgid "invalid formula %s: extraneous call to `%s` is deprecated"
msgstr "formule %s incorrecte : un appel externe à `%s` est obsolète"

#. R/models.R: gettextf("invalid formula %s: not a call", deparse2(x))
#: R/models.R:0
msgid "invalid formula %s: not a call"
msgstr "formule %s incorrecte : ce n’est pas un appel"

#. R/deriv.R: stop("invalid formula in deriv")
#: R/deriv.R:0
msgid "invalid formula in deriv"
msgstr "formule incorrecte dans deriv"

#. R/models.R: gettextf("invalid formula: %s", deparse2(x))
#: R/models.R:0
msgid "invalid formula: %s"
msgstr "'formula' incorrecte : %s"

#. R/approx.R: stop("invalid interpolation method")
#. R/spline.R: stop("invalid interpolation method")
#: R/approx.R:0 R/spline.R:0
msgid "invalid interpolation method"
msgstr "méthode d'interpolation incorrecte"

#. R/hclust.R: stop("invalid length of members")
#: R/hclust.R:0
msgid "invalid length of members"
msgstr "longueur des membres incorrecte"

#. R/HoltWinters.R: stop("invalid length(x)")
#. R/approx.R: stop("invalid length(x)")
#. R/bandwidths.R: stop("invalid length(x)")
#. R/stl.R: stop("invalid length(x)")
#: R/HoltWinters.R:0 R/approx.R:0 R/bandwidths.R:0 R/stl.R:0
msgid "invalid length(x)"
msgstr "length(x) incorrecte"

#. R/glm.R: stop("invalid linear predictor values in empty model", call. = FALSE)
#: R/glm.R:0
msgid "invalid linear predictor values in empty model"
msgstr "valeurs du prédicteur linéaire incorrectes dans le modèle vide"

#. R/lm.influence.R: stop("invalid model QR matrix")
#: R/lm.influence.R:0
msgid "invalid model QR matrix"
msgstr "matrice QR du modèle incorrecte"

#. R/kmeans.R: stop("invalid ncol(x)")
#: R/kmeans.R:0
msgid "invalid ncol(x)"
msgstr "ncol(x) incorrect"

#. R/kmeans.R: stop("invalid nrow(x)")
#: R/kmeans.R:0
msgid "invalid nrow(x)"
msgstr "nrow(x) incorrect"

#. R/smspline.R: stop("invalid number of points")
#: R/smspline.R:0
msgid "invalid number of points"
msgstr "nombre de points incorrect"

#. R/integrate.R: stop("invalid parameter values")
#: R/integrate.R:0
msgid "invalid parameter values"
msgstr "valeurs des paramètres incorrectes"

#. R/models.R: stop("invalid response type")
#: R/models.R:0
msgid "invalid response type"
msgstr "type de réponse incorrecte"

#. R/cmdscale.R: gettextf("invalid value of %s", "'n'")
#. R/density.R: gettextf("invalid value of %s", "length(x)")
#. R/diffinv.R: gettextf("invalid value of %s", "length(x)")
#. R/filter.R: gettextf("invalid value of %s", "NROW(x)")
#. R/filter.R: gettextf("invalid value of %s", "length(filter)")
#. R/kmeans.R: gettextf("invalid value of %s", "'k'")
#. R/runmed.R: gettextf("invalid value of %s", "length(x)")
#. R/runmed.R: gettextf("invalid value of %s", "'k'")
#. R/spline.R: gettextf("invalid value of %s", "length(x)")
#. R/splinefun.R: gettextf("invalid value of %s", "length(x)")
#: R/cmdscale.R:0 R/density.R:0 R/diffinv.R:0 R/filter.R:0 R/kmeans.R:0
#: R/runmed.R:0 R/spline.R:0 R/splinefun.R:0
msgid "invalid value of %s"
msgstr "valeur de %s incorrecte"

#. R/loess.R: gettext("iterTrace = %d is not obeyed since iterations = %d")
#: R/loess.R:0
msgid "iterTrace = %d is not obeyed since iterations = %d"
msgstr "iterTrace = %d n’est pas respecté puisque le nombre d’iterations = %d"

#. R/identify.hclust.R: gettextf("k must be between 2 and %d", length(tree$height))
#: R/identify.hclust.R:0
msgid "k must be between 2 and %d"
msgstr "'k' doit être compris entre 2 et %d"

#. R/fft.R: stop("length mismatch in convolution")
#: R/fft.R:0
msgid "length mismatch in convolution"
msgstr "désaccord entre les longueurs dans la convolution"

#. R/cov.wt.R: stop("length of 'center' must equal the number of columns in 'x'")
#: R/cov.wt.R:0
msgid "length of 'center' must equal the number of columns in 'x'"
msgstr "la longueur de 'center' doit être égale au nombre de colonnes de 'x'"

#. R/filter.R: stop("length of 'init' must equal length of 'filter'")
#: R/filter.R:0
msgid "length of 'init' must equal length of 'filter'"
msgstr "la longueur de 'init' doit être égale à la longueur de 'filter'"

#. R/spectrum.R: stop("length of 'p' must be 1 or equal the number of columns of 'x'")
#: R/spectrum.R:0
msgid "length of 'p' must be 1 or equal the number of columns of 'x'"
msgstr "la longueur de 'p' doit être égale à 1 ou au nombre de colonnes de 'x'"

#. R/glm.R: gettextf("length of 'start' should equal %d and correspond to initial coefs for %s",     nvars, paste(deparse(xnames), collapse = ", "))
#: R/glm.R:0
msgid "length of 'start' should equal %d and correspond to initial coefs for %s"
msgstr "la longueur de 'start' devrait être égale à %d et correspondre aux coefs initiaux pour %s"

#. R/reshape.R: stop("length of 'v.names' does not evenly divide length of 'varying'")
#: R/reshape.R:0
msgid "length of 'v.names' does not evenly divide length of 'varying'"
msgstr "la longueur de 'v.names' ne divise pas de manière entière la longueur de 'varying'"

#. R/reshape.R: stop("length of 'varying' must be the product of length of 'v.names' and length of 'times'")
#: R/reshape.R:0
msgid "length of 'varying' must be the product of length of 'v.names' and length of 'times'"
msgstr "la longueur de 'varying' doit être le produit des longueurs de 'v.names' et de 'times'"

#. R/cov.wt.R: stop("length of 'wt' must equal the number of rows in 'x'")
#: R/cov.wt.R:0
msgid "length of 'wt' must equal the number of rows in 'x'"
msgstr "la longueur de 'wt' doit être égale au nombre de lignes de 'x'"

#. R/addmargins.R: gettextf("length of FUN, %d,\n does not match the length of the margins, %d",     length(FUN), n.sid)
#: R/addmargins.R:0
msgid ""
"length of FUN, %d,\n"
" does not match the length of the margins, %d"
msgstr ""
"la longueur de FUN, %d,\n"
" ne correspond pas à la longueur des marges, %d"

#. R/biplot.R: stop("length of choices must be 2")
#: R/biplot.R:0
msgid "length of choices must be 2"
msgstr "la longueur des choix doit être 2"

#. R/smspline.R: stop("lengths of 'x' and 'w' must match")
#: R/smspline.R:0
msgid "lengths of 'x' and 'w' must match"
msgstr "les longueurs de 'x' et de 'w' doivent correspondre"

#. R/arima.R: stop("lengths of 'x' and 'xreg' do not match")
#. R/arma0.R: stop("lengths of 'x' and 'xreg' do not match")
#: R/arima.R:0 R/arma0.R:0
msgid "lengths of 'x' and 'xreg' do not match"
msgstr "les longueurs de 'x' et de 'xreg' ne correspondent pas"

#. R/nls-profile.R: warning("levels truncated to positive values only")
#: R/nls-profile.R:0
msgid "levels truncated to positive values only"
msgstr "les niveaux ont été réduits aux valeurs positives"

#. R/family.R: gettextf("link \"%s\" not available for %s family; available links are %s",     linktemp, family, paste(sQuote(okLinks), collapse = ", "))
#: R/family.R:0
msgid "link \"%s\" not available for %s family; available links are %s"
msgstr "le lien \"%s\" n'est pas disponible pour la famille %s ; les liens possibles sont %s"

#. R/lm.R: stop("lm object does not have a proper 'qr' component.\n Rank zero or should not have used lm(.., qr=FALSE).")
#: R/lm.R:0
msgid ""
"lm object does not have a proper 'qr' component.\n"
" Rank zero or should not have used lm(.., qr=FALSE)."
msgstr ""
"l'object lm n'a pas de composante 'qr' adéquate.\\n\n"
" Rang nul ou appel lm(..., qr=FALSE) inapproprié."

#. R/nlminb.R: stop("logical 'hessian' argument not allowed.  See documentation.")
#: R/nlminb.R:0
msgid "logical 'hessian' argument not allowed.  See documentation."
msgstr "argument 'hessian' logique non autorisé. Voyez la documentation."

#. R/nlm.R: stop("lower < upper  is not fulfilled")
#: R/nlm.R:0
msgid "lower < upper  is not fulfilled"
msgstr "lower < upper n'est pas vérifié"

#. R/lm.R: message("lower-rank qr: determining non-estimable cases")
#: R/lm.R:0
msgid "lower-rank qr: determining non-estimable cases"
msgstr ""

#. R/glm.R: stop("maximum number of iterations must be > 0")
#: R/glm.R:0
msgid "maximum number of iterations must be > 0"
msgstr "le nombre maximum d'itérations doit être > 0"

#. R/optim.R: stop("method = \"Brent\" is only available for one-dimensional optimization")
#: R/optim.R:0
msgid "method = \"Brent\" is only available for one-dimensional optimization"
msgstr "method = \"Brent\" n'est disponible que pour une optimisation unidimensionnelle"

#. R/lm.R: gettextf("method = '%s' is not supported. Using 'qr'", method)
#: R/lm.R:0
msgid "method = '%s' is not supported. Using 'qr'"
msgstr "method = '%s' n'est pas supporté. Utilisation de 'qr'"

#. R/optim.R: warning("method L-BFGS-B uses 'factr' (and 'pgtol') instead of 'reltol' and 'abstol'")
#: R/optim.R:0
msgid "method L-BFGS-B uses 'factr' (and 'pgtol') instead of 'reltol' and 'abstol'"
msgstr "la méthode L-BFGS-B utilise 'factr' (et 'pgtol') au lieu de 'reltol' et 'abstol'"

#. R/dendrogram.R: warning("midcache() of non-binary dendrograms only partly implemented")
#: R/dendrogram.R:0
msgid "midcache() of non-binary dendrograms only partly implemented"
msgstr "midcache() pour des dendrogrammes non binaires n'est implémenté que partiellement"

#. R/bandwidths.R: warning("minimum occurred at one end of the range")
#: R/bandwidths.R:0
msgid "minimum occurred at one end of the range"
msgstr "le minimum se trouve à une des extrémités de l'intervalle"

#. R/ppr.R: stop("mismatched 'x' and 'weights'")
#: R/ppr.R:0
#, fuzzy
msgid "mismatched 'x' and 'weights'"
msgstr "'x' et 'y' ne correspondent pas"

#. R/ppr.R: stop("mismatched 'x' and 'y'")
#: R/ppr.R:0
msgid "mismatched 'x' and 'y'"
msgstr "'x' et 'y' ne correspondent pas"

#. R/lsfit.R: warning("missing observations deleted")
#: R/lsfit.R:0
msgid "missing observations deleted"
msgstr "observations manquantes supprimées"

#. R/smspline.R: stop("missing or infinite values in inputs are not allowed")
#: R/smspline.R:0
msgid "missing or infinite values in inputs are not allowed"
msgstr "les valeurs manquantes ou infinies ne sont pas autorisées dans les entrées"

#. R/lm.R: stop("missing or negative weights not allowed")
#. R/nls.R: stop("missing or negative weights not allowed")
#: R/lm.R:0 R/nls.R:0
msgid "missing or negative weights not allowed"
msgstr "les poids manquants ou négatifs ne sont pas autorisés"

#. R/quantile.R: stop("missing values and NaN's not allowed if 'na.rm' is FALSE")
#: R/quantile.R:0
msgid "missing values and NaN's not allowed if 'na.rm' is FALSE"
msgstr "les valeurs manquantes et les NaN ne sont pas autorisés si 'na.rm' est FALSE"

#. R/contr.poly.R: stop("missing values are not allowed in 'poly'")
#: R/contr.poly.R:0
msgid "missing values are not allowed in 'poly'"
msgstr "valeurs manquantes non autorisées dans 'poly'"

#. R/filter.R: stop("missing values in 'filter'")
#: R/filter.R:0
msgid "missing values in 'filter'"
msgstr "valeurs manquantes dans 'filter'"

#. R/nafns.R: stop("missing values in object")
#: R/nafns.R:0
msgid "missing values in object"
msgstr "valeurs manquantes dans l'objet"

#. R/isoreg.R: stop("missing values not allowed")
#: R/isoreg.R:0
msgid "missing values not allowed"
msgstr "valeurs manquantes non autorisées"

#. R/models.R: stop("model frame and formula mismatch in model.matrix()")
#: R/models.R:0
msgid "model frame and formula mismatch in model.matrix()"
msgstr "le tableau du modèle et la formule ne correspondent pas dans model.matrix()"

#. R/AIC.R: warning("models are not all fitted to the same number of observations")
#: R/AIC.R:0
msgid "models are not all fitted to the same number of observations"
msgstr "tous les modèles n'ont pas été ajustés sur le même nombre d'observations"

#. R/glm.R: stop("models were not all fitted to the same size of dataset")
#. R/lm.R: stop("models were not all fitted to the same size of dataset")
#. R/mlm.R: stop("models were not all fitted to the same size of dataset")
#: R/glm.R:0 R/lm.R:0 R/mlm.R:0
msgid "models were not all fitted to the same size of dataset"
msgstr "tous les modèles n'ont pas été ajustés à la même taille du jeu de données"

#. R/glm.R: gettextf("models with response %s removed because response differs from model 1",     sQuote(deparse(responses[!sameresp])))
#. R/lm.R: gettextf("models with response %s removed because response differs from model 1",     sQuote(deparse(responses[!sameresp])))
#. R/loess.R: gettextf("models with response %s removed because response differs from model 1",     sQuote(deparse(responses[!sameresp])))
#. R/mlm.R: gettextf("models with response %s removed because response differs from model 1",     sQuote(deparse(responses[!sameresp])))
#. R/nls.R: gettextf("models with response %s removed because response differs from model 1",     sQuote(deparse(responses[!sameresp])))
#: R/glm.R:0 R/lm.R:0 R/loess.R:0 R/mlm.R:0 R/nls.R:0
msgid "models with response %s removed because response differs from model 1"
msgstr "les modèles avec réponse %s sont enlevés car la réponse diffère du modèle 1"

#. R/kmeans.R: stop("more cluster centers than data points")
#: R/kmeans.R:0
msgid "more cluster centers than data points"
msgstr "le nombre de centres de classes est supérieur au nombre de points"

#. R/kmeans.R: stop("more cluster centers than distinct data points.")
#: R/kmeans.R:0
msgid "more cluster centers than distinct data points."
msgstr "le nombre de centres de classes est supérieur au nombre de points distincts."

#. R/dummy.coef.R: stop("multivariate case with missing coefficients is not yet implemented")
#: R/dummy.coef.R:0
msgid "multivariate case with missing coefficients is not yet implemented"
msgstr "le cas multivarié avec des coefficients manquant n’est pas implémenté"

#. R/symnum.R: stop("must have 2 'symbols' for logical 'x' argument")
#: R/symnum.R:0
msgid "must have 2 'symbols' for logical 'x' argument"
msgstr "il doit y avoir 2 'symbols' si 'x' est un argument logique"

#. R/zzModels.R: stop("must have at least 4 observations to fit an 'SSfol' model")
#: R/zzModels.R:0
msgid "must have at least 4 observations to fit an 'SSfol' model"
msgstr "il faut au moins 4 observations pour ajuster un modèle 'SSfol'"

#. R/zzModels.R: stop("must have length of response = length of second argument to 'SSfol'")
#: R/zzModels.R:0
msgid "must have length of response = length of second argument to 'SSfol'"
msgstr "la longueur de response doit être égale à celle du second argument de 'SSfol'"

#. R/hclust.R: stop("must have n >= 2 objects to cluster")
#: R/hclust.R:0
msgid "must have n >= 2 objects to cluster"
msgstr "il faut n >= 2 objets pour une classification"

#. R/kmeans.R: stop("must have same number of columns in 'x' and 'centers'")
#: R/kmeans.R:0
msgid "must have same number of columns in 'x' and 'centers'"
msgstr "'x' et 'centers' doivent avoir le même nombre de colonnes"

#. R/smspline.R: stop("must not specify both 'spar' and 'lambda'")
#: R/smspline.R:0
msgid "must not specify both 'spar' and 'lambda'"
msgstr "il faut spécifier à la fois 'spar' et 'lambda'"

#. R/spectrum.R: stop("must specify 'spans' or a valid kernel")
#: R/spectrum.R:0
msgid "must specify 'spans' or a valid kernel"
msgstr "il faut spécifier 'spans' ou un noyau correct"

#. R/xtabs.R: stop("must supply 'formula' or 'data'")
#: R/xtabs.R:0
#, fuzzy
msgid "must supply 'formula' or 'data'"
msgstr "il faut fournir soit 'formula', soit 'data'"

#. R/contr.poly.R: stop("must supply one or more vectors")
#: R/contr.poly.R:0
msgid "must supply one or more vectors"
msgstr "vous devez fournir un ou plusieurs vecteurs"

#. R/model.tables.R: stop("na.action must be a function")
#: R/model.tables.R:0
msgid "na.action must be a function"
msgstr "na.action doit être une fonction"

#. R/fisher.test.R: stop("names(hybridPars) should be NULL or be identical to the default's")
#: R/fisher.test.R:0
msgid "names(hybridPars) should be NULL or be identical to the default's"
msgstr "names(hybridPars) doit être NULL ou identiques aux valeurs par défaut"

#. R/fisher.test.R: stop("need 2 or more non-zero column marginals")
#: R/fisher.test.R:0
msgid "need 2 or more non-zero column marginals"
msgstr "il faut au moins deux colonnes marginales"

#. R/fisher.test.R: stop("need 2 or more non-zero row marginals")
#: R/fisher.test.R:0
msgid "need 2 or more non-zero row marginals"
msgstr "il faut au moins deux lignes marginales"

#. R/family.R: stop("need CRAN package 'SuppDists' for simulation from the 'inverse.gaussian' family")
#: R/family.R:0
msgid "need CRAN package 'SuppDists' for simulation from the 'inverse.gaussian' family"
msgstr "le package 'SuppDists' de CRAN est nécessaire pour des simulations avec la famille 'inverse.gaussian'"

#. R/update.R: stop("need an object with call component")
#: R/update.R:0
msgid "need an object with call component"
msgstr "il faut un objet avec une composante call"

#. R/bandwidths.R: stop("need at least 2 data points")
#: R/bandwidths.R:0
msgid "need at least 2 data points"
msgstr "il faut au moins 2 points"

#. R/HoltWinters.R: stop("need at least 2 periods to compute seasonal start values")
#: R/HoltWinters.R:0
msgid "need at least 2 periods to compute seasonal start values"
msgstr "il faut au moins 2 périodes pour calculer les valeurs de départ saisonnières"

#. R/density.R: stop("need at least 2 points to select a bandwidth automatically")
#: R/density.R:0
msgid "need at least 2 points to select a bandwidth automatically"
msgstr "il faut au moins 2 points pour choisir automatiquement la largeur de fenêtre"

#. R/smspline.R: stop("need at least four unique 'x' values")
#: R/smspline.R:0
msgid "need at least four unique 'x' values"
msgstr "il faut au moins quatre valeurs de 'x' différentes"

#. R/approx.R: stop("need at least two non-NA values to interpolate")
#: R/approx.R:0
msgid "need at least two non-NA values to interpolate"
msgstr "il faut au moins deux valeurs non manquantes pour interpoler"

#. R/hclust.R: stop("need dendrograms where all leaves have labels")
#: R/hclust.R:0
msgid "need dendrograms where all leaves have labels"
msgstr "il faut un dendrogramme où toutes les feuilles ont une étiquette"

#. R/manova.R: stop("need multiple responses")
#: R/manova.R:0
msgid "need multiple responses"
msgstr "réponses multiples nécessaires"

#. R/median.R: stop("need numeric data")
#: R/median.R:0
msgid "need numeric data"
msgstr "données numériques nécessaires"

#. R/smspline.R: stop("need result of smooth.spline(keep.data = TRUE)")
#: R/smspline.R:0
msgid "need result of smooth.spline(keep.data = TRUE)"
msgstr "un résultat de smooth.spline(keep.data = TRUE) est nécessaire"

#. R/family.R: stop("negative values not allowed for the 'Poisson' family")
#: R/family.R:0
msgid "negative values not allowed for the 'Poisson' family"
msgstr "les valeurs négatives sont interdites pour la famille 'Poisson'"

#. R/family.R: stop("negative values not allowed for the 'quasiPoisson' family")
#: R/family.R:0
msgid "negative values not allowed for the 'quasiPoisson' family"
msgstr "les valeurs négatives sont interdites pour la famille 'quasiPoisson'"

#. R/glm.R: stop("negative weights not allowed")
#. R/lsfit.R: stop("negative weights not allowed")
#: R/glm.R:0 R/lsfit.R:0
msgid "negative weights not allowed"
msgstr "poids négatifs non autorisés"

#. R/factanal.R: stop("neither 'x' nor 'covmat' supplied")
#: R/factanal.R:0
msgid "neither 'x' nor 'covmat' supplied"
msgstr "ni 'x' ni 'covmat' ne sont fournis"

#. R/logLik.R: stop("no \"nobs\" attribute is available")
#: R/logLik.R:0
msgid "no \"nobs\" attribute is available"
msgstr "aucun attribut \"nobs\" n'est disponible"

#. R/add.R: stop("no 'add1' method implemented for \"mlm\" models")
#: R/add.R:0
msgid "no 'add1' method implemented for \"mlm\" models"
msgstr "aucune méhode 'add1' implémentée pour les modèles \"mlm\""

#. R/stepfun.R: stop("no 'as.stepfun' method available for 'x'")
#: R/stepfun.R:0
msgid "no 'as.stepfun' method available for 'x'"
msgstr "pas de méthode 'as.stepfun' disponible pour 'x'"

#. R/add.R: stop("no 'drop1' method for \"mlm\" models")
#: R/add.R:0
msgid "no 'drop1' method for \"mlm\" models"
msgstr "aucune méhode 'drop1' pour les modèles \"mlm\""

#. R/selfStart.R: gettextf("no 'getInitial' method found for \"%s\" objects", data.class(object))
#: R/selfStart.R:0
msgid "no 'getInitial' method found for \"%s\" objects"
msgstr "impossible de trouver une méthode 'getInitial' pour les objets \"%s\""

#. R/logLik.R: warning("no 'nobs' method is available")
#. R/logLik.R: stop("no 'nobs' method is available")
#: R/logLik.R:0
msgid "no 'nobs' method is available"
msgstr "pas de méthode 'nobs' disponible"

#. R/reshape.R: stop("no 'reshapeWide' attribute, must specify 'varying'")
#: R/reshape.R:0
msgid "no 'reshapeWide' attribute, must specify 'varying'"
msgstr "aucun attribut 'reshapeWide', il faut spécifier 'varying'"

#. R/aov.R: stop("no degrees of freedom for residuals")
#: R/aov.R:0
msgid "no degrees of freedom for residuals"
msgstr "les résidus n'ont aucun degré de liberté"

#. R/TukeyHSD.R: stop("no factors in the fitted model")
#: R/TukeyHSD.R:0
msgid "no factors in the fitted model"
msgstr "pas de facteur dans le modèle ajusté"

#. R/smspline.R: stop("no finite observations")
#: R/smspline.R:0
msgid "no finite observations"
msgstr "aucune observation finie"

#. R/loess.R: stop("no models to compare")
#: R/loess.R:0
msgid "no models to compare"
msgstr "pas de modèle à comparer"

#. R/glm.R: gettextf("no observations informative at iteration %d", iter)
#: R/glm.R:0
msgid "no observations informative at iteration %d"
msgstr "aucune observation informative à l'itération %d"

#. R/nls.R: stop("no parameters to fit")
#: R/nls.R:0
msgid "no parameters to fit"
msgstr "aucun paramètre à ajuster"

#. R/ts.R: stop("no replacement values supplied")
#: R/ts.R:0
msgid "no replacement values supplied"
msgstr "pas de valeur de remplacement fournie"

#. R/aggregate.R: stop("no rows to aggregate")
#: R/aggregate.R:0
msgid "no rows to aggregate"
msgstr "pas de lignes à aggréger"

#. R/prcomp.R: stop("no scores are available: refit with 'retx=TRUE'")
#: R/prcomp.R:0
msgid "no scores are available: refit with 'retx=TRUE'"
msgstr "pas de score disponible : refaites l'ajustement avec 'retx=TRUE'"

#. R/nlm.R: gettextf("no sign change found in %d iterations", it - 1)
#: R/nlm.R:0
msgid "no sign change found in %d iterations"
msgstr "pas de changement de signe après %d itérations"

#. R/bandwidths.R: stop("no solution in the specified range of bandwidths")
#: R/bandwidths.R:0
msgid "no solution in the specified range of bandwidths"
msgstr "pas de solution dans l'intervalle de largeur de fenêtre"

#. R/nls.R: stop("no starting values specified")
#: R/nls.R:0
msgid "no starting values specified"
msgstr "pas de valeurs initiales fournies"

#. R/factanal.R: stop("no starting values supplied")
#: R/factanal.R:0
msgid "no starting values supplied"
msgstr "pas de valeurs initiales fournies"

#. R/models.R: stop("no terms component nor attribute")
#: R/models.R:0
msgid "no terms component nor attribute"
msgstr "pas de composante 'terms' ni d'attribut"

#. R/add.R: stop("no terms in scope")
#: R/add.R:0
msgid "no terms in scope"
msgstr "aucun terme dans la formule cible"

#. R/add.R: stop("no terms in scope for adding to object")
#: R/add.R:0
msgid "no terms in scope for adding to object"
msgstr "aucun terme dans la formule cible à rajouter à l'objet"

#. R/ts.R: stop("no time series supplied")
#: R/ts.R:0
msgid "no time series supplied"
msgstr "aucune série temporelle fournie"

#. R/glm.R: stop("no valid set of coefficients has been found: please supply starting values",     call. = FALSE)
#: R/glm.R:0
msgid "no valid set of coefficients has been found: please supply starting values"
msgstr "impossible de trouver un jeu de coefficients correct : prière de fournir des valeurs initiales"

#. R/lm.influence.R: stop("non-NA residual length does not match cases used in fitting")
#: R/lm.influence.R:0
msgid "non-NA residual length does not match cases used in fitting"
msgstr "le nombre de résidus non manquants ne correspond pas a l'effectif utilisé pour l'ajustement"

#. R/model.tables.R: gettextf("non-factors ignored: %s", paste(names(nn), collapse = ", "))
#: R/model.tables.R:0
msgid "non-factors ignored: %s"
msgstr "les données autres que des facteurs sont ignorées : %s"

#. R/density.R: stop("non-finite 'bw'")
#: R/density.R:0
msgid "non-finite 'bw'"
msgstr "'bw' indéfinie"

#. R/density.R: stop("non-finite 'from'")
#: R/density.R:0
msgid "non-finite 'from'"
msgstr "'from' indéfini"

#. R/density.R: stop("non-finite 'to'")
#: R/density.R:0
msgid "non-finite 'to'"
msgstr "'to' indéfini"

#. R/glm.R: gettextf("non-finite coefficients at iteration %d", iter)
#: R/glm.R:0
msgid "non-finite coefficients at iteration %d"
msgstr "coefficients indéfinis à l'itération %d"

#. R/family.R: gettextf("non-integer #successes in a %s glm!", FAMILY)
#: R/family.R:0
msgid "non-integer #successes in a %s glm!"
msgstr "nombre de succès non entier dans un glm %s !"

#. R/family.R: gettextf("non-integer counts in a %s glm!", FAMILY)
#: R/family.R:0
msgid "non-integer counts in a %s glm!"
msgstr "effectifs non entier dans un glm %s !"

#. R/ts.R: warning("non-intersecting series")
#: R/ts.R:0
msgid "non-intersecting series"
msgstr "séries non recouvrantes"

#. R/dendrogram.R: stop("non-leaf subtree of length 0")
#: R/dendrogram.R:0
msgid "non-leaf subtree of length 0"
msgstr "sous-arbre de longueur 0 qui n'est pas une feuille"

#. R/models.R: warning("non-list contrasts argument ignored")
#: R/models.R:0
msgid "non-list contrasts argument ignored"
msgstr "un argument de contrastes qui n’est pas une liste est ignoré"

#. R/family.R: stop("non-positive values not allowed for the 'Gamma' family")
#: R/family.R:0
msgid "non-positive values not allowed for the 'Gamma' family"
msgstr "les valeurs inférieurs ou égales à zéro ne sont pas autorisées pour la famille ‘Gamma'"

#. R/dist.R: warning("non-square matrix")
#: R/dist.R:0
msgid "non-square matrix"
msgstr "la matrice n'est pas carrée"

#. R/arima.R: stop("non-stationary AR part")
#. R/arma0.R: stop("non-stationary AR part")
#: R/arima.R:0 R/arma0.R:0
msgid "non-stationary AR part"
msgstr "partie AR non stationnaire"

#. R/arima.R: stop("non-stationary AR part from CSS")
#: R/arima.R:0
msgid "non-stationary AR part from CSS"
msgstr "partie AR non stationnaire dans CSS"

#. R/arima.R: stop("non-stationary seasonal AR part")
#. R/arma0.R: stop("non-stationary seasonal AR part")
#: R/arima.R:0 R/arma0.R:0
msgid "non-stationary seasonal AR part"
msgstr "partie AR saisonnière non stationnaire"

#. R/arima.R: stop("non-stationary seasonal AR part from CSS")
#: R/arima.R:0
msgid "non-stationary seasonal AR part from CSS"
msgstr "partie AR saisonnière non stationnaire dans CSS"

#. R/ts.R: stop("non-time series not of the correct length")
#: R/ts.R:0
msgid "non-time series not of the correct length"
msgstr "la série n'a pas une longueur correcte"

#. R/smspline.R: stop("not a valid \"smooth.spline\" object")
#: R/smspline.R:0
msgid "not a valid \"smooth.spline\" object"
msgstr "objet \"smooth.spline\" incorrect"

#. R/stepfun.R: stop("not a valid step function")
#: R/stepfun.R:0
msgid "not a valid step function"
msgstr "ce n'est pas une fonction step correcte"

#. R/ts.R: stop("not all series have the same frequency")
#: R/ts.R:0
msgid "not all series have the same frequency"
msgstr "toutes les séries n'ont pas la même fréquence"

#. R/ts.R: stop("not all series have the same phase")
#: R/ts.R:0
msgid "not all series have the same phase"
msgstr "toutes les séries n'ont pas la même phase"

#. R/friedman.test.R: stop("not an unreplicated complete block design")
#. R/quade.test.R: stop("not an unreplicated complete block design")
#: R/friedman.test.R:0 R/quade.test.R:0
msgid "not an unreplicated complete block design"
msgstr "ce n'est pas un plan en bloc complet sans répétitions"

#. R/ks.test.R: stop("not enough 'x' data")
#: R/ks.test.R:0
msgid "not enough 'x' data"
msgstr "pas assez de données 'x'"

#. R/ansari.test.R: stop("not enough 'x' observations")
#. R/t.test.R: stop("not enough 'x' observations")
#. R/var.test.R: stop("not enough 'x' observations")
#: R/ansari.test.R:0 R/t.test.R:0 R/var.test.R:0
msgid "not enough 'x' observations"
msgstr "nombre d'observations 'x' insuffisant"

#. R/ks.test.R: stop("not enough 'y' data")
#: R/ks.test.R:0
msgid "not enough 'y' data"
msgstr "pas assez de données 'y'"

#. R/ansari.test.R: stop("not enough 'y' observations")
#. R/t.test.R: stop("not enough 'y' observations")
#. R/var.test.R: stop("not enough 'y' observations")
#. R/wilcox.test.R: stop("not enough 'y' observations")
#: R/ansari.test.R:0 R/t.test.R:0 R/var.test.R:0 R/wilcox.test.R:0
msgid "not enough 'y' observations"
msgstr "nombre d'observations 'y' insuffisant"

#. R/wilcox.test.R: stop("not enough (non-missing) 'x' observations")
#: R/wilcox.test.R:0
msgid "not enough (non-missing) 'x' observations"
msgstr "pas assez d'observations 'x' (définies)"

#. R/poisson.test.R: stop("not enough data")
#. R/prop.test.R: stop("not enough data")
#: R/poisson.test.R:0 R/prop.test.R:0
msgid "not enough data"
msgstr "pas assez de données"

#. R/contrast.R: stop("not enough degrees of freedom to define contrasts")
#: R/contrast.R:0
msgid "not enough degrees of freedom to define contrasts"
msgstr "nombre de degrés de liberté insuffisant pour définir des contrastes"

#. R/cor.test.R: stop("not enough finite observations")
#: R/cor.test.R:0
msgid "not enough finite observations"
msgstr "pas assez d'observations non indéfinies"

#. R/oneway.test.R: stop("not enough groups")
#: R/oneway.test.R:0
msgid "not enough groups"
msgstr "pas assez de groupes"

#. R/fligner.test.R: stop("not enough observations")
#. R/kruskal.test.R: stop("not enough observations")
#. R/mood.test.R: stop("not enough observations")
#. R/oneway.test.R: stop("not enough observations")
#. R/t.test.R: stop("not enough observations")
#: R/fligner.test.R:0 R/kruskal.test.R:0 R/mood.test.R:0 R/oneway.test.R:0
#: R/t.test.R:0
msgid "not enough observations"
msgstr "pas assez d'observations"

#. R/plot.lm.R: gettextf("not plotting observations with leverage one:\n  %s",     paste(which(isInf), collapse = ", "))
#: R/plot.lm.R:0
msgid ""
"not plotting observations with leverage one:\n"
"  %s"
msgstr ""
"les observations ayant un 'leverage = 0' ne sont pas représentées sur le graphique : \n"
" %s"

#. R/smspline.R: warning("not using invalid df; must have 1 < df <= n := #{unique x} = ",     nx)
#: R/smspline.R:0
msgid "not using invalid df; must have 1 < df <= n := #{unique x} ="
msgstr "n’utilise pas un df correct ; il faut fournir 1 < df <= n := #{unique x} ="

#. R/ftable.R: stop("nothing to tabulate")
#: R/ftable.R:0
msgid "nothing to tabulate"
msgstr "rien à tabuler"

#. R/symnum.R: stop("number of 'cutpoints' must be one less than number of symbols")
#: R/symnum.R:0
msgid "number of 'cutpoints' must be one less than number of symbols"
msgstr "le nombre de 'cutpoints' doit être égal au nombre de symboles moins 1"

#. R/symnum.R: stop("number of 'cutpoints' must be one more than number of symbols")
#: R/symnum.R:0
msgid "number of 'cutpoints' must be one more than number of symbols"
msgstr "le nombre de 'cutpoints' doit être égal au nombre de symboles plus 1"

#. R/kmeans.R: stop("number of cluster centres must lie between 1 and nrow(x)",     call. = FALSE)
#: R/kmeans.R:0
msgid "number of cluster centres must lie between 1 and nrow(x)"
msgstr "le nombre de centres de classes doit être compris entre 1 et nrow(x)"

#. R/ts.R: stop("number of differences must be a positive integer")
#: R/ts.R:0
msgid "number of differences must be a positive integer"
msgstr "le nombre de différences doit être un entier positif"

#. R/power.anova.test.R: stop("number of groups must be at least 2")
#: R/power.anova.test.R:0
msgid "number of groups must be at least 2"
msgstr "le nombre de groupes doit être au moins 2"

#. R/smspline.R: stop("number of observations in 'x' and 'y' must match.")
#: R/smspline.R:0
msgid "number of observations in 'x' and 'y' must match."
msgstr "les nombres d'observations de 'x' et de 'y' doivent correspondre."

#. R/power.anova.test.R: stop("number of observations in each group must be at least 2")
#: R/power.anova.test.R:0
msgid "number of observations in each group must be at least 2"
msgstr "le nombre d'obervations dans chaque groupe doit être au moins 2"

#. R/glm.R: gettextf("number of offsets is %d should equal %d (number of observations)",     length(offset), NROW(Y))
#: R/glm.R:0
msgid "number of offsets is %d should equal %d (number of observations)"
msgstr "le nombre de décalages est %d et il devrait valoir %d (nombre d'observations)"

#. R/lm.R: gettextf("number of offsets is %d, should equal %d (number of observations)",     NROW(offset), ny)
#: R/lm.R:0
msgid "number of offsets is %d, should equal %d (number of observations)"
msgstr "le nombre de décalages est %d, il devrait valoir %d (nombre d'observations)"

#. R/add.R: stop("number of rows in use has changed: remove missing values?")
#: R/add.R:0
msgid "number of rows in use has changed: remove missing values?"
msgstr "le nombre de lignes utilisées a changé : supprimer les valeurs manquantes ?"

#. R/ar.R: stop("number of series in 'object' and 'newdata' do not match")
#: R/ar.R:0
msgid "number of series in 'object' and 'newdata' do not match"
msgstr "le nombre de séries dans 'object' et 'newdata' ne correspondent pas"

#. R/ts.R: stop("number of values supplied is not a sub-multiple of the number of values to be replaced")
#: R/ts.R:0
msgid "number of values supplied is not a sub-multiple of the number of values to be replaced"
msgstr "le nombre de valeurs fournies n'est pas un multiple du nombre de valeurs à remplacer"

#. R/lsfit.R: gettextf("number of weights = %d should equal %d (number of responses)",     nwts, nry)
#: R/lsfit.R:0
msgid "number of weights = %d should equal %d (number of responses)"
msgstr "nombre de poids = %d au lieu de %d (nombre de réponses)"

#. R/smspline.R: stop("number of weights must match number of observations.")
#: R/smspline.R:0
msgid "number of weights must match number of observations."
msgstr "le nombre de poids doit correspondre au nombre d'observations."

#. R/smspline.R: stop("numeric 'all.knots' must cover [0,1] (= the transformed data-range)")
#: R/smspline.R:0
msgid "numeric 'all.knots' must cover [0,1] (= the transformed data-range)"
msgstr "les nombres 'all.knots' doivent couvrir [0, 1] (= plage de données transformée)"

#. R/contrast.R: stop("numeric contrasts or contrast name expected")
#: R/contrast.R:0
msgid "numeric contrasts or contrast name expected"
msgstr "contrastes numérique ou nom de contraste attendu"

#. R/ksmooth.R: stop("numeric y must be supplied.\nFor density estimation use density()")
#: R/ksmooth.R:0
msgid ""
"numeric y must be supplied.\n"
"For density estimation use density()"
msgstr ""
"y doit être fourni.\n"
"Pour l'estimation de la densité, utilisez density()"

#. R/biplot.R: gettextf("object '%s' has no scores", deparse1(substitute(x)))
#: R/biplot.R:0
msgid "object '%s' has no scores"
msgstr "l'objet '%s' n'a pas de score"

#. R/manova.R: gettextf("object must be of class %s or %s", dQuote("manova"),     dQuote("maov"))
#: R/manova.R:0
msgid "object must be of class %s or %s"
msgstr "l'objet doit être de la classe %s ou %s"

#. R/C.R: stop("object not interpretable as a factor")
#: R/C.R:0
msgid "object not interpretable as a factor"
msgstr "objet non interprétable comme un facteur"

#. R/lsfit.R: warning("observations with 0 weight not used in calculating standard deviation")
#: R/lsfit.R:0
msgid "observations with 0 weight not used in calculating standard deviation"
msgstr "observations de poids nul non utilisées pour le calcul de l'écart-type"

#. R/lsfit.R: warning("observations with 0 weights not used")
#: R/lsfit.R:0
msgid "observations with 0 weights not used"
msgstr "observations de poids nul non utilisées"

#. R/glm.R: warning("observations with zero weight not used for calculating dispersion")
#: R/glm.R:0
msgid "observations with zero weight not used for calculating dispersion"
msgstr "les observations de poids nul n'ont pas été utilisées pour le calcul de la dispersion"

#. R/optim.R: warning("one-dimensional optimization by Nelder-Mead is unreliable:\nuse \"Brent\" or optimize() directly")
#: R/optim.R:0
msgid ""
"one-dimensional optimization by Nelder-Mead is unreliable:\n"
"use \"Brent\" or optimize() directly"
msgstr ""
"l'optimisation de Nelder-Mead unidimensionnelle est instable :\n"
"use \"Brent\" or optimize() directement"

#. R/cmdscale.R: gettextf("only %d of the first %d eigenvalues are > 0", k1, k)
#: R/cmdscale.R:0
msgid "only %d of the first %d eigenvalues are > 0"
msgstr "seulement %d des premières %d valeurs propres sont positives"

#. R/loess.R: stop("only 1-4 predictors are allowed")
#: R/loess.R:0
msgid "only 1-4 predictors are allowed"
msgstr "pas plus de 4 prédicteurs autorisés"

#. R/StructTS.R: stop("only implemented for univariate time series")
#. R/arima.R: stop("only implemented for univariate time series")
#. R/arma0.R: stop("only implemented for univariate time series")
#. R/cpgram.R: stop("only implemented for univariate time series")
#: R/StructTS.R:0 R/arima.R:0 R/arma0.R:0 R/cpgram.R:0
msgid "only implemented for univariate time series"
msgstr "implémenté seulement pour les séries temporelles univariées"

#. R/ts.R: stop("only replacement of elements is allowed")
#: R/ts.R:0
msgid "only replacement of elements is allowed"
msgstr "seul le remplacement d'éléments est autorisé"

#. R/stl.R: stop("only univariate series are allowed")
#: R/stl.R:0
msgid "only univariate series are allowed"
msgstr "seules les séries univariées sont autorisées"

#. R/HoltWinters.R: gettextf("optimization difficulties: %s", sol$message)
#: R/HoltWinters.R:0
msgid "optimization difficulties: %s"
msgstr "difficultés d'optimisation : %s"

#. R/HoltWinters.R: stop("optimization failure")
#: R/HoltWinters.R:0
msgid "optimization failure"
msgstr "échec d'optimisation"

#. R/anova.R: warning("option \"show.coef.Pvalues\" is invalid: assuming TRUE")
#: R/anova.R:0
msgid "option \"show.coef.Pvalues\" is invalid: assuming TRUE"
msgstr "l'option \"show.coef.Pvalues\" est incorrecte : TRUE est supposé"

#. R/anova.R: warning("option \"show.signif.stars\" is invalid: assuming TRUE")
#: R/anova.R:0
msgid "option \"show.signif.stars\" is invalid: assuming TRUE"
msgstr "l'option \"show.signif.stars\" est incorrecte : TRUE est supposée"

#. R/contr.poly.R: gettextf("orthogonal polynomials cannot be represented accurately enough for %d degrees of freedom",     n - 1)
#: R/contr.poly.R:0
msgid "orthogonal polynomials cannot be represented accurately enough for %d degrees of freedom"
msgstr "les polynômes orthogonaux ne peuvent pas être évalués avec une précision suffisante pour %d degrés de liberté"

#. R/ks.test.R: warning("p-value will be approximate in the presence of ties")
#: R/ks.test.R:0
msgid "p-value will be approximate in the presence of ties"
msgstr "les valeurs p seront approximées en présence d'ex-aequos"

#. R/nls.R: gettextf("parameters without starting value in 'data': %s", paste(nnn,     collapse = ", "))
#: R/nls.R:0
msgid "parameters without starting value in 'data': %s"
msgstr "des paramètres n'ont pas de valeurs initiales dans 'data' : %s"

#. R/smspline.R: stop("penalty must be numeric and > 0")
#: R/smspline.R:0
#, fuzzy
msgid "penalty must be numeric and > 0"
msgstr "'y' doit être numérique"

#. R/pairwise.R: stop("pooling of SD is incompatible with paired tests")
#: R/pairwise.R:0
msgid "pooling of SD is incompatible with paired tests"
msgstr "le regroupement des SD est incompatible avec les tests appariés"

#. R/family.R: stop("positive values only are allowed for the 'inverse.gaussian' family")
#: R/family.R:0
msgid "positive values only are allowed for the 'inverse.gaussian' family"
msgstr "seules les valeurs positives sont autorisées pour la famille 'inverse.gaussian'"

#. R/StructTS.R: gettextf("possible convergence problem: 'optim' gave code = %d and message %s",     res$convergence, sQuote(res$message))
#: R/StructTS.R:0
msgid "possible convergence problem: 'optim' gave code = %d and message %s"
msgstr "problème de convergence possible : 'optim' renvoie un code = %d et un message %s"

#. R/arima.R: gettextf("possible convergence problem: optim gave code = %d",     res$convergence)
#. R/arma0.R: gettextf("possible convergence problem: optim gave code = %d",     code)
#: R/arima.R:0 R/arma0.R:0
msgid "possible convergence problem: optim gave code = %d"
msgstr "problème de convergence possible : optim renvoie un code = %d"

#. R/lm.R: gettext("prediction from rank-deficient fit")
#: R/lm.R:0
#, fuzzy
msgid "prediction from rank-deficient fit"
msgstr "les prédictions venant d'un modèle de rang faible peuvent être trompeuses"

#. R/lm.R: warning("predictions on current data refer to _future_ responses\n")
#: R/lm.R:0
msgid "predictions on current data refer to _future_ responses"
msgstr "les prédictions sur les données actuelles se réfèrent à des réponses _futures_"

#. R/loess.R: stop("predictors must all be numeric")
#: R/loess.R:0
msgid "predictors must all be numeric"
msgstr "les prédicteurs doivent tous être numériques"

#. R/distn.R: stop("probabilities must be finite, non-negative and not all 0")
#: R/distn.R:0
msgid "probabilities must be finite, non-negative and not all 0"
msgstr "les probabilités doivent être non infinies, non négatives, et ne peuvent pas toutes être nulles"

#. R/chisq.test.R: stop("probabilities must be non-negative.")
#: R/chisq.test.R:0
msgid "probabilities must be non-negative."
msgstr "les probabilités doivent être positives ou nulles."

#. R/chisq.test.R: stop("probabilities must sum to 1.")
#: R/chisq.test.R:0
msgid "probabilities must sum to 1."
msgstr "la somme des probabilités doit être égale à 1."

#. R/glm-profile.R: stop("profiling has found a better solution, so original fit had not converged")
#: R/glm-profile.R:0
msgid "profiling has found a better solution, so original fit had not converged"
msgstr ""

#. R/optim.R: warning("read the documentation for 'trace' more carefully")
#: R/optim.R:0
msgid "read the documentation for 'trace' more carefully"
msgstr "lisez la documentation de 'trace' plus soigneusement"

#. R/relevel.R: gettextf("ref = %d must be in 1L:%d", ref, nlev)
#: R/relevel.R:0
msgid "ref = %d must be in 1L:%d"
msgstr "ref = %d doit appartenir à 1L:%d"

#. R/wilcox.test.R: warning("requested conf.level not achievable")
#: R/wilcox.test.R:0
msgid "requested conf.level not achievable"
msgstr "requête conf.level impossible à atteindre"

#. R/factanal.R: stop("requested scores without an 'x' matrix")
#: R/factanal.R:0
msgid "requested scores without an 'x' matrix"
msgstr "scores demandés sans matrice 'x'"

#. R/lm.R: warning("residual degrees of freedom in object suggest this is not an \"lm\" fit")
#: R/lm.R:0
msgid "residual degrees of freedom in object suggest this is not an \"lm\" fit"
msgstr "les degrés de liberté résiduels de l'objet suggère que ce n'est pas un ajustement \"lm\""

#. R/manova.R: gettextf("residuals have rank %d < %d", rss.qr$rank, ncol(resid))
#: R/manova.R:0
msgid "residuals have rank %d < %d"
msgstr "les résidus sont de rang %d < %d"

#. R/mlm.R: gettextf("residuals have rank %s < %s", rss.qr$rank, pp)
#: R/mlm.R:0
msgid "residuals have rank %s < %s"
msgstr "les résidus sont de rang %s < %s"

#. R/factanal.R: stop("response not allowed in formula")
#. R/prcomp.R: stop("response not allowed in formula")
#. R/princomp.R: stop("response not allowed in formula")
#: R/factanal.R:0 R/prcomp.R:0 R/princomp.R:0
msgid "response not allowed in formula"
msgstr "réponse non autorisée dans la formule"

#. R/selfStart.R: stop("right-hand side of formula is not a call")
#: R/selfStart.R:0
#, fuzzy
msgid "right-hand side of formula is not a call"
msgstr "formule %s incorrecte : ce n’est pas un appel"

#. R/dendrogram.R: stop("row dendrogram ordering gave index of wrong length")
#: R/dendrogram.R:0
msgid "row dendrogram ordering gave index of wrong length"
msgstr "longueur incorrecte pour l'indice d'ordre des lignes dans le dendrogramme"

#. R/mantelhaen.test.R: stop("sample size in each stratum must be > 1")
#: R/mantelhaen.test.R:0
msgid "sample size in each stratum must be > 1"
msgstr "la taille des échantillons dans chaque strate doit être > 1"

#. R/shapiro.test.R: stop("sample size must be between 3 and 5000")
#: R/shapiro.test.R:0
msgid "sample size must be between 3 and 5000"
msgstr "la taille de l'échantillon doit être comprise entre 3 et 5000"

#. R/ansari.test.R: warning("samples differ in location: cannot compute confidence set, returning NA")
#: R/ansari.test.R:0
msgid "samples differ in location: cannot compute confidence set, returning NA"
msgstr "la position des échantillons diffère : impossible de calculer l'intervalle de confiance, NA est renvoyé"

#. R/ts.R: stop("scatter plots only for univariate time series")
#: R/ts.R:0
msgid "scatter plots only for univariate time series"
msgstr "les nuages de points ne sont que pour les séries temporelles univariées"

#. R/add.R: stop("scope is not a subset of term labels")
#: R/add.R:0
msgid "scope is not a subset of term labels"
msgstr "la formule cible n'est pas un sous-ensemble des étiquettes de termes du modèle"

#. R/arima.R: warning("seasonal MA part of model is not invertible")
#. R/arma0.R: warning("seasonal MA part of model is not invertible")
#: R/arima.R:0 R/arma0.R:0
msgid "seasonal MA part of model is not invertible"
msgstr "la partie MA saisonnière du modèle est non inversible"

#. R/ts.R: warning("series is corrupt, with no 'tsp' attribute")
#. R/ts.R: stop("series is corrupt, with no 'tsp' attribute")
#: R/ts.R:0
msgid "series is corrupt, with no 'tsp' attribute"
msgstr "la série est incorrecte, pas d'attribut 'tsp'"

#. R/ts.R: gettextf("series is corrupt: length %d with 'tsp' implying %d",     NROW(x), nn)
#: R/ts.R:0
msgid "series is corrupt: length %d with 'tsp' implying %d"
msgstr "la série est incorrecte : longeur %d mais avec un 'tps' qui implique %d observations"

#. R/stl.R: stop("series is not periodic or has less than two periods")
#: R/stl.R:0
msgid "series is not periodic or has less than two periods"
msgstr "la série n'est pas périodique ou elle a moins de deux périodes"

#. R/nls.R: stop("setVarying : 'vary' length must match length of parameters")
#: R/nls.R:0
msgid "setVarying : 'vary' length must match length of parameters"
msgstr "setVarying : la longueur de 'vary' ne correspond pas à la longueur des paramètres"

#. R/models.R: gettextf("setting '%s' in terms.formula() is deprecated", "abb")
#. R/models.R: gettextf("setting '%s' in terms.formula() is deprecated", "neg.out")
#: R/models.R:0
msgid "setting '%s' in terms.formula() is deprecated"
msgstr ""

#. R/smspline.R: warning(wtxt, "\nsetting df = 1  __use with care!__")
#: R/smspline.R:0
msgid "setting df = 1  __use with care!__"
msgstr "df fixé à 1 __à utiliser avec prudence !__"

#. R/lm.R: stop("simulate() is not yet implemented for multivariate lm()")
#: R/lm.R:0
msgid "simulate() is not yet implemented for multivariate lm()"
msgstr "'simulate' n'est pas encore implémenté pour des modèles lm() multivariés"

#. R/contrast.R: stop("singular contrast matrix")
#: R/contrast.R:0
msgid "singular contrast matrix"
msgstr "matrice de contrastes singulière"

#. R/glm.R: stop("singular fit encountered")
#. R/lm.R: stop("singular fit encountered")
#: R/glm.R:0 R/lm.R:0
msgid "singular fit encountered"
msgstr "ajustement singulier rencontré"

#. R/nls.R: stop("singular gradient matrix at initial parameter estimates")
#: R/nls.R:0
msgid "singular gradient matrix at initial parameter estimates"
msgstr "matrice de gradient singulière pour les estimations initiales des paramètres"

#. R/ts-tests.R: stop("singularities in regression")
#: R/ts-tests.R:0
msgid "singularities in regression"
msgstr "singularités dans la régression"

#. R/distn.R: stop("size != sum(x), i.e. one is wrong")
#: R/distn.R:0
msgid "size != sum(x), i.e. one is wrong"
msgstr "size != sum(x), donc l'un des deux est faux"

#. R/hclust.R: stop("size cannot be NA nor exceed 65536")
#: R/hclust.R:0
msgid "size cannot be NA nor exceed 65536"
msgstr "la taille ne peut être NA et ne peut excéder 65536"

#. R/arima.R: warning("some AR parameters were fixed: setting transform.pars = FALSE")
#: R/arima.R:0
msgid "some AR parameters were fixed: setting transform.pars = FALSE"
msgstr "certains des paramètres AR etaient fixés : transform.pars = FALSE"

#. R/arma0.R: warning("some ARMA parameters were fixed: setting transform.pars = FALSE")
#: R/arma0.R:0
msgid "some ARMA parameters were fixed: setting transform.pars = FALSE"
msgstr "certains paramètre ARMA étaient fixés : transform.pars = FALSE"

#. R/reshape.R: gettextf("some constant variables (%s) are really varying", paste(names(rval)[!really.constant],     collapse = ","))
#: R/reshape.R:0
msgid "some constant variables (%s) are really varying"
msgstr "certaines variables constantes (%s) varient"

#. R/kruskal.test.R: warning("some elements of 'x' are not numeric and will be coerced to numeric")
#: R/kruskal.test.R:0
msgid "some elements of 'x' are not numeric and will be coerced to numeric"
msgstr "certains éléments de 'x' sont non numériques et seront convertis en nombres"

#. R/dummy.coef.R: warning("some terms will have NAs due to the limits of the method")
#: R/dummy.coef.R:0
msgid "some terms will have NAs due to the limits of the method"
msgstr "certains termes auront des NAs du fait des limites de la méthode"

#. R/smspline.R: stop("some weights should be positive")
#: R/smspline.R:0
msgid "some weights should be positive"
msgstr "certains poids doivent être positifs"

#. R/loess.R: stop("specified parametric for all predictors")
#: R/loess.R:0
msgid "specified parametric for all predictors"
msgstr "tous les prédicteurs spécifiés sont paramétriques"

#. R/loess.R: stop("specified the square of a factor predictor to be dropped when degree = 1")
#: R/loess.R:0
msgid "specified the square of a factor predictor to be dropped when degree = 1"
msgstr "le carré d'un facteur prédicteur à ignorer a été spécifié, alors que le degré = 1"

#. R/loess.R: stop("specified the square of a predictor to be dropped with only one numeric predictor")
#: R/loess.R:0
msgid "specified the square of a predictor to be dropped with only one numeric predictor"
msgstr "le carré d'un prédicteur à ignorer a été spécifié, alors qu'il n'y a qu'un prédicteur"

#. R/distn.R: warning("specify 'rate' or 'scale' but not both")
#. R/distn.R: stop("specify 'rate' or 'scale' but not both")
#: R/distn.R:0
msgid "specify 'rate' or 'scale' but not both"
msgstr "spécifiez 'rate' ou 'scale', mais pas les deux en même temps"

#. R/identify.hclust.R: stop("specify exactly one of 'k' and 'h'")
#: R/identify.hclust.R:0
msgid "specify exactly one of 'k' and 'h'"
msgstr "spécifiez seulement 'k' ou 'h'"

#. R/identify.hclust.R: stop("specify exactly one of 'which' and 'x'")
#: R/identify.hclust.R:0
msgid "specify exactly one of 'which' and 'x'"
msgstr "spécifiez seulement 'which' ou 'x'"

#. R/splinefun.R: warning("spline: first and last y values differ - using y[1L] for both")
#: R/splinefun.R:0
msgid "spline: first and last y values differ - using y[1L] for both"
msgstr "spline : la première et la dernière valeurs de y diffèrent - y[1L] utilisé pour les deux"

#. R/spline.R: warning("spline: first and last y values differ - using y[1] for both")
#: R/spline.R:0
msgid "spline: first and last y values differ - using y[1] for both"
msgstr "spline : la première et la dernière valeurs de y diffèrent - y[1] utilisé pour les deux"

#. R/glm.R: warning("step size truncated due to divergence", call. = FALSE)
#: R/glm.R:0
msgid "step size truncated due to divergence"
msgstr "le pas a été tronqué à cause de la divergence"

#. R/glm.R: warning("step size truncated: out of bounds", call. = FALSE)
#: R/glm.R:0
msgid "step size truncated: out of bounds"
msgstr "le pas a été tronqué : hors limites"

#. R/stepfun.R: stop("stepfun: 'x' must be ordered increasingly")
#: R/stepfun.R:0
msgid "stepfun: 'x' must be ordered increasingly"
msgstr "stepfun : 'x' doit être rangé par ordre croissant"

#. R/density.R: warning("sum(weights) != 1  -- will not get true density")
#: R/density.R:0
msgid "sum(weights) != 1  -- will not get true density"
msgstr "sum(weights) != 1  -- vous n'obtiendrez pas réellement une densité de probabilité"

#. R/cor.R: stop("supply both 'x' and 'y' or a matrix-like 'x'")
#: R/cor.R:0
msgid "supply both 'x' and 'y' or a matrix-like 'x'"
msgstr "fournir 'x' et 'y' ou bien 'x' en matrice"

#. R/prop.test.R: stop("table 'x' should have 2 entries")
#: R/prop.test.R:0
msgid "table 'x' should have 2 entries"
msgstr "la tableau 'x' doit compter deux entrées"

#. R/cutree.R: stop("the 'height' component of 'tree' is not sorted (increasingly)")
#: R/cutree.R:0
msgid "the 'height' component of 'tree' is not sorted (increasingly)"
msgstr "la composante 'height' de 'tree' n'est pas triée (par ordre croissant)"

#. R/lm.R: stop("the 'se.fit' argument is not yet implemented for \"mlm\" objects")
#: R/lm.R:0
msgid "the 'se.fit' argument is not yet implemented for \"mlm\" objects"
msgstr "l'argument 'se.fit' n'est pas encore implémenté pour les objets \"mlm\""

#. R/aov.R: stop("the 'split' argument must be a list")
#: R/aov.R:0
msgid "the 'split' argument must be a list"
msgstr "l'argument 'split' doit être une liste"

#. R/poisson.test.R: stop("the case k > 2 is unimplemented")
#: R/poisson.test.R:0
msgid "the case k > 2 is unimplemented"
msgstr "le cas k > 2 n'est pas implémenté"

#. R/aov.R: stop("the contrast defined is empty (has no TRUE elements)")
#: R/aov.R:0
msgid "the contrast defined is empty (has no TRUE elements)"
msgstr "le contraste défini est vide (il n'a aucun élément TRUE)"

#. R/StructTS.R: stop("the first value of the time series must not be missing")
#: R/StructTS.R:0
msgid "the first value of the time series must not be missing"
msgstr "la première valeur de la série temporelle ne peut pas être manquante"

#. R/glm.R: gettext("the following arguments to 'anova.glm' are invalid and dropped: ",     domain = "R-stats")
#: R/glm.R:0
msgid "the following arguments to 'anova.glm' are invalid and dropped:"
msgstr "les arguments de 'anova.glm' suivants sont incorrects et ignorés :"

#. R/StructTS.R: stop("the series is entirely NA")
#: R/StructTS.R:0
msgid "the series is entirely NA"
msgstr "la série ne contient que des NAs"

#. R/reshape.R: warning("there are records with missing times, which will be dropped.")
#: R/reshape.R:0
msgid "there are records with missing times, which will be dropped."
msgstr "il y a des enregistrements avec des dates manquantes, qui seront ignorés."

#. R/bartlett.test.R: stop("there must be at least 2 observations in each group")
#: R/bartlett.test.R:0
msgid "there must be at least 2 observations in each group"
msgstr "il doit y avoir au moins 2 observations dans chaque groupe"

#. R/model.tables.R: stop("this fit does not inherit from \"lm\"")
#: R/model.tables.R:0
msgid "this fit does not inherit from \"lm\""
msgstr "cet ajustement n'hérite pas de la classe \"lm\""

#. R/ks.test.R: warning("ties should not be present for the one-sample Kolmogorov-Smirnov test")
#: R/ks.test.R:0
#, fuzzy
msgid "ties should not be present for the one-sample Kolmogorov-Smirnov test"
msgstr "aucun ex-aequo ne devrait être présent pour le test de Kolmogorov-Smirnov"

#. R/ts.R: stop("time series contains internal NAs")
#: R/ts.R:0
msgid "time series contains internal NAs"
msgstr "la série temporelle contient des NA internes"

#. R/HoltWinters.R: stop("time series has no or less than 2 periods")
#: R/HoltWinters.R:0
msgid "time series has no or less than 2 periods"
msgstr "la série temporelle a moins de 2 périodes"

#. R/ts.R: stop("times to be replaced do not match")
#: R/ts.R:0
msgid "times to be replaced do not match"
msgstr "les dates à remplacer ne correspondent pas"

#. R/lm.influence.R: stop("too few cases i with h_ii > 0), n < k")
#: R/lm.influence.R:0
msgid "too few cases i with h_ii > 0), n < k"
msgstr "trop peu de cas i avec h_ij > 0), n < k"

#. R/zzModels.R: stop("too few distinct input values to fit a Michaelis-Menten model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit a Michaelis-Menten model"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster le modèle de Michaelis-Menten"

#. R/zzModels.R: stop("too few distinct input values to fit a biexponential")
#: R/zzModels.R:0
msgid "too few distinct input values to fit a biexponential"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster le modèle biexponentiel"

#. R/zzModels.R: stop("too few distinct input values to fit a four-parameter logistic")
#: R/zzModels.R:0
msgid "too few distinct input values to fit a four-parameter logistic"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster un modèle logistique à quatre paramètres"

#. R/zzModels.R: stop("too few distinct input values to fit a logistic model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit a logistic model"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster un modèle logistique"

#. R/zzModels.R: stop("too few distinct input values to fit an asymptotic regression model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit an asymptotic regression model"
msgstr "le nombre de valeurs distinctes en entrée est trop faible pour ajuster un modèle de régression asymptotique"

#. R/zzModels.R: stop("too few distinct input values to fit the 'asympOff' model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit the 'asympOff' model"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster le modèle 'asympOff'"

#. R/zzModels.R: stop("too few distinct input values to fit the 'asympOrig' model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit the 'asympOrig' model"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster le modèle 'asympOrig'"

#. R/zzModels.R: stop("too few distinct input values to fit the Gompertz model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit the Gompertz model"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster le modèle de Gompertz"

#. R/zzModels.R: stop("too few distinct input values to fit the Weibull growth model")
#: R/zzModels.R:0
msgid "too few distinct input values to fit the Weibull growth model"
msgstr "trop peu de valeurs distinctes en entrée pour ajuster le modèle de croissance de Weibull"

#. R/pairwise.R: stop("too few groups")
#: R/pairwise.R:0
msgid "too few groups"
msgstr "trop peu de groupes"

#. R/arima.R: stop("too few non-missing observations")
#: R/arima.R:0
msgid "too few non-missing observations"
msgstr "trop peu d'observations non manquantes"

#. R/zzModels.R: stop("too few observations to fit an asymptotic regression model")
#: R/zzModels.R:0
msgid "too few observations to fit an asymptotic regression model"
msgstr "trop peu d'observations pour ajuster un modèle de régression asymptotique"

#. R/ts.R: stop("too many replacement values supplied")
#: R/ts.R:0
msgid "too many replacement values supplied"
msgstr "trop de valeurs de remplacement fournies"

#. R/arma0.R: warning("transformed ARMA parameters were fixed")
#: R/arma0.R:0
msgid "transformed ARMA parameters were fixed"
msgstr "les paramètres ARMA tranformés étaient fixés"

#. R/model.tables.R: gettextf("type '%s' is not implemented yet", type)
#: R/model.tables.R:0
msgid "type '%s' is not implemented yet"
msgstr "le type '%s' n'est pas encore implémenté"

#. R/smspline.R: stop("type = \"partial\" is not yet implemented")
#: R/smspline.R:0
msgid "type = \"partial\" is not yet implemented"
msgstr "type = \"partial\" n'est pas encore implémenté"

#. R/cancor.R: stop("unequal number of rows in 'cancor'")
#: R/cancor.R:0
msgid "unequal number of rows in 'cancor'"
msgstr "nombre de lignes inégaux dans 'cancor'"

#. R/acf.R: stop("univariate time series only")
#: R/acf.R:0
msgid "univariate time series only"
msgstr "séries temporelles univariées seulement"

#. R/density.R: stop("unknown bandwidth rule")
#: R/density.R:0
msgid "unknown bandwidth rule"
msgstr "règle de choix de la largeur de fenêtre inconnue"

#. R/kernel.R: stop("unknown named kernel")
#: R/kernel.R:0
msgid "unknown named kernel"
msgstr "nom de noyau inconnu"

#. R/optim.R: gettext("unknown names in control: ", domain = "R-stats")
#: R/optim.R:0
msgid "unknown names in control:"
msgstr "noms inconnus dans le contrôle :"

#. R/stl.R: stop("unknown string value for s.window")
#: R/stl.R:0
msgid "unknown string value for s.window"
msgstr "chaîne inconnue pour s.window"

#. R/nls.R: warning("upper and lower bounds ignored unless algorithm = \"port\"")
#: R/nls.R:0
msgid "upper and lower bounds ignored unless algorithm = \"port\""
msgstr "limites hautes et basses ignorées, à moins d'utiliser l'algorithme \"port\""

#. R/plot.lm.R: stop("use only with \"lm\" objects")
#: R/plot.lm.R:0
msgid "use only with \"lm\" objects"
msgstr "à utiliser seulement pour des objets \"lm\""

#. R/glm.R: gettextf("using F test with a '%s' family is inappropriate",     fname)
#. R/glm.R: gettextf("using F test with a '%s' family is inappropriate",     fam)
#: R/glm.R:0
msgid "using F test with a '%s' family is inappropriate"
msgstr "l'utilisation d'un test F avec une famille '%s' n'est pas appropriée"

#. R/glm.R: warning("using F test with a fixed dispersion is inappropriate")
#: R/glm.R:0
msgid "using F test with a fixed dispersion is inappropriate"
msgstr "l'utilisation d'un test F avec un facteur de dispersion fixe n'est pas appropriée"

#. R/models.R: warning("using type = \"numeric\" with a factor response will be ignored")
#: R/models.R:0
msgid "using type = \"numeric\" with a factor response will be ignored"
msgstr "l'utilisation de type=\"numeric\" avec une réponse de type facteur sera ignorée"

#. R/family.R: message("using weights as inverse variances")
#: R/family.R:0
msgid "using weights as inverse variances"
msgstr "utilisation des pondérations comme variances inverses"

#. R/family.R: message("using weights as shape parameters")
#: R/family.R:0
msgid "using weights as shape parameters"
msgstr "utilisation des pondérations comme paramètres de forme"

#. R/glm.R: stop("value of 'epsilon' must be > 0")
#: R/glm.R:0
msgid "value of 'epsilon' must be > 0"
msgstr "la valeur de 'epsilon' doit être > 0"

#. R/models.R: gettextf("variable '%s' is absent, its contrast will be ignored",     nn)
#: R/models.R:0
msgid "variable '%s' is absent, its contrast will be ignored"
msgstr "la variable %s est absente, son contraste sera ignoré"

#. R/models.R: gettextf("variable '%s' is not a factor", nm)
#: R/models.R:0
msgid "variable '%s' is not a factor"
msgstr "la variable '%s' n'est pas un facteur"

#. R/models.R: gettextf("variable '%s' was fitted with type \"%s\" but type \"%s\" was supplied",     names(old)[wrong], old[wrong], new[wrong])
#: R/models.R:0
msgid "variable '%s' was fitted with type \"%s\" but type \"%s\" was supplied"
msgstr "la variable '%s' a été ajustée avec le type \"%s\" mais le type \"%s\" a été fourni"

#. R/models.R: gettextf("variables %s were specified with different types from the fit",     paste(sQuote(names(old)[wrong]), collapse = ", "))
#: R/models.R:0
msgid "variables %s were specified with different types from the fit"
msgstr "les variables %s ont été spécifiées avec des types différents de ceux de l'ajustement"

#. R/aov.R: stop("weights are not supported in a multistratum aov() fit")
#: R/aov.R:0
msgid "weights are not supported in a multistratum aov() fit"
msgstr "les pondérations ne sont pas supportées dans des ajustements aov() à plusieurs strates"

#. R/cov.wt.R: stop("weights must be non-negative and not all zero")
#: R/cov.wt.R:0
msgid "weights must be non-negative and not all zero"
msgstr "les poids doivent être positifs ou nuls et de somme non nulle"

#. R/embed.R: stop("wrong embedding dimension")
#: R/embed.R:0
msgid "wrong embedding dimension"
msgstr "dimension d'inclusion incorrecte"

#. R/anova.R: stop("wrong k / cs.ind")
#: R/anova.R:0
msgid "wrong k / cs.ind"
msgstr "k / cs.ind incorrect"

#. R/arima.R: stop("wrong length for 'fixed'")
#. R/arma0.R: stop("wrong length for 'fixed'")
#: R/arima.R:0 R/arma0.R:0
msgid "wrong length for 'fixed'"
msgstr "longueur de 'fixed' incorrecte"

#. R/ftable.R: stop("wrong method")
#: R/ftable.R:0
msgid "wrong method"
msgstr "méthode incorrecte"

#. R/ppr.R: stop("wrong number of columns in 'x'")
#: R/ppr.R:0
msgid "wrong number of columns in 'x'"
msgstr "le nombre de colonnes de 'x' est incorrect"

#. R/contr.poly.R: stop("wrong number of columns in new data: ", deparse1(substitute(...)))
#: R/contr.poly.R:0
msgid "wrong number of columns in new data:"
msgstr "le nombre de colonnes des nouvelles données est incorrect :"

#. R/contrast.R: stop("wrong number of contrast matrix rows")
#: R/contrast.R:0
msgid "wrong number of contrast matrix rows"
msgstr "nombre de lignes de la matrice de contrastes incorrect"

#. R/ts-tests.R: stop("x is not a vector or univariate time series")
#: R/ts-tests.R:0
msgid "x is not a vector or univariate time series"
msgstr "x n'est pas un vecteur ni une série temporelle univariée"

#. R/acf.R: stop("x$lag must have at least 1 column")
#: R/acf.R:0
msgid "x$lag must have at least 1 column"
msgstr "x$lag doit avoir au moins une colonne"

#. R/cmdscale.R: warning("x.ret=TRUE is disregarded when list.=FALSE")
#: R/cmdscale.R:0
msgid "x.ret=TRUE is disregarded when list.=FALSE"
msgstr "x.ret=TRUE n’est pas pris en compte lorsque list.=FALSE"

#. R/diffinv.R: warning("x[1] != r[1]; using x[1] for diagonal")
#: R/diffinv.R:0
msgid "x[1] != r[1]; using x[1] for diagonal"
msgstr ""

#. R/distn.R: stop("x[] and prob[] must be equal length vectors.")
#: R/distn.R:0
msgid "x[] and prob[] must be equal length vectors."
msgstr "x[] et prob[] doivent être des vecteur de même longueur."

#. R/plot.lm.R: stop("y is empty or has only NAs")
#. R/qqnorm.R: stop("y is empty or has only NAs")
#: R/plot.lm.R:0 R/qqnorm.R:0
msgid "y is empty or has only NAs"
msgstr "y est vide ou ne contient que des NA"

#. R/family.R: stop("y values must be 0 <= y <= 1")
#: R/family.R:0
msgid "y values must be 0 <= y <= 1"
msgstr "les valeurs de y doivent être 0 <= y <= 1"

#. R/approx.R: stop("zero non-NA points")
#. R/spline.R: stop("zero non-NA points")
#. R/splinefun.R: stop("zero non-NA points")
#: R/approx.R:0 R/spline.R:0 R/splinefun.R:0
msgid "zero non-NA points"
msgstr "zéro points non NA"

#. R/ar.R: stop("zero-variance series")
#: R/ar.R:0
msgid "zero-variance series"
msgstr "séries de variance nulle"

#. R/factanal.R: ngettext(factors, "%d factor is too many for %d variables", "%d factors are too many for %d variables")
#: R/factanal.R:0
msgid "%d factor is too many for %d variables"
msgid_plural "%d factors are too many for %d variables"
msgstr[0] "%d facteur, c'est trop pour %d variables"
msgstr[1] "%d facteurs, c'est trop pour %d variables"

#. R/lsfit.R: ngettext(sum(!good), "%d missing value deleted", "%d missing values deleted")
#: R/lsfit.R:0
msgid "%d missing value deleted"
msgid_plural "%d missing values deleted"
msgstr[0] "%d valeur manquante supprimée"
msgstr[1] "%d valeurs manquantes supprimées"

#. R/nafns.R: ngettext(n <- length(x), "%d observation deleted due to missingness",     "%d observations deleted due to missingness")
#: R/nafns.R:0
msgid "%d observation deleted due to missingness"
msgid_plural "%d observations deleted due to missingness"
msgstr[0] "%d observation effacée parce que manquante"
msgstr[1] "%d observations effacées parce que manquantes"

#. R/smspline.R: ngettext(diff, "%d observation with NA, NaN or Inf deleted",     "%d observations with NAs, NaNs and/or Infs deleted")
#: R/smspline.R:0
msgid "%d observation with NA, NaN or Inf deleted"
msgid_plural "%d observations with NAs, NaNs and/or Infs deleted"
msgstr[0] "%d observation avec NA, NaN ou Inf éliminée"
msgstr[1] "%d observations avec NA, NaN ou Inf éliminées"

#. R/lsfit.R: ngettext(nrx, "'X' matrix has %d case (row)", "'X' matrix has %d cases (rows)")
#: R/lsfit.R:0
msgid "'X' matrix has %d case (row)"
msgid_plural "'X' matrix has %d cases (rows)"
msgstr[0] "la matrice 'X' a %d cas (ligne)"
msgstr[1] "la matrice 'X' a %d cas (lignes)"

#. R/lsfit.R: ngettext(nry, "'Y' has %d case (row)", "'Y' has %d cases (rows)")
#: R/lsfit.R:0
msgid "'Y' has %d case (row)"
msgid_plural "'Y' has %d cases (rows)"
msgstr[0] "'Y' a %d cas (ligne)"
msgstr[1] "'Y' a %d cas (lignes)"

#. R/filter.R: ngettext(nser, "'init' must have %d column", "'init' must have 1 or %d columns",     domain = "R-stats")
#: R/filter.R:0
msgid "'init' must have %d column"
msgid_plural "'init' must have 1 or %d columns"
msgstr[0] "'init' doit avoir %d colonne"
msgstr[1] "'init' doit avoir %d colonnes"

#. R/models.R: ngettext(nr, "'newdata' had %d row", "'newdata' had %d rows")
#: R/models.R:0
msgid "'newdata' had %d row"
msgid_plural "'newdata' had %d rows"
msgstr[0] "'newdata' avait %d ligne"
msgstr[1] "'newdata' avait %d lignes"

#. R/factanal.R: ngettext(p, "'start' must have %d row", "'start' must have %d rows")
#: R/factanal.R:0
msgid "'start' must have %d row"
msgid_plural "'start' must have %d rows"
msgstr[0] "'start' doit avoir %d ligne"
msgstr[1] "'start' doit avoir %d lignes"

#. R/ts.R: ngettext(n.start, "'start.innov' is too short: need %d point",     "'start.innov' is too short: need %d points")
#: R/ts.R:0
msgid "'start.innov' is too short: need %d point"
msgid_plural "'start.innov' is too short: need %d points"
msgstr[0] "'start.innov' est trop court : il faut %d point"
msgstr[1] "'start.innov' est trop court : il faut %d points"

#. R/glm.R: ngettext(nobs, "X matrix has rank %d, but only %d observation",     "X matrix has rank %d, but only %d observations")
#: R/glm.R:0
msgid "X matrix has rank %d, but only %d observation"
msgid_plural "X matrix has rank %d, but only %d observations"
msgstr[0] "La matrice X est de rang %d, mais n'a que %d observation"
msgstr[1] "La matrice X est de rang %d, mais n'a que %d observations"

#. R/nlm.R: ngettext(maxiter, "_NOT_ converged in %d iteration", "_NOT_ converged in %d iterations")
#: R/nlm.R:0
msgid "_NOT_ converged in %d iteration"
msgid_plural "_NOT_ converged in %d iterations"
msgstr[0] "pas de convergence en %d itération"
msgstr[1] "pas de convergence en %d itérations"

#. R/lsfit.R: ngettext(ncx, "but %d variable", "but %d variables")
#: R/lsfit.R:0
msgid "but %d variable"
msgid_plural "but %d variables"
msgstr[0] "mais seulement %d variable"
msgstr[1] "mais seulement %d variables"

#. R/models.R: ngettext(nr2, "but variable found had %d row", "but variables found have %d rows")
#: R/models.R:0
msgid "but variable found had %d row"
msgid_plural "but variables found have %d rows"
msgstr[0] "mais la variable trouvée a %d ligne"
msgstr[1] "mais les variables trouvées ont %d lignes"

#. R/kmeans.R: ngettext(iter.max, "did not converge in %d iteration", "did not converge in %d iterations")
#: R/kmeans.R:0
msgid "did not converge in %d iteration"
msgid_plural "did not converge in %d iterations"
msgstr[0] "pas de convergence en %d itération"
msgstr[1] "pas de convergence en %d itérations"

#. R/dendrogram.R: ngettext(length(nms), "extra argument %s is not of class \"%s\"",     "extra arguments %s are not of class \"%s\"")
#: R/dendrogram.R:0
#, fuzzy
msgid "extra argument %s is not of class \"%s\""
msgid_plural "extra arguments %s are not of class \"%s\""
msgstr[0] "l'argument supplémentaire %s n'est pas un \"%s\""
msgstr[1] "les arguments supplémentaires %s ne sont pas des \"%s\""

#. R/models.R: ngettext(length(m), "factor %s has new level %s", "factor %s has new levels %s")
#: R/models.R:0
msgid "factor %s has new level %s"
msgid_plural "factor %s has new levels %s"
msgstr[0] "le facteur %s a un nouveau niveau %s"
msgstr[1] "le facteur %s a des nouveaux niveaux %s"

#. R/nls.R: ngettext(sum(np == -1), "fitting parameter %s without any variables",     "fitting parameters %s without any variables")
#: R/nls.R:0
msgid "fitting parameter %s without any variables"
msgid_plural "fitting parameters %s without any variables"
msgstr[0] "paramètres d'ajustement %s sans aucune variable"
msgstr[1] "paramètres d'ajustement %s sans aucunes variables"

#. R/add.R: ngettext(sum(where == 0), "lower scope has term %s not included in model",     "lower scope has terms %s not included in model")
#: R/add.R:0
msgid "lower scope has term %s not included in model"
msgid_plural "lower scope has terms %s not included in model"
msgstr[0] "la formule inférieure a un terme %s non inclus dans le modèle"
msgstr[1] "la formule inférieure a des termes %s non inclus dans le modèle"

#. R/medpolish.R: ngettext(maxiter, "medpolish() did not converge in %d iteration",     "medpolish() did not converge in %d iterations")
#: R/medpolish.R:0
msgid "medpolish() did not converge in %d iteration"
msgid_plural "medpolish() did not converge in %d iterations"
msgstr[0] "medpolish() n'a pas convergé en %d itération"
msgstr[1] "medpolish() n'a pas convergé en %d itérations"

#. R/lsfit.R: ngettext(nry, "only %d case", "only %d cases")
#: R/lsfit.R:0
msgid "only %d case"
msgid_plural "only %d cases"
msgstr[0] "mais seulement %d cas"
msgstr[1] "mais seulement %d cas"

#. R/selfStart.R: ngettext(sum(msng), "parameter %s does not occur in the model formula",     "parameters %s do not occur in the model formula")
#: R/selfStart.R:0
msgid "parameter %s does not occur in the model formula"
msgid_plural "parameters %s do not occur in the model formula"
msgstr[0] "le paramètre %s n'apparaît pas dans la formule du modèle"
msgstr[1] "les paramètres %s n'apparaîssent pas dans la formule du modèle"

#. R/aov.R: ngettext(length(indError), "there are %d Error terms: only 1 is allowed",     "there are %d Error terms: only 1 is allowed")
#: R/aov.R:0
msgid "there are %d Error terms: only 1 is allowed"
msgid_plural "there are %d Error terms: only 1 is allowed"
msgstr[0] "il y a %d terme d'erreur : un seul est autorisé"
msgstr[1] "il y a %d termes d'erreur : un seul est autorisé"

#. R/factanal.R: ngettext(nc, "unable to optimize from this starting value", "unable to optimize from these starting values")
#: R/factanal.R:0
msgid "unable to optimize from this starting value"
msgid_plural "unable to optimize from these starting values"
msgstr[0] "optimisation impossible à partir de la valeur initiale"
msgstr[1] "optimisation impossible à partir de ces valeurs initiales"

#. R/aov.R: ngettext(na, "unknown name %s in the 'split' list", "unknown names %s in the 'split' list")
#: R/aov.R:0
msgid "unknown name %s in the 'split' list"
msgid_plural "unknown names %s in the 'split' list"
msgstr[0] "nom %s inconnu dans la liste 'split'"
msgstr[1] "noms %s inconnus dans la liste 'split'"

#. R/nlminb.R: ngettext(length(nap), "unrecognized control element named %s ignored",     "unrecognized control elements named %s ignored")
#. R/nls.R: ngettext(length(nap), "unrecognized control element named %s ignored",     "unrecognized control elements named %s ignored")
#: R/nlminb.R:0 R/nls.R:0
msgid "unrecognized control element named %s ignored"
msgid_plural "unrecognized control elements named %s ignored"
msgstr[0] "élément de contrôle non reconnu nommé %s ignoré"
msgstr[1] "éléments de contrôle non reconnus nommés %s ignorés"

#. R/add.R: ngettext(sum(where == 0), "upper scope has term %s not included in model",     "upper scope has terms %s not included in model")
#: R/add.R:0
msgid "upper scope has term %s not included in model"
msgid_plural "upper scope has terms %s not included in model"
msgstr[0] "la formule inférieure a un terme %s non inclus dans le modèle"
msgstr[1] "la formule inférieure a des termes %s non inclus dans le modèle"

#. R/add.R: ngettext(newn, "using the %d/%d row from a combined fit", "using the %d/%d rows from a combined fit")
#: R/add.R:0
msgid "using the %d/%d row from a combined fit"
msgid_plural "using the %d/%d rows from a combined fit"
msgstr[0] "utilisation de %d/%d ligne d'un ajustement combiné"
msgstr[1] "utilisation des %d/%d lignes d'un ajustement combiné"

#~ msgid ","
#~ msgstr ","

#, fuzzy
#~ msgid "ignored"
#~ msgstr "' et ignoré(s)"

#~ msgid "deprecatedWarning"
#~ msgstr "deprecatedWarning"

#~ msgid "reformulate"
#~ msgstr "reformulez"

#~ msgid ".nknots.smspl() is now exported; use it instead of n.knots()"
#~ msgstr ".nknots.smspl() est maintenant exporté ; utilisez-le à la place de n.knots()"

#~ msgid "package 'MASS' must be installed"
#~ msgstr "le package 'MASS' doit être installé"

#~ msgid "link \"%s\" not available for quasipoisson family; available links are %s"
#~ msgstr "le lien \"%s\" n'est pas disponible pour la famille 'quasipoisson' ; les liens possibles sont %s"

#~ msgid "link \"%s\" not available for gaussian family; available links are %s"
#~ msgstr "le lien \"%s\" n'est pas disponible pour la famille 'gaussian' ; les liens possibles sont %s"

#~ msgid "link \"%s\" not available for binomial family; available links are %s"
#~ msgstr "le lien \"%s\" n'est pas disponible pour la famille 'binomial' ; les liens possibles sont %s"

#~ msgid "link \"%s\" not available for quasibinomial family; available links are %s"
#~ msgstr "le lien \"%s\" n'est pas disponible pour la famille 'quasibinomial' ; les liens possibles sont %s"

#~ msgid ""
#~ "for the 'quasibinomial' family, y must be a vector of 0 and 1's\n"
#~ "or a 2 column matrix where col 1 is no. successes and col 2 is no. failures"
#~ msgstr ""
#~ "pour la famille 'quasibinomial', y doit être un vecteur de 0 ou de 1\n"
#~ "ou une matrice à 2 colonnes où la col 1 est le nombre de succès et la col 2 le nombre d'échecs"

#~ msgid "link \"%s\" not available for gamma family; available links are %s"
#~ msgstr "le lien \"%s\" n'est pas disponible pour la famille 'gamma' ; les liens possibles sont %s"

#~ msgid "link \"%s\" not available for inverse.gaussian family; available links are %s"
#~ msgstr "le lien \"%s\" n'est pas disponible pour la famille 'inverse.gaussian' ; les liens possibles sont %s"

#~ msgid "all group levels must be finite"
#~ msgstr "tous les niveaux des groupes doivent être définis"

#~ msgid "invalid value of length(x)"
#~ msgstr "valeur incorrectye pour length(x)"

#~ msgid "'invalid value of 'k'"
#~ msgstr "valeur de 'k' incorrecte"

#~ msgid "invalid value of 'k'"
#~ msgstr "valeur de 'k' incorrecte"

#~ msgid "specified both 'df' and 'cv'; will disregard the latter"
#~ msgstr "'df' et 'cv' sont spécifiés simultanément ; le second sera ignoré"

#~ msgid "a limit is missing"
#~ msgstr "il manque une limite"

#~ msgid "'times' is wrong length"
#~ msgstr "'times' n'a pas la bonne longueur"

#~ msgid "non-matched further arguments are disregarded"
#~ msgstr "les arguments non nommés ultérieurs sont ignorés"

#~ msgid "extra argument %s will be disregarded"
#~ msgid_plural "extra arguments %s will be disregarded"
#~ msgstr[0] "argument supplémentaire %s ignorés"
#~ msgstr[1] "arguments supplémentaires %s ignorés"

#~ msgid "'merge' and 'height' do not fit!"
#~ msgstr "'merge' et 'height' ne se correspondent pas"

#~ msgid "invalid dendrogram"
#~ msgstr "dendrogramme incorrect"

#~ msgid "'merge' component in dendrogram must be integer"
#~ msgstr "la composante 'merge' du dendrogramme doit être un entier"

#~ msgid "probabilities cannot be negative nor all 0"
#~ msgstr "les probabilités ne peuvent pas être négatives, ni toutes nulles"

#~ msgid "'init' must have 1 or %d columns"
#~ msgstr "'init' doit avoir 1 ou %d colonnes"

#~ msgid "'deriv' must be between 0 and 2"
#~ msgstr "'deriv' doit être compris entre 0 et 2"

#~ msgid "%d response"
#~ msgid_plural "%d responses"
#~ msgstr[0] "%d réponse"
#~ msgstr[1] "%d réponses"

#~ msgid "character variable '%s' changed to a factor"
#~ msgstr "la variable chaîne de caractères '%s' est convertie en facteur"

#~ msgid "variable '%s' converted to a factor"
#~ msgstr "la variable '%s' est convertie en facteur"

#~ msgid "Burg's algorithm only implemented for univariate series"
#~ msgstr "l'algorithme de Burg n'est implémenté que pour des séries univariées"

#~ msgid "sample is too sparse to find TD"
#~ msgstr "l'échantillon est trop clairsemé pour estimer TD"

#~ msgid "sample is too sparse to find alph2"
#~ msgstr "l'échantillon est trop clairsemé pour estimer alph2"

#~ msgid "Cannot compute exact p-values with ties"
#~ msgstr "Impossible de calculer les p-values exactes avec des ex-aequos"

#~ msgid "we require a dendrogram"
#~ msgstr "nous avons besoin d'un dendrogramme"

#~ msgid "NA's are not allowed in groups or blocks"
#~ msgstr "les NAs ne sont pas autorisés dans les groupes ou les blocs"

#~ msgid "y, groups and blocks must have the same length"
#~ msgstr "y, les groupes et les blocs doivent être de même longueur"

#~ msgid "cannot compute exact p-values with ties"
#~ msgstr "impossible de calculer la valeur p exacte avec des ex-aequos"

#~ msgid "family '"
#~ msgstr "famille '"

#~ msgid "need multiple response"
#~ msgstr "réponse multiple nécessaire"

#~ msgid "internal error"
#~ msgstr "erreur interne"

#~ msgid "'proj' is not implemented for \"mlm\" fits"
#~ msgstr "'proj' n'est pas implémenté pour les ajustements \"mlm\""

#~ msgid "upper scope does not include model term(s) %s"
#~ msgstr "la formule supérieure n'inclus pas le ou les termes %s du modèle"

#~ msgid "for the binomial family, y must be a vector of 0 and 1's"
#~ msgstr "pour la famille binomial, 'y' doit être un vecteur de 0 et de 1"

#~ msgid "for the quasibinomial family, y must be a vector of 0 and 1's"
#~ msgstr "pour la famille quasibinomial, 'y' doit être un vecteur de 0 et de 1"

#~ msgid "using F test with a %s family is inappropriate"
#~ msgstr "l'utilisation d'un test F avec une famille %s n'est pas appropriée"

#~ msgid "did not converge in"
#~ msgstr "pas de convergence en"

#~ msgid "iterations"
#~ msgstr "itérations"

#~ msgid "removed because response differs from"
#~ msgstr "supprimés car la réponse diffère de"

#~ msgid "model 1"
#~ msgstr "modèle 1"

#~ msgid "residuals have rank"
#~ msgstr "les résidus sont de rang"

#~ msgid "<"
#~ msgstr "<"

#~ msgid "_NOT_ converged in"
#~ msgstr "_PAS_ de convergence en"

#~ msgid "use \"Brent\" or optimize() directly"
#~ msgstr "utilisation de \"Brent\" ou optimize() directement"

#~ msgid "hat values (leverages) are all ="
#~ msgstr "les 'hat values' (leverages) sont toutes ="

#, fuzzy
#~ msgid "invalid length(xout)"
#~ msgstr "longueur des membres incorrecte"

#~ msgid "contr*(.., sparse=TRUE) needs package \"Matrix\" correctly installed"
#~ msgstr "contr*(..., sparse=TRUE) nécessite un package \"Matrix\" installé correctement"

#~ msgid "this should not happen"
#~ msgstr "ceci ne devrait pas se produire"

#~ msgid "algorithm did not converge"
#~ msgstr "l'algorithme n'a pas convergé"

#~ msgid "incorrect specification of 'table' or 'start'"
#~ msgstr "spécification de 'table' ou de 'start' incorrecte"

#~ msgid "ifault=%d. This should not happen"
#~ msgstr "ifault=%d. Ceci ne devrait pas se produire"

#~ msgid "insufficient observations"
#~ msgstr "observations insuffisantes"

#~ msgid "'vec' contains NAs"
#~ msgstr "'vec' contient des NA"

#~ msgid "'vec' must be sorted non-decreasingly"
#~ msgstr "'vec' doit être trié de façon non décroissante"

#, fuzzy
#~ msgid "invalid length(vec)"
#~ msgstr "longueur des membres incorrecte"

#~ msgid "No starting values specified for some parameters."
#~ msgstr "Pas de valeurs initiales fournies pour certains paramètres."

#~ msgid "Initializing"
#~ msgstr "Initialisation"

#~ msgid "to '1.'."
#~ msgstr "à '1'."

#~ msgid "Consider specifying 'start' or using a selfStart model"
#~ msgstr "Spécifiez 'start' ou utilisez un model de type 'SelfStart'"

#~ msgid "wrong number of predictors"
#~ msgstr "nombre de prédicteurs incorrect"

#, fuzzy
#~ msgid "invalid value oflength(x)"
#~ msgstr "méthode de classification incorrecte"

#~ msgid "extra arguments"
#~ msgstr "les arguments surnuméraires"

#~ msgid "are just disregarded."
#~ msgstr "sont ignorés."

#~ msgid "cannot compute correct p-values with ties"
#~ msgstr "impossible de calculer les p-values correctes avec des ex-aequos"
