# Russian translations for R
# Русский перевод для R
#
# Copyright (C) 2008 The R Foundation
# This file is distributed under the same license as the R package.
# Alexey Garkovenko <garkovenko@gmail.com> 2007
# Alexey Shipunov <dactylorhiza at gmail.com> 2010
#
msgid ""
msgstr ""
"Project-Id-Version: R 4.4.0\n"
"Report-Msgid-Bugs-To: bugs.r-project.org\n"
"POT-Creation-Date: 2025-06-15 11:12\n"
"PO-Revision-Date: 2025-04-01 16:42+0200\n"
"Last-Translator: Ivan Krylov <ikrylov@disroot.org>\n"
"Language-Team: Russian <ru@li.org>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Poedit 3.5\n"
"X-Poedit-SourceCharset: UTF-8\n"

#. R/RMethodUtils.R: warning("\"MethodsList\" is defunct; allMethods now are empty")
#: R/RMethodUtils.R:0
msgid "\"MethodsList\" is defunct; allMethods now are empty"
msgstr "\"MethodsList\" больше не поддерживается; allMethods теперь пусты"

#. R/RClassUtils.R: stop("\"class\" is a reserved slot name and cannot be redefined")
#: R/RClassUtils.R:0
msgid "\"class\" is a reserved slot name and cannot be redefined"
msgstr "\"class\" является зарезервированным названием слота и не может быть переопределено"

#. R/MethodsListClass.R: gettextf("%d: target \"%s\": chose \"%s\" (others: %s)", i, target[[i]],     selected[[i]], paste0("\"", these, "\"", collapse = ", "))
#: R/MethodsListClass.R:0
msgid "%d: target \"%s\": chose \"%s\" (others: %s)"
msgstr "%d: цель \"%s\": выбрано \"%s\" (другие: %s)"

#. R/RMethodUtils.R: gettextf("%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list",     .renderSignature(generic@generic, signature), paste(sQuote(trailingArgs),         collapse = ", "), sQuote("..."))
#: R/RMethodUtils.R:0
msgid "%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list"
msgstr "%s аргументы (%s) после %s в общей должны появиться в методе, в той же позиции в конце списка аргументов"

#. R/Methods.R: gettextf("%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed.",     sQuote(name))
#: R/Methods.R:0
msgid "%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed."
msgstr "%s регулируется изнутри; методы могут быть определены, но общая функция подразумевается и не может быть изменена."

#. R/SClasses.R: gettextf("%s has a sealed class definition and cannot be redefined",     dQuote(Class))
#: R/SClasses.R:0
msgid "%s has a sealed class definition and cannot be redefined"
msgstr "%s имеет запечатанное определение класса и не может быть переопределено"

#. R/Methods.R: gettextf("%s has no methods defined", sQuote(f))
#: R/Methods.R:0
msgid "%s has no methods defined"
msgstr "%s не содержит определенных методов"

#. R/Methods.R: gettextf("%s is a primitive function; its generic form cannot be redefined",     sQuote(name))
#: R/Methods.R:0
msgid "%s is a primitive function; its generic form cannot be redefined"
msgstr "%s является примитивной функцией и не может быть переопределена"

#. R/SClasses.R: gettextf("%s is not a defined class", dQuote(Class))
#: R/SClasses.R:0
msgid "%s is not a defined class"
msgstr "%s не является определенным классом"

#. R/refClass.R: gettextf("%s is not a defined class in this environment", dQuote(Class))
#: R/refClass.R:0
msgid "%s is not a defined class in this environment"
msgstr "%s -- класс, который не определен в этом окружении"

#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(field), dQuote(thisClass@className))
#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(what), dQuote(def@className))
#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(what), dQuote(className))
#: R/refClass.R:0
msgid "%s is not a field in class %s"
msgstr "%s не является полем класса %s"

#. R/refClass.R: gettextf("%s is not a field in this class", sQuote(name))
#: R/refClass.R:0
msgid "%s is not a field in this class"
msgstr "%s не является полем в этом классе"

#. R/RMethodUtils.R: gettextf("%s is not a generic function (or not visible here)",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "%s is not a generic function (or not visible here)"
msgstr "%s не является общей функцией (либо не видна здесь)"

#. R/trace.R: gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)),     dQuote(class(where)))
#: R/trace.R:0
msgid "%s is not a method for reference class %s"
msgstr "%s не является методом для ссылки на класс %s"

#. R/refClass.R: gettextf("%s is not a reference class", dQuote(Class))
#. R/refClass.R: gettextf("%s is not a reference class", dQuote(def@className))
#: R/refClass.R:0
msgid "%s is not a reference class"
msgstr "%s не является ссылочным классом"

#. R/SClasses.R: gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl))
#: R/SClasses.R:0
msgid "%s is not a slot in class %s"
msgstr "%s не является позицией класса %s"

#. R/refClass.R: gettextf("%s is not a valid field or method name for reference class %s",     sQuote(field), dQuote(thisClass@className))
#: R/refClass.R:0
msgid "%s is not a valid field or method name for reference class %s"
msgstr "поле \"%s\" -- неправильное поле или имя метода для ссылочного класса %s"

#. R/refClass.R: gettextf("%s is not a valid field or method name for this class",     sQuote(what))
#: R/refClass.R:0
msgid "%s is not a valid field or method name for this class"
msgstr "поле %s -- неправильное поле или имя метода для этого класса"

#. R/Methods.R: gettextf("%s is not an S4 generic function in %s; methods not removed",     sQuote(f), sQuote(getPackageName(where)))
#: R/Methods.R:0
msgid "%s is not an S4 generic function in %s; methods not removed"
msgstr "%s не является общей функцией S4 в %s; методы не удалены"

#. R/Methods.R: gettextf("%s is not currently a generic:  define it first to create a non-default implicit form",     sQuote(name))
#: R/Methods.R:0
msgid "%s is not currently a generic:  define it first to create a non-default implicit form"
msgstr "%s в настоящее время не является общей функцией: определите ее первой, чтобы создать не умалчиваемую подразумеваемую форму"

#. R/RClassUtils.R: gettextf("%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)",     dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)"
msgstr "%s не может быть назначен частью данных другого класса (должен быть основным классом либо виртуальным классом без слотов)"

#. R/addedFunctions.R: gettextf("%s is not one of the element names", sQuote(name))
#: R/addedFunctions.R:0
msgid "%s is not one of the element names"
msgstr "%s не является одним из имен элемента"

#. R/refClass.R: gettextf("%s is not one of the reference super classes for this object",     dQuote(Class))
#: R/refClass.R:0
msgid "%s is not one of the reference super classes for this object"
msgstr "%s не является одной из ссылок суперкласса на этот объект"

#. R/trace.R: gettextf("%s() is not a generic function in the target environment -- methods will not be inserted",     f)
#: R/trace.R:0
msgid "%s() is not a generic function in the target environment -- methods will not be inserted"
msgstr "%s() не является общей функцией в целевом окружении -- методы не удут вставлены"

#. R/MethodsList.R: gettextf("%s, along with other use of the \"MethodsList\" metadata objects, is defunct.",     dQuote(this))
#: R/MethodsList.R:0
msgid "%s, along with other use of the \"MethodsList\" metadata objects, is defunct."
msgstr "%s, также как и иное использование объектов метаданных \"MethodsList\", больше не работает."

#. R/MethodsList.R: gettextf("%s, along with other use of the \"MethodsList\" metadata objects, is deprecated.",     dQuote(this))
#: R/MethodsList.R:0
msgid "%s, along with other use of the \"MethodsList\" metadata objects, is deprecated."
msgstr "%s, также как и иное использование объектов метаданных \"MethodsList\", не рекомендуется."

#. R/Methods.R: gettextf("'%s' is not a known generic function {and 'package' not specified}",     f)
#: R/Methods.R:0
msgid "'%s' is not a known generic function {and 'package' not specified}"
msgstr "'%s' не является известной общей функцией {и 'package' не указан}"

#. R/RClassUtils.R: stop("'Class' must be a valid class definition or class")
#: R/RClassUtils.R:0
msgid "'Class' must be a valid class definition or class"
msgstr "'Class' должен быть правильным определением класса либо классом"

#. R/oldClass.R: gettextf("'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s",     dQuote(class(object)))
#: R/oldClass.R:0
msgid "'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s"
msgstr "'S3Class' может быть определен только для таких S4-объектов, которые расширяют \"oldClass\"; это не так для класса %s"

#. R/oldClass.R: gettextf("'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s",     dQuote("oldClass"), dQuote(class(object)))
#: R/oldClass.R:0
msgid "'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s"
msgstr "'S3Class' определен только для расширений %s или классов с частями-данными: это не так у класса %s"

#. R/as.R: gettextf("'as' method should have one argument, or match the arguments of coerce(): got  (%s)",     paste(formalArgs(def), collapse = ", "))
#: R/as.R:0
msgid "'as' method should have one argument, or match the arguments of coerce(): got  (%s)"
msgstr "метод 'as' должен иметь один аргумент, или соответствовать аргументам coerce(): получено (%s)"

#. R/is.R: stop("'class1' must be the name of a class or a class definition")
#: R/is.R:0
msgid "'class1' must be the name of a class or a class definition"
msgstr "'class1' должен быть именем класса либо определением класса"

#. R/is.R: stop("'class2' must be the name of a class or a class definition")
#: R/is.R:0
msgid "'class2' must be the name of a class or a class definition"
msgstr "'class2' должен быть именем класса либо определением класса"

#. R/RClassUtils.R: stop("'externalptr' objects cannot be initialized from new()")
#: R/RClassUtils.R:0
msgid "'externalptr' objects cannot be initialized from new()"
msgstr "'externalptr' объекты не могут быть инициализированы из new()"

#. R/Methods.R: stop("'file' must be a character string or a connection")
#: R/Methods.R:0
msgid "'file' must be a character string or a connection"
msgstr "'file' должен быть текстовой строкой или соединением"

#. R/MethodsListClass.R: gettextf("'initialize' method returned an object of class %s instead of the required class %s",     paste(dQuote(class(value)), collapse = ", "), dQuote(class(.Object)))
#: R/MethodsListClass.R:0
msgid "'initialize' method returned an object of class %s instead of the required class %s"
msgstr "метод 'initialize' возвратил объект класса %s вместо требуемого класса %s"

#. R/RClassUtils.R: gettextf("(class %s)", .dQ(unlist(properties, recursive = FALSE)[undefClasses]))
#: R/RClassUtils.R:0
msgid "(class %s)"
msgstr "(класс %s)"

#. R/RMethodUtils.R: message("--- caching class ", sQuote(cl))
#: R/RMethodUtils.R:0
msgid "--- caching class"
msgstr ""

#. R/RMethodUtils.R: gettextf("--- done caching class %s", sQuote(cl))
#: R/RMethodUtils.R:0
msgid "--- done caching class %s"
msgstr ""

#. R/RMethodUtils.R: message("--- done getting generic ", sQuote(f))
#: R/RMethodUtils.R:0
msgid "--- done getting generic"
msgstr ""

#. R/RMethodUtils.R: gettextf("--- getting generic %s (and methods)", sQuote(f))
#: R/RMethodUtils.R:0
msgid "--- getting generic %s (and methods)"
msgstr ""

#. R/SClasses.R: gettextf("All %s names must be distinct in:\n(%s)", what, paste(sQuote(propNames),     collapse = ", "))
#: R/SClasses.R:0
msgid ""
"All %s names must be distinct in:\n"
"(%s)"
msgstr ""
"Все имена %s должны быть непустыми в:\n"
"(%s)"

#. R/SClasses.R: gettextf("All %s names must be nonempty in:\n(%s)", what, paste(sQuote(propNames),     collapse = ", "))
#: R/SClasses.R:0
msgid ""
"All %s names must be nonempty in:\n"
"(%s)"
msgstr ""
"Все имена %s должны быть непустыми в:\n"
"(%s)"

#. R/RClassUtils.R: message("Also defined by ", paste(sQuote(pkgs[-1]), collapse = " "))
#: R/RClassUtils.R:0
msgid "Also defined by"
msgstr "Также определен в"

#. R/show.R: gettextf("An object of class %s", dQuote(class(object)))
#: R/show.R:0
msgid "An object of class %s"
msgstr "Объект класса %s"

#. R/SClasses.R: stop("Argument \"representation\" cannot be used if argument \"slots\" is supplied")
#: R/SClasses.R:0
msgid "Argument \"representation\" cannot be used if argument \"slots\" is supplied"
msgstr "Аргумент \"representation\" нельзя использовать если указан аргумент \"slots\""

#. R/refClass.R: gettextf("Class %s is not a subclass of %s; functional semantics not defined for this class",     dQuote(class(object)), dQuote("envRefClass"))
#: R/refClass.R:0
msgid "Class %s is not a subclass of %s; functional semantics not defined for this class"
msgstr "Класс %s не является подклассом %s; функциональная семантика в этом классе не определена"

#. R/Methods.R: gettextf("Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)",     sQuote(f), sQuote(getPackageName(where)), sQuote(getPackageName(gwhere)))
#: R/Methods.R:0
msgid "Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)"
msgstr "Копирую общую функцию %s в окружение %s, потому что предыдущая версия была в запечатанном пространстве имен (%s)"

#. R/refClass.R: stop("Could not find local object in supplied environment")
#: R/refClass.R:0
msgid "Could not find local object in supplied environment"
msgstr "Не могу найти локальный объект в представленном окружении"

#. R/packageName.R: gettextf("Created a package name, %s, when none found", sQuote(pkg))
#: R/packageName.R:0
msgid "Created a package name, %s, when none found"
msgstr "Создано имя пакета, %s, в то время как ни одного не найдено"

#. R/Methods.R: gettextf("Creating a generic function for %s from %s in %s\n    (from the saved implicit definition)",     sQuote(name), sQuote(package), thisPName)
#: R/Methods.R:0
msgid ""
"Creating a generic function for %s from %s in %s\n"
"    (from the saved implicit definition)"
msgstr ""
"Создаю общую функцию для %s из %s в %s\n"
"    (из сохраненного подразумеваемого определения)"

#. R/Methods.R: gettextf("Creating a generic function for %s from package %s in %s",     sQuote(f), sQuote(fdef@package), thisPName)
#: R/Methods.R:0
msgid "Creating a generic function for %s from package %s in %s"
msgstr "Создание новой общей функции для %s из пакета %s в %s"

#. R/Methods.R: gettextf("Creating a generic function from function %s in %s",     sQuote(f), thisPName)
#: R/Methods.R:0
msgid "Creating a generic function from function %s in %s"
msgstr "Создание новой общей функции из функции %s в %s"

#. R/Methods.R: gettextf("Creating a new generic function for %s in %s", sQuote(name),     thisPName)
#: R/Methods.R:0
msgid "Creating a new generic function for %s in %s"
msgstr "Создание новой общей функции для %s в %s"

#. R/RClassUtils.R: stop("Data part is undefined for general S4 object")
#: R/RClassUtils.R:0
msgid "Data part is undefined for general S4 object"
msgstr "У общего S4 объекта не определена компонента данных"

#. R/RClassUtils.R: gettextf("Debugging .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);\nE := environment(): %s; parent.env(E): %s",     what, format(cwhere), format(E <- environment()), format(parent.env(E)))
#: R/RClassUtils.R:0
#, fuzzy
msgid ""
"Debugging .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);\n"
"E := environment(): %s; parent.env(E): %s"
msgstr "Проверка .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);"

#. R/RClassUtils.R: gettextf("Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s",     sQuote(dup), dQuote(name), dQuote(elNamed(allProps, dup)),     dQuote(cl), dQuote(elNamed(theseProperties, dup)))
#: R/RClassUtils.R:0
msgid "Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s"
msgstr "Определение слота %s в классе %s как %s конфликтует с определением, унаследованным из класса %s как %s"

#. R/RMethodUtils.R: message("Empty function name in .getGeneric")
#: R/RMethodUtils.R:0
msgid "Empty function name in .getGeneric"
msgstr "Пустое имя функции в .getGeneric"

#. R/trace.R: gettextf("Environment of class %s is locked; using global environment for new class",     dQuote(className))
#: R/trace.R:0
msgid "Environment of class %s is locked; using global environment for new class"
msgstr "Окружение класса %s заблокировано; использую глобальное окружение для нового класса"

#. R/Methods.R: gettextf("For function %s, signature %s: argument in method definition changed from (%s) to (%s)",     sQuote(f), sQuote(signature), mnames, fnames)
#: R/Methods.R:0
msgid "For function %s, signature %s: argument in method definition changed from (%s) to (%s)"
msgstr "Для функции %s, идентификатора %s: аргумент в определении метода изменен с (%s) на (%s)"

#. R/RClassUtils.R: gettextf("Found more than one class \"%s\" in cache; using the first, from namespace '%s'",     value[[1]]@className, pkgs[1])
#: R/RClassUtils.R:0
msgid "Found more than one class \"%s\" in cache; using the first, from namespace '%s'"
msgstr "В кеше найдено больше одного класса \"%s\"; использую первый, из пространства имен '%s'"

#. R/Methods.R: gettextf("Function %s is a group generic; do not call it directly",     sQuote(name))
#: R/Methods.R:0
msgid "Function %s is a group generic; do not call it directly"
msgstr "Функция %s является общегрупповой; не вызывайте ее напрямую"

#. R/Methods.R: gettextf("Function %s is already a group generic; no change",     sQuote(name))
#: R/Methods.R:0
msgid "Function %s is already a group generic; no change"
msgstr "Функция %s уже в группе общие; без изменений"

#. R/MethodsList.R: gettextf("In %s: use of \"MethodsList\" metadata objects is defunct.",     deparse(this))
#: R/MethodsList.R:0
msgid "In %s: use of \"MethodsList\" metadata objects is defunct."
msgstr "В %s: использование объектов метаданных \"MethodsList\" больше не работает."

#. R/MethodsList.R: gettextf("In %s: use of \"MethodsList\" metadata objects is deprecated.",     deparse(this))
#: R/MethodsList.R:0
msgid "In %s: use of \"MethodsList\" metadata objects is deprecated."
msgstr "В %s: использование объектов метаданных \"MethodsList\" не рекомендуется."

#. R/trace.R: gettextf("Methods inserted for function %s(): %s", f, paste(methodsInserted,     collapse = ", "))
#: R/trace.R:0
msgid "Methods inserted for function %s(): %s"
msgstr "Методы, вставленные для функции %s(): %s"

#. R/RMethodUtils.R: gettextf("Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information",     sQuote(fdef@generic))
#: R/RMethodUtils.R:0
msgid "Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information"
msgstr "Методы, перечисляющие объекты, не поддерживаются в этой версии R:  запрос функции %s может вернуть неправильную информацию"

#. R/refClass.R: gettextf("Methods not found: %s", paste(dQuote(methods[missing]),     collapse = ", "))
#: R/refClass.R:0
msgid "Methods not found: %s"
msgstr "Методы не найдены: %s"

#. R/trace.R: gettextf("Modified functions inserted through trace(): %s", paste(objectsDone,     collapse = ", "))
#: R/trace.R:0
msgid "Modified functions inserted through trace(): %s"
msgstr "Измененные функции вставлены через trace(): %s"

#. R/trace.R: gettextf("New functions are not currently inserted (not untraceable): %s",     paste(newObjects, collapse = ", "))
#: R/trace.R:0
msgid "New functions are not currently inserted (not untraceable): %s"
msgstr "Новые функции сейчас не установлены (не пригодны для untrace()): %s"

#. R/SClasses.R: gettextf("No %s names supplied", what)
#: R/SClasses.R:0
msgid "No %s names supplied"
msgstr "Не указаны имена %s"

#. R/NextMethod.R: stop("No next method available")
#: R/NextMethod.R:0
msgid "No next method available"
msgstr "Нет доступного следующего метода"

#. R/methodsTable.R: gettextf("No simply inherited methods found for function %s; using non-simple method",     sQuote(fdef@generic))
#: R/methodsTable.R:0
msgid "No simply inherited methods found for function %s; using non-simple method"
msgstr "Не найдено просто унаследованного метода для функции %s; использую непростой метод"

#. R/trace.R: gettextf("Non-function objects are not currently inserted (not traceable): %s",     paste(notTraceable, collapse = ", "))
#: R/trace.R:0
msgid "Non-function objects are not currently inserted (not traceable): %s"
msgstr "Объекты, не являющиеся функциями, в настоящее время не установлены (не пригодны для trace()): %s"

#. R/methodsTable.R: gettextf("Note: method with signature %s chosen for function %s,\n target signature %s.\n %s would also be valid",     sQuote(selected), sQuote(attr(cond, "generic")), sQuote(attr(cond,         "target")), paste0("\"", possible[is.na(match(possible,         selected))], "\"", collapse = ", "))
#: R/methodsTable.R:0
msgid ""
"Note: method with signature %s chosen for function %s,\n"
" target signature %s.\n"
" %s would also be valid"
msgstr ""
"Замечание: метод с подписью %s выбран для функции %s,\n"
" целевая подпись %s.\n"
" %s должна также быть правильной"

#. R/RClassUtils.R: gettextf("Note: some superclasses of class %s in package %s have duplicate definitions.  This definition is not being treated as equivalent to that from package %s",     dQuote(def@className), sQuote(def@package), sQuote(prev@package))
#: R/RClassUtils.R:0
msgid "Note: some superclasses of class %s in package %s have duplicate definitions.  This definition is not being treated as equivalent to that from package %s"
msgstr "Замечание: некоторые супер-классы класса %s пакета %s имеют двойные определения. Это определение не будет рассматриваться как соответствующее определению из пакета %s"

#. R/RClassUtils.R: gettextf("Note: the specification for class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class.",     dQuote(def@className), sQuote(def@package), sQuote(prev@package))
#: R/RClassUtils.R:0
msgid "Note: the specification for class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class."
msgstr "Замечание: спецификация класса %s пакета %s похоже на спецификацию из пакета %s: не будет дубликатом определений этого класса."

#. R/MethodsListClass.R: gettextf("\n    Notes: %s.\n", notei)
#: R/MethodsListClass.R:0
msgid "Notes: %s."
msgstr "Замечания: %s."

#. R/BasicClasses.R: gettextf("OOPS: something wrong with '.OldClassesPrototypes[[%d]]'",     i)
#: R/BasicClasses.R:0
msgid "OOPS: something wrong with '.OldClassesPrototypes[[%d]]'"
msgstr "OOPS: что-то не так с '.OldClassesPrototypes[[%d]]'"

#. R/refClass.R: gettextf("Reference superclasses must come from the same package for the environment to be defined:  got %s and %s",     .nQuote(clRefMethods$.objectPackage), .nQuote(pkg))
#: R/refClass.R:0
msgid "Reference superclasses must come from the same package for the environment to be defined:  got %s and %s"
msgstr "Reference superclasses must come from the same package for the environment to be defined:  got %s and %s"

#. R/Methods.R: gettextf("Restoring default function definition of %s", sQuote(f))
#: R/Methods.R:0
msgid "Restoring default function definition of %s"
msgstr "Восстанавливаю определение по умолчанию для функции %s"

#. R/ClassExtensions.R: gettextf("S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s",     dQuote(class(object)))
#: R/ClassExtensions.R:0
msgid "S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s"
msgstr "S3Part() определена только для классов установленных через setOldCLass(), их базовые классы или субклассы: это нетак для класса %s"

#. R/method.skeleton.R: gettextf("Skeleton of method written to %s", if (is.character(file)) file else "connection")
#: R/method.skeleton.R:0
msgid "Skeleton of method written to %s"
msgstr "Каркас метода записан в %s"

#. R/RClassUtils.R: gettextf("The prototype for class %s has undefined slot(s): %s",     dQuote(name), paste0("'", undefinedPrototypeSlots, "'", collapse = ", "))
#: R/RClassUtils.R:0
msgid "The prototype for class %s has undefined slot(s): %s"
msgstr "Прототип для класса %s включает неопределенный(ые) слот(ы): %s"

#. R/MethodsList.R: gettextf("Use %s instead. ", dQuote(instead))
#: R/MethodsList.R:0
msgid "Use %s instead."
msgstr "Вместо этого используйте %s."

#. R/as.R: gettextf("a 'replace' method definition in 'setAs' must be a function of two arguments, got %d",     length(args))
#: R/as.R:0
msgid "a 'replace' method definition in 'setAs' must be a function of two arguments, got %d"
msgstr "определение метода 'replace' в 'setAs' должно быть функцией двух аргументов, получено %d"

#. R/NextMethod.R: gettextf("a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'",     sQuote(f))
#: R/NextMethod.R:0
msgid "a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'"
msgstr "при обращении к %s, похоже был вызван callNextMethod(), но данный вызов не был, похоже, произведен другой общей функцией или другим 'callNextMethod'"

#. R/refClass.R: gettextf("a call to superClass() is in the method %s but there is no superclass definition of this method for class %s",     sQuote(me), dQuote(thisClass@className))
#: R/refClass.R:0
msgid "a call to superClass() is in the method %s but there is no superclass definition of this method for class %s"
msgstr "вызов superClass() есть в методе %s, но там нет определения суперклассаэтого метода для класса %s"

#. R/Methods.R: stop("a function for argument 'f' must be a generic function")
#: R/Methods.R:0
msgid "a function for argument 'f' must be a generic function"
msgstr "функция для аргумента 'f' должна быть общей функцией"

#. R/RClassUtils.R: gettextf("a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s",     dQuote(class(prototype@object)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s"
msgstr "прототип был предоставлен вместе с объектным слотом класса %s, но определение класса требует объект, являющийся классом %s"

#. R/RClassUtils.R: gettextf("a prototype was supplied of class %s, but the class definition requires an object that is class %s",     dQuote(class(prototype)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "a prototype was supplied of class %s, but the class definition requires an object that is class %s"
msgstr "прототип был предоставлен классом %s, но определение класса требует объект, являющийся классом %s"

#. R/refClass.R: gettextf("a single class name is needed for field %s, got a character vector of length %d",     sQuote(thisName), length(thisField))
#: R/refClass.R:0
msgid "a single class name is needed for field %s, got a character vector of length %d"
msgstr "нужно одно имя класса для поля %s, а поступил текстовый вектор %d"

#. R/RClassUtils.R: gettextf("a validity method must be a function of one argument, got an object of class %s",     dQuote(class(validity)))
#: R/RClassUtils.R:0
msgid "a validity method must be a function of one argument, got an object of class %s"
msgstr "метод проверки правильности должен быть функцией одного аргумента, получен объект класса %s"

#. R/SClasses.R: gettextf("abnormal type %s is not supported as a superclass of a class definition",     dQuote(type))
#: R/SClasses.R:0
msgid "abnormal type %s is not supported as a superclass of a class definition"
msgstr "ненормальный тип %s не боддерживается как суперкласс или определение класса"

#. R/RMethodUtils.R: gettextf("action function %s has no arguments, should have at least 1",     sQuote(fname))
#: R/RMethodUtils.R:0
msgid "action function %s has no arguments, should have at least 1"
msgstr "функция действия %s не имеет аргументов, а должен быть хотя бы один"

#. R/as.R: warning("ambiguous object (length != 1) to coerce to \"name\"")
#: R/as.R:0
msgid "ambiguous object (length != 1) to coerce to \"name\""
msgstr "сомнительный объект (длина != 1) для приведения к \"name\""

#. R/zzz.R: warning("apparently bad method or class metadata in saved environment;\n",     "move the file or remove the class/method")
#: R/zzz.R:0
msgid "apparently bad method or class metadata in saved environment;"
msgstr "очевидно плохой метод или метаданные класса в сохраненном окружении;"

#. R/Methods.R: gettextf("argument %s is not S4", deparse1(substitute(f1)))
#. R/Methods.R: gettextf("argument %s is not S4", deparse1(substitute(f2)))
#: R/Methods.R:0
msgid "argument %s is not S4"
msgstr "аргумент %s -- не S4"

#. R/Methods.R: gettextf("argument %s must be a generic function or a single character string; got an object of class %s",     sQuote("f"), dQuote(class(f)))
#: R/Methods.R:0
msgid "argument %s must be a generic function or a single character string; got an object of class %s"
msgstr "аргумент %s должен быть общей функцией или одной текстовой строкой; получен объект класса %s"

#. R/SClasses.R: gettextf("argument %s must be a list or a character vector; got an object of class %s",     dQuote(what), dQuote(class(fields)))
#: R/SClasses.R:0
msgid "argument %s must be a list or a character vector; got an object of class %s"
msgstr "аргумент %s должен быть общей функцией или одной текстовой строкой; получен объект класса %s"

#. R/oldClass.R: gettextf("argument 'Classes' must be a vector of two classes; got an argument of length %d",     length(Classes))
#: R/oldClass.R:0
msgid "argument 'Classes' must be a vector of two classes; got an argument of length %d"
msgstr "аргумент 'Classes' должен быть вектором двух классов; получен аргумент длины %d"

#. R/oldClass.R: gettextf("argument 'S4Class' must be a class definition: got an object of class %s",     dQuote(class(S4Class)))
#: R/oldClass.R:0
msgid "argument 'S4Class' must be a class definition: got an object of class %s"
msgstr "аргумент 'S4Class' должен быть определением класса: получен объект класса %s"

#. R/RClassUtils.R: stop("argument 'abbreviate' must be 0, 1, 2, or 3")
#: R/RClassUtils.R:0
msgid "argument 'abbreviate' must be 0, 1, 2, or 3"
msgstr "аргумент 'abbreviate' должен быть 0, 1, 2, или 3"

#. R/SClasses.R: stop("argument 'classDef' must be a class definition or the name of a class")
#: R/SClasses.R:0
msgid "argument 'classDef' must be a class definition or the name of a class"
msgstr "аргумент 'classDef' должен быть определением или именем класса"

#. R/SClasses.R: gettextf("argument 'classDef' must be a string or a class representation; got an object of class %s",     dQuote(class(classDef)))
#: R/SClasses.R:0
msgid "argument 'classDef' must be a string or a class representation; got an object of class %s"
msgstr "аргумент 'classDef' должен быть строкой либо представлением класса; получен объект класса %s"

#. R/Methods.R: gettextf("argument 'f' must be a generic function or %s", .notSingleString(f))
#: R/Methods.R:0
msgid "argument 'f' must be a generic function or %s"
msgstr "аргумент 'f' должен быть общей функцией или %s"

#. R/RMethodUtils.R: stop("argument 'f' must be a string, generic function, or primitive: got an ordinary function")
#: R/RMethodUtils.R:0
msgid "argument 'f' must be a string, generic function, or primitive: got an ordinary function"
msgstr "аргумент 'f' должен быть строкой, общей функцией, или примитивом: получена обычная функция"

#. R/RClassUtils.R: stop("argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'")
#: R/RClassUtils.R:0
msgid "argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'"
msgstr "аргумент 'includeSubclasses' должен быть логическим, либо иметь одно значение или быть вектором той же длины, что и классы аргумента"

#. R/trace.R: stop("argument 'signature' is not meaningful for tracing reference methods")
#: R/trace.R:0
msgid "argument 'signature' is not meaningful for tracing reference methods"
msgstr "аргумент 'signature' не имеет значения для выяснения методов ссылки"

#. R/Methods.R: warning("argument 'signature' is not meaningful with the current implementation and is ignored \n(extract a subset of the methods list instead)")
#: R/Methods.R:0
msgid ""
"argument 'signature' is not meaningful with the current implementation and is ignored \n"
"(extract a subset of the methods list instead)"
msgstr ""
"аргумент 'signature' ничего не значит в настоящее время и пропущен \n"
"(вместо этого укажите подмножество списка методов)"

#. R/methodsTable.R: stop("argument 'signatures' must be a character matrix whose rows are method signatures")
#: R/methodsTable.R:0
msgid "argument 'signatures' must be a character matrix whose rows are method signatures"
msgstr "аргумент 'signatures' должен быть символьной матрицей, чьи строки -- подписи метода"

#. R/trace.R: stop("argument 'what' should be the name of a function")
#: R/trace.R:0
msgid "argument 'what' should be the name of a function"
msgstr "аргумент 'what' должен быть именем функции"

#. R/RMethodUtils.R: stop("argument f must be a generic function with signature \"...\"")
#: R/RMethodUtils.R:0
msgid "argument f must be a generic function with signature \"...\""
msgstr "аргумент \"f\" должен быть общей функцией с подписью \"...\""

#. R/as.R: gettextf("argument names in 'replace' changed to agree with 'coerce<-' generic:\n%s",     paste(deparse(replace), sep = "\n    "))
#: R/as.R:0
msgid ""
"argument names in 'replace' changed to agree with 'coerce<-' generic:\n"
"%s"
msgstr ""
"имена аргументов в 'replace' изменены в соответствии с 'coerce<-' generic:\n"
"%s"

#. R/MethodsList.R: stop("arguments 'names' and 'signature' must have the same length")
#: R/MethodsList.R:0
msgid "arguments 'names' and 'signature' must have the same length"
msgstr "аргументы 'имена' и 'идентификатор' должны быть одинаковой длины"

#. R/refClass.R: stop("arguments must all be character string names of fields")
#: R/refClass.R:0
msgid "arguments must all be character string names of fields"
msgstr "аргументы должны быть текстовыми именами полей"

#. R/refClass.R: stop("arguments to methods() must be named, or one named list")
#: R/refClass.R:0
msgid "arguments to methods() must be named, or one named list"
msgstr "аргументы в methods() должны быть поименованы, или давайте один именованный список"

#. R/RClassUtils.R: gettextf("assigning as %s a class representation with internal name %s",     dQuote(Class), dQuote(def@className))
#: R/RClassUtils.R:0
msgid "assigning as %s a class representation with internal name %s"
msgstr "назначаю как %s представление класса с внутренним именем %s"

#. R/trace.R: gettextf("assigning over the binding of symbol %s in environment/package %s",     sQuote(what), sQuote(pname))
#: R/trace.R:0
msgid "assigning over the binding of symbol %s in environment/package %s"
msgstr "присвоение через связь символа %s в окружении/пакете %s"

#. R/SClasses.R: gettextf("assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE",     dQuote(valueClass), sQuote(name), dQuote(cl), slotClass)
#: R/SClasses.R:0
msgid "assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE"
msgstr "назначение объекта класса %s неверно для позиции %s в объекте класса %s; is(value, \"%s\") не является TRUE"

#. R/SClasses.R: gettextf("assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE",     dQuote(valueClass), sQuote(name), dQuote(cl), slotClass)
#: R/SClasses.R:0
msgid "assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE"
msgstr "назначение объекта класса %s неверно для позиции %s в объекте класса %s; is(value, \"%s\") не является TRUE"

#. R/Methods.R: gettextf("bad class specified for element %d (should be a single character string)",     i)
#: R/Methods.R:0
msgid "bad class specified for element %d (should be a single character string)"
msgstr "для элемента %d установлен неверный класс (должен быть односимвольной строкой)"

#. R/methodsTable.R: gettextf("bad method object stored in method table, class %s",     dQuote(class(current)))
#: R/methodsTable.R:0
msgid "bad method object stored in method table, class %s"
msgstr "плохой объект найден в качестве метода (класс %s)"

#. R/NextMethod.R: gettextf("bad object found as method (class %s)", dQuote(class(method)))
#: R/NextMethod.R:0
msgid "bad object found as method (class %s)"
msgstr "плохой объект найден в качестве метода (класс %s)"

#. R/is.R: gettext("both classes must be defined")
#: R/is.R:0
msgid "both classes must be defined"
msgstr "оба класса должны быть определены"

#. R/NextMethod.R: stop("call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context")
#: R/NextMethod.R:0
msgid "call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context"
msgstr "вызов 'callNextMethod' похоже, не входит в контекст 'method' либо 'callNextMethod'"

#. R/Methods.R: stop("callGeneric() must be called from within a method body")
#: R/Methods.R:0
msgid "callGeneric() must be called from within a method body"
msgstr "callGeneric() должна быть вызвана из тела метода"

#. R/is.R: gettextf("cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package",     dQuote(class1), dQuote(class2))
#: R/is.R:0
msgid "cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package"
msgstr "не могу создать 'setIs' отношение т.к. ни один из классов (%s и %s) не является локальным и модифицируемым в этом пакете"

#. R/trace.R: gettextf("cannot find an environment corresponding to package name '%s\"",     package)
#: R/trace.R:0
msgid "cannot find an environment corresponding to package name '%s\""
msgstr "не могу найти окружение, соответствующее имени пакета '%s\""

#. R/BasicClasses.R: stop("cannot have more than one unnamed argument as environment")
#: R/BasicClasses.R:0
msgid "cannot have more than one unnamed argument as environment"
msgstr "невозможно иметь более одного неименованного аргумента в окружении"

#. R/trace.R: gettextf("cannot insert methods for these functions (methods table not found in source): %s",     paste0("\"", methods[notThere], "\"", collapse = ", "))
#: R/trace.R:0
msgid "cannot insert methods for these functions (methods table not found in source): %s"
msgstr "не могу вставить методы для этих функций (таблица методов не найдена в исходниках): %s"

#. R/trace.R: gettextf("cannot insert these (not found in source): %s", paste0("\"",     functions[notThere], "\"", collapse = ", "))
#: R/trace.R:0
msgid "cannot insert these (not found in source): %s"
msgstr "не могу вставить это (в исходниках не найдено): %s"

#. R/Methods.R: gettextf("cannot remove methods for %s in locked environment/package %s",     sQuote(f), sQuote(getPackageName(db)))
#: R/Methods.R:0
msgid "cannot remove methods for %s in locked environment/package %s"
msgstr "не могу удалить методы %s в заблокированном окружении/пакете %s"

#. R/BasicClasses.R: stop("cannot specify array() arguments when specifying '.Data'")
#: R/BasicClasses.R:0
msgid "cannot specify array() arguments when specifying '.Data'"
msgstr "не могу определить аргументы array(), когда определяю '.Data'"

#. R/BasicClasses.R: stop("cannot specify matrix() arguments when specifying '.Data'")
#: R/BasicClasses.R:0
msgid "cannot specify matrix() arguments when specifying '.Data'"
msgstr "не могу определить аргументы matrix(), когда определяю '.Data'"

#. R/trace.R: gettextf("cannot untrace method for %s; no method defined for this signature: %s",     sQuote(what), paste(signature, collapse = ", "))
#: R/trace.R:0
msgid "cannot untrace method for %s; no method defined for this signature: %s"
msgstr "не могу детрассировать метод для %s; не определено метода для данной подписи: %s"

#. R/trace.R: stop("cannot use 'at' argument unless the function body has the form '{ ... }'")
#: R/trace.R:0
msgid "cannot use 'at' argument unless the function body has the form '{ ... }'"
msgstr "не могу использовать аргумент 'at' пока тело функции имеет форму '{ ... }'"

#. R/trace.R: stop("cannot use 'at' argument without a trace expression")
#: R/trace.R:0
msgid "cannot use 'at' argument without a trace expression"
msgstr "не могу использовать аргумент 'at' без отслеживаемого выражения"

#. R/SClasses.R: gettextf("cannot use object of class %s in new():  class %s does not extend that class",     dQuote(Classi), dQuote(Class))
#: R/SClasses.R:0
msgid "cannot use object of class %s in new():  class %s does not extend that class"
msgstr "не могу использовать объект класса %s в new():  класс %s не может расширить данный класс"

#. R/is.R: gettextf("class %s cannot extend class %s", dQuote(class1), dQuote(class2))
#: R/is.R:0
msgid "class %s cannot extend class %s"
msgstr "класс %s не может расширить класс %s"

#. R/RClassUtils.R: gettextf("class %s does not have a data part (a .Data slot) defined",     dQuote(class(object)))
#: R/RClassUtils.R:0
msgid "class %s does not have a data part (a .Data slot) defined"
msgstr "класс %s не имеет определенного раздела данных (позиция .Data)"

#. R/BasicClasses.R: gettextf("class %s does not have an S3 data part, and so is of type \"S4\"; no S3 equivalent",     dQuote(class(from)))
#: R/BasicClasses.R:0
msgid "class %s does not have an S3 data part, and so is of type \"S4\"; no S3 equivalent"
msgstr "класс %s не имеет определенного S3-раздела данных, и поэтому он типа \"S4\"; S3 эквивалента нет"

#. R/RClassUtils.R: gettextf("class %s extends an undefined class (%s)", dQuote(name),     dQuote(cl))
#: R/RClassUtils.R:0
msgid "class %s extends an undefined class (%s)"
msgstr "класс %s расширяет неопределенный класс (%s)"

#. R/RClassUtils.R: gettextf("class %s extends an undefined class, %s", dQuote(ClassDef@className),     dQuote(what))
#: R/RClassUtils.R:0
msgid "class %s extends an undefined class, %s"
msgstr "класс %s расширяет неопределенный класс, %s"

#. R/refClass.R: gettextf("class %s for field %s is not defined", dQuote(thisField),     sQuote(thisName))
#: R/refClass.R:0
msgid "class %s for field %s is not defined"
msgstr "класс %s для поля %s не определен"

#. R/RClassUtils.R: gettextf("class %s has a locked definition in package %s", dQuote(Class),     sQuote(getPackageName(where)))
#: R/RClassUtils.R:0
msgid "class %s has a locked definition in package %s"
msgstr "класс %s имеет заблокированное определение в пакете %s"

#. R/SClasses.R: gettextf("class %s has multiple definitions visible; only the first removed",     dQuote(Class))
#: R/SClasses.R:0
msgid "class %s has multiple definitions visible; only the first removed"
msgstr "класс %s имеет несколько видимых определений; удалено только первое"

#. R/is.R: gettextf("class %s has no visible definition from package or environment %s",     dQuote(class2), sQuote(getPackageName(where)))
#: R/is.R:0
msgid "class %s has no visible definition from package or environment %s"
msgstr "класс %s не имеет видимого определения в пакете либо окружении %s"

#. R/BasicClasses.R: gettextf("class %s is VIRTUAL; not meaningful to create an S4 object from this class",     dQuote(cl))
#: R/BasicClasses.R:0
msgid "class %s is VIRTUAL; not meaningful to create an S4 object from this class"
msgstr "rласс %s ВИРТУАЛЕН; не имеет смысла создавать S4-объект из этого класса"

#. R/as.R: gettextf("class %s is a class union: 'coerce' relations to a class union are not meaningful",     dQuote(to))
#: R/as.R:0
msgid "class %s is a class union: 'coerce' relations to a class union are not meaningful"
msgstr "класс %s является объединением классов: отношения 'coerce' для объединения классов бессмысленны"

#. R/is.R: gettextf("class %s is defined (with package slot %s) but no metadata object found to revise %s information---not imported?  Making a copy in package %s",     .dQ(class), sQuote(classDef@package), purpose, sQuote(getPackageName(where,         FALSE)))
#: R/is.R:0
msgid "class %s is defined (with package slot %s) but no metadata object found to revise %s information---not imported?  Making a copy in package %s"
msgstr "класс %s определен (со слотом из пакета %s), но не найден объект метаданных для проверки %s информации -- не экспортирован? Делаю копию в пакете %s"

#. R/refClass.R: gettextf("class %s is defined but is not a reference class",     dQuote(Class))
#: R/refClass.R:0
msgid "class %s is defined but is not a reference class"
msgstr "класс %s не  определен как ссылочный класс"

#. R/SClasses.R: gettextf("class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)",     dQuote(Class), sQuote(classDef@package))
#: R/SClasses.R:0
msgid "class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)"
msgstr "класс %s определен с пакетом %s, но соответствующего объекта метаданных не найдено (не экспортирован?)"

#. R/RClassUtils.R: gettextf("class %s is inheriting an inconsistent superclass structure from class %s, inconsistent with %s",     .dQ(className), .dQ(by), paste(.dQ(coni), collapse = ", "))
#: R/RClassUtils.R:0
msgid "class %s is inheriting an inconsistent superclass structure from class %s, inconsistent with %s"
msgstr "класс %s наследует несовместимую структуру надкласса из класса %s, несовместимую с %s"

#. R/as.R: gettextf("class %s is not defined in this environment", dQuote(to))
#: R/as.R:0
msgid "class %s is not defined in this environment"
msgstr "класс %s не определен в этом окружении"

#. R/SClasses.R: gettextf("class %s is sealed; 'resetClass' will have no effect",     dQuote(Class))
#: R/SClasses.R:0
msgid "class %s is sealed; 'resetClass' will have no effect"
msgstr "класс %s запечатан; 'resetClass' не будет иметь эффекта"

#. R/is.R: gettextf("class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'",     dQuote(class1))
#: R/is.R:0
msgid "class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'"
msgstr "класс %s запечатан; новые суперклассы нельзя определить, за исключением 'setClassUnion'"

#. R/SClasses.R: gettextf("class %s not found on %s; 'resetClass' will have no effect",     dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "class %s not found on %s; 'resetClass' will have no effect"
msgstr "класс %s не найден на %s; 'resetClass' останется без эффекта"

#. R/RClassUtils.R: stop("class cannot have both an ordinary and hidden data type")
#: R/RClassUtils.R:0
msgid "class cannot have both an ordinary and hidden data type"
msgstr "у класса не может быть одновременно обычного и скрытого типа данных"

#. R/SClasses.R: gettextf("class definition cannot extend more than one of these data types: %s",     paste0("\"", type, "\"", collapse = ", "))
#: R/SClasses.R:0
msgid "class definition cannot extend more than one of these data types: %s"
msgstr "определение класса на может расширить более чем один из этих типов данных: %s"

#. R/SClasses.R: gettextf("class definition for %s not found (no action taken)",     dQuote(Class))
#: R/SClasses.R:0
msgid "class definition for %s not found (no action taken)"
msgstr "определение класса для %s не найдено  (не предпринято никаких действий)"

#. R/MethodsListClass.R: gettextf("class generator function for class %s from package %s\n",     dQuote(object@className), sQuote(object@package))
#: R/MethodsListClass.R:0
msgid "class generator function for class %s from package %s"
msgstr "создание новой производящей функции для класса %s из пакета %s"

#. R/refClass.R: gettextf("class must be a reference class representation or a character string; got an object of class %s",     dQuote(class(Class)))
#: R/refClass.R:0
msgid "class must be a reference class representation or a character string; got an object of class %s"
msgstr "класс должен быть ссылочным представлением класса или текстовой строкой; получен объект класса %s"

#. R/refClass.R: gettextf("code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)",     dQuote(Class), sQuote("codetools"))
#: R/refClass.R:0
msgid "code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)"
msgstr "код методов в классе %s не был проверен на подозрительные назначения полей (рекоммендуемый пакет %s не доступен?)"

#. R/RClassUtils.R: gettextf("conflicting definition of data part: .Data = %s, superclass implies %s",     dQuote(elNamed(properties, ".Data")), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "conflicting definition of data part: .Data = %s, superclass implies %s"
msgstr "конфликтующее определение части данных: .Data = %s, суперкласс подразумевает %s"

#. R/MethodsList.R: gettextf("default method must be a method definition, a primitive or NULL: got an object of class %s",     dQuote(class(method)))
#: R/MethodsList.R:0
msgid "default method must be a method definition, a primitive or NULL: got an object of class %s"
msgstr "метод по умолчанию должен быть определением метода, примитивом или NULL: получен объект класса %s"

#. R/refClass.R: stop("direct calls to callSuper() are invalid:  should only be called from another method")
#: R/refClass.R:0
msgid "direct calls to callSuper() are invalid:  should only be called from another method"
msgstr "прямые вызовы callSuper() неправильны:  можно вызывать только из другого метода"

#. R/trace.R: gettextf("does not seem to be a method table for generic %s in tracing environment",     sQuote(what))
#: R/trace.R:0
msgid "does not seem to be a method table for generic %s in tracing environment"
msgstr "похоже, что для общего  %s нет таблицы методов в отслеживаемом окружении"

#. R/SClasses.R: gettextf("duplicate class names among superclasses: %s", paste(.dQ(includes[duplicated(includes)]),     collapse = ", "))
#: R/SClasses.R:0
msgid "duplicate class names among superclasses: %s"
msgstr "совпадение имен классов среди суперклассов: %s"

#. R/MethodsList.R: gettextf("duplicate element names in 'MethodsList' at level %d: %s",     level, paste("\"", unique(mnames[duplicated(mnames)]), "\"",         collapse = ", "))
#: R/MethodsList.R:0
msgid "duplicate element names in 'MethodsList' at level %d: %s"
msgstr "повторяющиеся имена элементов в 'MethodsList' на уровне %d: %s"

#. R/SClasses.R: gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]),     collapse = ", "))
#: R/SClasses.R:0
msgid "duplicated slot names: %s"
msgstr "совпадающие имена слотов: %s"

#. R/MethodsList.R: gettextf("element %d at level %d (class %s) cannot be interpreted as a function or named list",     i, level, dQuote(class(eli)))
#: R/MethodsList.R:0
msgid "element %d at level %d (class %s) cannot be interpreted as a function or named list"
msgstr "элемент %d на уровне %d (класс %s) не может быть интерпретирован как функция или именованный список"

#. R/SClasses.R: gettextf("element %d of the representation was not a single character string",     i)
#: R/SClasses.R:0
msgid "element %d of the representation was not a single character string"
msgstr "элемент %d представления не был одиночной символьной строкой"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s and unable to remove definition from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s and unable to remove definition from %s"
msgstr "ошибка в содержащихся классах (%s) для класса %s и не возможно удалить определение из %s"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s and unable to restore previous definition from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s and unable to restore previous definition from %s"
msgstr "ошибка в содержащихся классах (%s) для класса %s и не возможно восстановить предыдущее определение из %s"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s; class definition removed from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s; class definition removed from %s"
msgstr "ошибка в содержащихся классах (%s) для класса %s; определение класса удалено из %s"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s; previous definition restored to %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s; previous definition restored to %s"
msgstr "ошибка в содержащихся классах (%s) для класса %s; предыдущее определение восстановлено к %s"

#. R/RMethodUtils.R: gettextf("error in load action %s for package %s: %s: %s", aname,     getPackageName(where), callString, value$message)
#: R/RMethodUtils.R:0
msgid "error in load action %s for package %s: %s: %s"
msgstr "ошибка в действии загрузки %s для пакета %s: %s: %s"

#. R/Methods.R: gettextf("error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)",     sQuote(f), dQuote(class(fdef)))
#: R/Methods.R:0
msgid "error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)"
msgstr "ошибка в обновлении общей функции S4 %s; определение функции не является общей функцией S4 (класс %s)"

#. R/RMethodUtils.R: gettextf("expanding the signature to include omitted arguments in definition: %s",     paste(sigNames[omittedSig], "= \"missing\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "expanding the signature to include omitted arguments in definition: %s"
msgstr "расширяю идентификатор для включения опущенных аргументов в определении: %s"

#. R/addedFunctions.R: gettextf("expected a non-empty character string for argument 'name'")
#: R/addedFunctions.R:0
msgid "expected a non-empty character string for argument 'name'"
msgstr "ожидаю непустую текстовую строку для аргумента 'name'"

#. R/Methods.R: gettextf("expected a non-empty character string for argument name")
#: R/Methods.R:0
msgid "expected a non-empty character string for argument name"
msgstr "ожидаю непустую текстовую строку для имени аргумента"

#. R/oldClass.R: gettextf("explicit coercion of old-style class (%s) is not defined",     paste(class(from), collapse = ", "))
#: R/oldClass.R:0
msgid "explicit coercion of old-style class (%s) is not defined"
msgstr "не определено четкого приведения для устаревшего класса (%s)"

#. R/oldClass.R: gettextf("explicit replacement not defined for as(x, \"%s\") <- value for old-style class %s",     to, dQuote(class(from)[1L]))
#: R/oldClass.R:0
msgid "explicit replacement not defined for as(x, \"%s\") <- value for old-style class %s"
msgstr "не определено четкой замены для as(x, \"%s\") <- value для устаревшего класса %s"

#. R/methodsTable.R: stop("failed to find expected group generic function: ", what)
#: R/methodsTable.R:0
msgid "failed to find expected group generic function:"
msgstr "не могу найти ожидаемую групповую общую функцию:"

#. R/Methods.R: gettextf("fdef appears to be a generic function, but with generic name %s instead of %s",     sQuote(gen), sQuote(f))
#: R/Methods.R:0
msgid "fdef appears to be a generic function, but with generic name %s instead of %s"
msgstr "функция fdef, кажется, является общей функцией, но с общим именем %s вместо %s"

#. R/refClass.R: gettextf("field %s is already locked", sQuote(what))
#: R/refClass.R:0
msgid "field %s is already locked"
msgstr "поле %s уже заблокировано"

#. R/refClass.R: gettextf("field %s of class %s has a non-default binding and cannot be locked",     sQuote(what), dQuote(className))
#: R/refClass.R:0
msgid "field %s of class %s has a non-default binding and cannot be locked"
msgstr "поле %s  класса %s имеет присоединение не по умолчанию и не может быть заблокировано"

#. R/refClass.R: gettextf("field %s was supplied as an object of class %s; must be a class name or a binding function",     sQuote(thisName), dQuote(class(thisField)))
#: R/refClass.R:0
msgid "field %s was supplied as an object of class %s; must be a class name or a binding function"
msgstr "поле %s предложено как объект класса %s; а должно быть именем класса или функцией привязки"

#. R/Methods.R: gettextf("first argument should be the names of one of more generic functions (got object of class %s)",     dQuote(class(f)))
#: R/Methods.R:0
msgid "first argument should be the names of one of more generic functions (got object of class %s)"
msgstr "первый аргумент должен быть именем(-ами) общих функций (а получен объект класса %s)"

#. R/RMethodUtils.R: gettextf("formal arguments (%s) omitted in the method definition cannot be in the signature",     bad2)
#: R/RMethodUtils.R:0
msgid "formal arguments (%s) omitted in the method definition cannot be in the signature"
msgstr "формальные аргументы (%s), опущенные в определении метода, не могут быть в идентификаторе"

#. R/Methods.R: gettext("formal arguments differ (in default values?)")
#: R/Methods.R:0
msgid "formal arguments differ (in default values?)"
msgstr "формальные аргументы различаются (по умалчиваемым значениям?)"

#. R/Methods.R: gettextf("formal arguments differ: (%s), (%s)", paste(a1, collapse = ", "),     paste(a2, collapse = ", "))
#: R/Methods.R:0
msgid "formal arguments differ: (%s), (%s)"
msgstr "формальные аргументы различаются: (%s), (%s)"

#. R/RMethodUtils.R: stop(.renderSignature(f, signature), "formal arguments in method and generic do not appear in the same order",     call. = FALSE)
#. R/RMethodUtils.R: stop(.renderSignature(generic@generic, signature), "formal arguments in method and generic do not appear in the same order",     call. = FALSE)
#: R/RMethodUtils.R:0
msgid "formal arguments in method and generic do not appear in the same order"
msgstr "формальные аргументы в методе и общей функции появляются не в одинаковом порядке"

#. R/Methods.R: stop("function supplied as argument 'f' must be a generic")
#: R/Methods.R:0
msgid "function supplied as argument 'f' must be a generic"
msgstr "функция, предоставленная аргументом 'f' должна быть общей"

#. R/Methods.R: gettextf("generic function %s not found for removal", sQuote(f))
#: R/Methods.R:0
msgid "generic function %s not found for removal"
msgstr "общая функция %s не найдена для удаления"

#. R/Methods.R: gettextf("generic function supplied was not created for %s",     sQuote(name))
#: R/Methods.R:0
msgid "generic function supplied was not created for %s"
msgstr "указанная для %s общая функция не создана"

#. R/Methods.R: gettextf("generic names differ: %s, %s", .dQ(f1@generic), .dQ(f2@generic))
#: R/Methods.R:0
msgid "generic names differ: %s, %s"
msgstr "общие имена различаются: %s, %s"

#. R/RMethodUtils.R: stop("got a negative maximum number of frames to look at")
#: R/RMethodUtils.R:0
msgid "got a negative maximum number of frames to look at"
msgstr "получено отрицательное максимальное число структур для поиска"

#. R/Methods.R: gettextf("groups differ: %s, %s", .dQ(gpString(f1@group)), .dQ(gpString(f2@group)))
#: R/Methods.R:0
msgid "groups differ: %s, %s"
msgstr "группы различаются: %s, %s"

#. R/Methods.R: gettextf("if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default",     name)
#: R/Methods.R:0
msgid "if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default"
msgstr "если предоставлен аргумент 'def' , он должен быть функцией, которая вызывает standardGeneric(\"%s\") или умолчание"

#. R/RMethodUtils.R: gettextf("in changing formal arguments in %s, some of the old names are not in fact arguments: %s",     msg, paste0("\"", old[is.na(match(old, names(dlist)))], "\"",         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "in changing formal arguments in %s, some of the old names are not in fact arguments: %s"
msgstr "при изменении формальных аргументов в %s, некоторые старые имена не являются аргументами: %s"

#. R/RClassUtils.R: gettextf("in constructing the prototype for class %s, slots in prototype and not in class: %s",     dQuote(className), paste(extra, collapse = ", "))
#: R/RClassUtils.R:0
msgid "in constructing the prototype for class %s, slots in prototype and not in class: %s"
msgstr "при конструировании прототипа класса %s, слоты в прототипе и не в классе: %s"

#. R/RClassUtils.R: gettextf("in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s",     dQuote(className), dQuote(.class1(prototype)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s"
msgstr "при конструировании прототипа для класса %s: прототип является классом %s, но его данные указывают на класс %s"

#. R/RClassUtils.R: gettextf("in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)",     dQuote(name), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)"
msgstr "при определении класса %s, предоставленная часть данных класса, %s не верна (должна быть основным классом или виртуальным классом, включающем основные классы)"

#. R/RClassUtils.R: gettextf("in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")",     dQuote(ClassDef@className), dQuote(what), dQuote(class(exti)))
#: R/RClassUtils.R:0
msgid "in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")"
msgstr "в определении класса %s, информация для суперкласса %s принадлежит классу %s (ожидалось \"SClassExtension\")"

#. R/RClassUtils.R: gettextf("in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s",     dQuote(className), paste(pnames[check], "(class", .dQ(slotDefs[match(pnames[check],         slotNames)]), ")", collapse = ", "))
#: R/RClassUtils.R:0
msgid "in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s"
msgstr "при создании прототипа для класса %s элементы прототипа не совпадают с соответствующим слотом класса: %s"

#. R/RMethodUtils.R: gettextf("in method for %s with signature %s: ", sQuote(f), sQuote(msig))
#: R/RMethodUtils.R:0
msgid "in method for %s with signature %s:"
msgstr "в методе для %s с идентификатором %s:"

#. R/oldClass.R: gettextf("inconsistent old-style class information for %s (maybe mixing old and new classes?)",     dQuote(cl))
#: R/oldClass.R:0
msgid "inconsistent old-style class information for %s (maybe mixing old and new classes?)"
msgstr "противоречивая, в старом стиле информация для класса %s (возможно имеет место смешение старых и новых классов?)"

#. R/oldClass.R: gettextf("inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part",     dQuote(cl), dQuote(prevClass))
#: R/oldClass.R:0
msgid "inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part"
msgstr "противоречивая, в старом стиле информация для %s; класс определен, но не расширяет %s и неправилен как часть данных"

#. R/RClassUtils.R: gettextf("initializing objects from class %s with these arguments is not supported",     dQuote(Class))
#: R/RClassUtils.R:0
msgid "initializing objects from class %s with these arguments is not supported"
msgstr "инициализация объектов из класса %s с такими аргументами не поддерживается"

#. R/MethodsList.R: stop("inserting method corresponding to empty signature")
#: R/MethodsList.R:0
msgid "inserting method corresponding to empty signature"
msgstr "вставляю метод соответствующий пустому идентификатору"

#. R/MethodsList.R: gettextf("inserting method into non-methods-list object (class %s)",     dQuote(.class1(mlist)))
#: R/MethodsList.R:0
msgid "inserting method into non-methods-list object (class %s)"
msgstr "вставляю метод в объект, не являющийся списком методов (класс %s)"

#. R/MethodsList.R: gettextf("inserting method with invalid signature matching argument '...' to class %s",     dQuote(signature[[1L]]))
#: R/MethodsList.R:0
msgid "inserting method with invalid signature matching argument '...' to class %s"
msgstr "вставка метода с неверным идентификатором, совпадающим с аргументом '...' в класс %s"

#. R/refClass.R: stop("invalid 'Class' argument:  should be a single string")
#: R/refClass.R:0
msgid "invalid 'Class' argument:  should be a single string"
msgstr "неправильный 'Class' аргумент:  должен быть простой строкой"

#. R/show.R: gettextf("invalid 'ignore' argument; should be a class definition or a character vector, got an object of class %s",     dQuote(class(ignore)))
#: R/show.R:0
msgid "invalid 'ignore' argument; should be a class definition or a character vector, got an object of class %s"
msgstr "неправильный 'ignore' argument; должен быть определенем класса или текстовой строкой; получен объект класса %s"

#. R/MethodsList.R: stop("invalid 'package' slot or attribute, wrong length")
#: R/MethodsList.R:0
msgid "invalid 'package' slot or attribute, wrong length"
msgstr "неправильная позиция слота или атрибута, неправильная длина"

#. R/trace.R: gettextf("invalid 'source' argument: expected file names or a connection but got an object of class %s",     dQuote(class(source)[[1L]]))
#: R/trace.R:0
msgid "invalid 'source' argument: expected file names or a connection but got an object of class %s"
msgstr "неправильный исходный аргумент: ждал имени файлов или соединения, а получил объект класса %s"

#. R/oldClass.R: gettextf("invalid S4 class corresponding to S3 class: slots in S4 version must extend corresponding slots in S3 version: fails for %s",     paste0("\"", bad, "\"", collapse = ", "))
#: R/oldClass.R:0
#, fuzzy
msgid "invalid S4 class corresponding to S3 class: slots in S4 version must extend corresponding slots in S3 version: fails for %s"
msgstr "неправильный S4 класс соответствует S3 классу: слоты в S4 версии должны расширять соответствсующие слоты в S3 версии: не удается для %s"

#. R/Methods.R: gettextf("invalid argument 'name': %s", .isSingleName(name))
#: R/Methods.R:0
msgid "invalid argument 'name': %s"
msgstr "неправильное 'name' аргумента: %s"

#. R/refClass.R: gettextf("invalid assignment for reference class field %s, should be from class %s or a subclass (was class %s)",     sQuote(fieldName), dQuote(fieldClass), dQuote(class(value)))
#: R/refClass.R:0
msgid "invalid assignment for reference class field %s, should be from class %s or a subclass (was class %s)"
msgstr "неправильная замена для поля класса %s, должна быть из класса %s или подкласса (был класс %s)"

#. R/show.R: gettextf("invalid call to 'classLabel': expected a name or a class definition, got an object of class %s",     classLabel(class(Class)))
#: R/show.R:0
msgid "invalid call to 'classLabel': expected a name or a class definition, got an object of class %s"
msgstr "неверный вызов 'classLabel': ожидалось имя либо определение класса, получен объект класса %s"

#. R/SClasses.R: gettextf("invalid class %s object", dQuote(Class))
#: R/SClasses.R:0
msgid "invalid class %s object"
msgstr "неверный объект класса %s"

#. R/MethodsList.R: gettextf("invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name",     i)
#: R/MethodsList.R:0
msgid "invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name"
msgstr "неправильный элемент в списке аргументов \"signature\"; элемент %d -- не определение и не имя класса"

#. R/RMethodUtils.R: gettextf("invalid element in the \"groupMembers\" slot (class %s)",     dQuote(class(x)))
#: R/RMethodUtils.R:0
msgid "invalid element in the \"groupMembers\" slot (class %s)"
msgstr "неверный элемент в \"groupMembers\" слоте (класс %s)"

#. R/MethodsList.R: stop("invalid first argument: should be the name of the first argument in the dispatch")
#: R/MethodsList.R:0
msgid "invalid first argument: should be the name of the first argument in the dispatch"
msgstr "неверный первый аргумент: должно быть имя первого аргумента в отправке"

#. R/methodsTable.R: gettextf("invalid group generic function in search for inherited method (class %s)",     dQuote(class(gen)))
#: R/methodsTable.R:0
msgid "invalid group generic function in search for inherited method (class %s)"
msgstr "неверная групповая общая функция в поиске для наследованного метода (класс %s)"

#. R/languageEl.R: stop("invalid index for function argument")
#: R/languageEl.R:0
msgid "invalid index for function argument"
msgstr "неверный индекс для аргумента функции"

#. R/Methods.R: gettextf("invalid method definition: expected a function, got an object of class %s",     dQuote(class(definition)))
#: R/Methods.R:0
msgid "invalid method definition: expected a function, got an object of class %s"
msgstr "неверное определение метода: ожидалась функция, а получен объект класса %s"

#. R/methodsTable.R: gettextf("invalid method element for signature %s at level %d (should be MethodDefinition or .Primitive, had class %s)",     sQuote(classes[[j]]), i, dQuote(class(el)))
#: R/methodsTable.R:0
#, fuzzy
msgid "invalid method element for signature %s at level %d (should be MethodDefinition or .Primitive, had class %s)"
msgstr "неправильный элемент mlist для подписи %s на уровне %d (должен быть MethodDefinition либо .Primitive, имеет класс %s)"

#. R/methodsTable.R: stop("invalid methods table request")
#: R/methodsTable.R:0
msgid "invalid methods table request"
msgstr "неверный запрос к таблице методов"

#. R/MethodsListClass.R: gettextf("invalid object for formal method definition: type %s",     dQuote(typeof(def)))
#: R/MethodsListClass.R:0
msgid "invalid object for formal method definition: type %s"
msgstr "неверный объект для формального определения метода: тип %s"

#. R/methodsTable.R: gettextf("invalid object in meta table of methods for %s, label %s, had class %s",     sQuote(generic@generic), sQuote(what), dQuote(class(obj)))
#: R/methodsTable.R:0
msgid "invalid object in meta table of methods for %s, label %s, had class %s"
msgstr "неверный объект в мета-таблице методов для %s, метка %s, имеет класс %s"

#. R/methodsTable.R: gettextf("invalid object in methods table (%s), expected a method, got an object of class %s",     sQuote(what), dQuote(class(method)))
#: R/methodsTable.R:0
msgid "invalid object in methods table (%s), expected a method, got an object of class %s"
msgstr "неверный объект в таблице методов (%s): ожидался метод, а получен объект класса %s"

#. R/methodsTable.R: gettextf("invalid or unset methods table in generic function %s",     sQuote(fdef@generic))
#: R/methodsTable.R:0
msgid "invalid or unset methods table in generic function %s"
msgstr "неверная или неустановленная таблица методов в общей функции %s"

#. R/refClass.R: gettextf("invalid replacement: reference class field %s is read-only",     sQuote(fieldName))
#: R/refClass.R:0
msgid "invalid replacement: reference class field %s is read-only"
msgstr "неправильная замена: поле ссылочного класса %s только для чтения"

#. R/RMethodUtils.R: gettextf("invalid value from generic function %s, class %s, expected %s",     sQuote(fname), dQuote(class(object)), paste(dQuote(classes),         collapse = " or "))
#: R/RMethodUtils.R:0
msgid "invalid value from generic function %s, class %s, expected %s"
msgstr "неверное значение из общей функции %s, класс %s, ожидалось %s"

#. R/refClass.R: gettextf("local assignment to field name will not change the field:\n    %s\n Did you mean to use \"<<-\"? ( in method %s for class %s)",     paste(unlist(assigned$locals)[localsAreFields], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"local assignment to field name will not change the field:\n"
"    %s\n"
" Did you mean to use \"<<-\"? ( in method %s for class %s)"
msgstr ""
"локальное назначение имени поля не изменит поле:\n"
"    %s\n"
" Может быть, Вы хотели использовать \"<<-\"? ( в методе %s класса %s)"

#. R/RMethodUtils.R: gettextf("making a generic for special function %s", sQuote(f))
#: R/RMethodUtils.R:0
msgid "making a generic for special function %s"
msgstr "создаю общую для специальной функции %s"

#. R/trace.R: warning("making a traced version of a special; arguments may be altered")
#: R/trace.R:0
msgid "making a traced version of a special; arguments may be altered"
msgstr "создаю отслеживаемую версию special; аргументы могут быть изменены"

#. R/debug.R: warning("method is not being debugged")
#: R/debug.R:0
msgid "method is not being debugged"
msgstr "метод не проверен"

#. R/RMethodUtils.R: gettextf("methods can add arguments to the generic %s only if '...' is an argument to the generic",     sQuote(generic@generic))
#: R/RMethodUtils.R:0
msgid "methods can add arguments to the generic %s only if '...' is an argument to the generic"
msgstr "методы могут добавлять аргументы в общую %s только если '...' является аргументом для общей"

#. R/as.R: gettextf("methods currently exist for coercing from %s to %s; they will be replaced.",     dQuote(from), dQuote(to))
#: R/as.R:0
msgid "methods currently exist for coercing from %s to %s; they will be replaced."
msgstr "методы для приведения %s к %s уже существуют; они будут заменены."

#. R/refClass.R: gettextf("methods declared in usingMethods() but not found: %s",     paste0(declared[!declared %in% allMethods], collapse = ", "))
#: R/refClass.R:0
msgid "methods declared in usingMethods() but not found: %s"
msgstr "методы объявлены в usingMethods(), но не найдены: %s"

#. R/BasicFunsList.R: gettextf("methods may not be defined for primitive function %s in this version of R",     sQuote(f))
#: R/BasicFunsList.R:0
msgid "methods may not be defined for primitive function %s in this version of R"
msgstr "в этой версии R методы не могут быть определены для элементарной функции %s"

#. R/Defunct.R: stop("methods:::bind_activation() is defunct;\n rather provide methods for cbind2() / rbind2()")
#: R/Defunct.R:0
msgid ""
"methods:::bind_activation() is defunct;\n"
" rather provide methods for cbind2() / rbind2()"
msgstr ""
"methods:::bind_activation() больше не работает;\n"
" вместо этого, определите методы для cbind2() / rbind2()"

#. R/RMethodUtils.R: gettextf("missing function for load action: %s", what)
#: R/RMethodUtils.R:0
msgid "missing function for load action: %s"
msgstr "нет функции для действия загрузки: %s"

#. R/MethodsListClass.R: gettextf("missing package slot (%s) in object of class %s (package info added)",     packageSlot(co), dQuote(class(.Object)))
#: R/MethodsListClass.R:0
msgid "missing package slot (%s) in object of class %s (package info added)"
msgstr "отсутствует позиция пакета (%s) в объекте класса %s (добавлена информация о пакете)"

#. R/MethodsList.R: gettextf("more elements in the method signature (%d) than in the generic signature (%d) for function %s",     length(signature), length(anames), sQuote(fun@generic))
#: R/MethodsList.R:0
msgid "more elements in the method signature (%d) than in the generic signature (%d) for function %s"
msgstr "в идентификаторе метода (%d) больше элементов, чем в общем идентификаторе (%d) функции %s"

#. R/RClassUtils.R: gettextf("more than one possible class for the data part: using %s rather than %s",     .dQ(prevDataPartClass), .dQ(value))
#: R/RClassUtils.R:0
msgid "more than one possible class for the data part: using %s rather than %s"
msgstr "более одного возможного класса для части данных: использую %s, а не %s"

#. R/zzz.R: warning("apparently bad method or class metadata in saved environment;\n",     "move the file or remove the class/method")
#: R/zzz.R:0
msgid "move the file or remove the class/method"
msgstr "переместить файл или удалить класс/метод"

#. R/SClasses.R: gettextf("multiple class definitions for %s from packages: %s; picking the first",     dQuote(className), paste(sQuote(pkgs), collapse = ", "))
#: R/SClasses.R:0
msgid "multiple class definitions for %s from packages: %s; picking the first"
msgstr "много определений класса для %s из пакетов: %s; беру первое"

#. R/RMethodUtils.R: gettextf("multiple definitions exist for class %s, but the supplied package (%s) is not one of them (%s)",     dQuote(classi), sQuote(pkgi), paste(dQuote(get(classi, envir = .classTable)),         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "multiple definitions exist for class %s, but the supplied package (%s) is not one of them (%s)"
msgstr "существует несколько определений класса %s, но представленный пакет (%s) не из них (%s)"

#. R/RMethodUtils.R: gettextf("multiple definitions exist for class %s; should specify one of them (%s), e.g. by className()",     dQuote(classi), paste(dQuote(get(classi, envir = .classTable)),         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "multiple definitions exist for class %s; should specify one of them (%s), e.g. by className()"
msgstr "есть много определений класса %s; надо указать одно из них (%s), например, через className()"

#. R/promptClass.R: gettextf("multiple definitions of %s found; using the one on %s",     dQuote(clName), whereClass)
#: R/promptClass.R:0
msgid "multiple definitions of %s found; using the one on %s"
msgstr "найдено несколько определений %s; использую одно из %s"

#. R/RMethodUtils.R: gettextf("multiple direct matches: %s; using the first of these",     .pasteC(classes))
#: R/RMethodUtils.R:0
msgid "multiple direct matches: %s; using the first of these"
msgstr "много прямых соответствий: %s; использую первое из них"

#. R/RMethodUtils.R: gettextf("multiple equivalent inherited matches: %s; using the first of these",     .pasteC(classes))
#: R/RMethodUtils.R:0
msgid "multiple equivalent inherited matches: %s; using the first of these"
msgstr "много равных унаследованных соответствий: %s; использую первое из них"

#. R/trace.R: gettextf("multiple generics match pattern, using table %s", table)
#: R/trace.R:0
msgid "multiple generics match pattern, using table %s"
msgstr "множественные общие совпадающие паттерны, использую таблицу %s"

#. R/Methods.R: gettextf("must provide an environment table; got class %s", dQuote(class(what)))
#: R/Methods.R:0
msgid "must provide an environment table; got class %s"
msgstr "нужно указать таблицу окружения; получен класс %s"

#. R/Methods.R: stop("must supply 'generic.function' or 'class'")
#: R/Methods.R:0
msgid "must supply 'generic.function' or 'class'"
msgstr "надо указать 'generic.function' или 'class'"

#. R/Methods.R: gettextf("must supply a function skeleton for %s, explicitly or via an existing function",     sQuote(name))
#: R/Methods.R:0
msgid "must supply a function skeleton for %s, explicitly or via an existing function"
msgstr "необходимо предоставить каркас %s, явно либо через вызов существующей функции"

#. R/RMethodUtils.R: gettextf("must supply either a generic function or a function as default for %s",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "must supply either a generic function or a function as default for %s"
msgstr "надо определить либо общую функцию, либо функцию по умолчанию для %s"

#. R/method.skeleton.R: stop("need a definition for the method here")
#: R/method.skeleton.R:0
msgid "need a definition for the method here"
msgstr "здесь нужно определение метода"

#. R/RClassUtils.R: gettextf("needed the supplied labels vector of length %d, got %d",     length(nodes), length(short))
#: R/RClassUtils.R:0
msgid "needed the supplied labels vector of length %d, got %d"
msgstr "нужны добавочные метки вектора длины %d, а получено %d"

#. R/RClassUtils.R: gettextf("no '.Data' slot defined for class %s", dQuote(class(object)))
#: R/RClassUtils.R:0
msgid "no '.Data' slot defined for class %s"
msgstr "не определена позиция '.Data' для класса %s"

#. R/ClassExtensions.R: gettextf("no 'replace' method was defined for 'as(x, \"%s\") <- value' for class %s",     to, dQuote(class(from)))
#: R/ClassExtensions.R:0
msgid "no 'replace' method was defined for 'as(x, \"%s\") <- value' for class %s"
msgstr "не было определено 'replace' метода для 'as(x, \"%s\") <- value' для класса %s"

#. R/trace.R: gettextf("no definition for object %s found in tracing environment",     sQuote(what))
#: R/trace.R:0
msgid "no definition for object %s found in tracing environment"
msgstr "в отслеживаемом окружении на найдено определения объекта %s"

#. R/fixPrevious.R: gettextf("no definition for the class of %s (class %s) found",     sQuote(what), dQuote(class))
#: R/fixPrevious.R:0
msgid "no definition for the class of %s (class %s) found"
msgstr "не найдено определения для класса из %s (класс %s)"

#. R/RMethodUtils.R: gettextf("no definition found for class %s", dQuote(classi))
#: R/RMethodUtils.R:0
msgid "no definition found for class %s"
msgstr "нет определения класса %s"

#. R/refClass.R: gettextf("no definition found for inherited class: %s", paste0("\"",     contains[missingDefs], "\"", collapse = ", "))
#: R/refClass.R:0
msgid "no definition found for inherited class: %s"
msgstr "нет определения для унаследованного класса: %s"

#. R/SClasses.R: gettextf("no definition of %s to use for %s", dQuote(Class),     unique)
#: R/SClasses.R:0
msgid "no definition of %s to use for %s"
msgstr "нет определения %s для использования с %s"

#. R/promptClass.R: gettextf("no definition of class %s found", dQuote(clName))
#: R/promptClass.R:0
msgid "no definition of class %s found"
msgstr "не найдено определение класса %s"

#. R/RClassUtils.R: gettextf("no definition of inheritance from %s to %s, though the relation was implied by the setIs() from %s",     .dQ(what), .dQ(def2@className), .dQ(class))
#: R/RClassUtils.R:0
msgid "no definition of inheritance from %s to %s, though the relation was implied by the setIs() from %s"
msgstr "нет определения наследования от %s к %s, однако подразумевалась зависимость через setIs() от %s"

#. R/RClassUtils.R: gettextf("no definition was found for superclass %s in the specification of class %s",     dQuote(cl), dQuote(name))
#: R/RClassUtils.R:0
msgid "no definition was found for superclass %s in the specification of class %s"
msgstr "в спецификации класса %s нет определения для суперкласса %s"

#. R/Methods.R: gettextf("no environment or package corresponding to argument where=%s",     deparse(where))
#: R/Methods.R:0
msgid "no environment or package corresponding to argument where=%s"
msgstr "нет ни окружениея, ни пакета соответствующего аргументу where=%s"

#. R/Methods.R: gettextf("no existing definition for function %s", sQuote(f))
#: R/Methods.R:0
msgid "no existing definition for function %s"
msgstr "нет существующего определения для функции %s"

#. R/addedFunctions.R: gettextf("no function %s found", sQuote(name))
#: R/addedFunctions.R:0
msgid "no function %s found"
msgstr "не найдено функции %s"

#. R/trace.R: gettextf("no function definition for %s found", sQuote(what))
#: R/trace.R:0
msgid "no function definition for %s found"
msgstr "не найдено определение функции для %s"

#. R/method.skeleton.R: gettextf("no function definition found for %s", sQuote(generic))
#: R/method.skeleton.R:0
msgid "no function definition found for %s"
msgstr "не найдено определение функции для %s"

#. R/Methods.R: gettextf("no generic function %s found", sQuote(f))
#: R/Methods.R:0
msgid "no generic function %s found"
msgstr "не найдено общей функции %s"

#. R/MethodsList.R: gettextf("no generic function found corresponding to %s", sQuote(f))
#: R/MethodsList.R:0
msgid "no generic function found corresponding to %s"
msgstr "нет общей функции, соответствующей %s"

#. R/RMethodUtils.R: gettextf("no generic function found for %s", sQuote(f))
#: R/RMethodUtils.R:0
msgid "no generic function found for %s"
msgstr "не найдено общей функции для %s"

#. R/Methods.R: gettextf("no generic function found for '%s'", f)
#: R/Methods.R:0
msgid "no generic function found for '%s'"
msgstr "не найдено общей функции для '%s'"

#. R/Methods.R: gettextf("no generic version of %s on package %s is allowed;\n   a new generic will be assigned for %s",     sQuote(name), sQuote(package), thisPName)
#: R/Methods.R:0
msgid ""
"no generic version of %s on package %s is allowed;\n"
"   a new generic will be assigned for %s"
msgstr ""
"не разрешена общая версия %s в пакете %s;\n"
"   новая общая функция будет присвоена %s"

#. R/Methods.R: gettextf("no method for %s matches class %s", sQuote("..."),     dQuote(signature))
#: R/Methods.R:0
msgid "no method for %s matches class %s"
msgstr "нет метода для %s, сответствующего классу %s"

#. R/Methods.R: gettextf("no method found for function %s and signature %s",     sQuote(fdef@generic), paste(.dQ(signature), collapse = ", "))
#: R/Methods.R:0
msgid "no method found for function %s and signature %s"
msgstr "не найдено метода для функции %s и идентификатора %s"

#. R/Methods.R: gettextf("no method found for function '%s' and signature %s",     f, paste(signature, collapse = ", "))
#: R/Methods.R:0
msgid "no method found for function '%s' and signature %s"
msgstr "не найдено метода для функции '%s' и идентификатора %s"

#. R/Methods.R: gettextf("no method found for signature %s", paste(signature,     collapse = ", "))
#: R/Methods.R:0
msgid "no method found for signature %s"
msgstr "не найдено метода для идентификатора %s"

#. R/trace.R: gettextf("no method in methods table for %s for signature %s",     sQuote(what), sQuote(signature))
#: R/trace.R:0
msgid "no method in methods table for %s for signature %s"
msgstr "в таблице методов нет метода для %s для подписи %s"

#. R/as.R: gettextf("no method or default for as() replacement of %s with Class=\"%s\"",     dQuote(thisClass), Class)
#: R/as.R:0
msgid "no method or default for as() replacement of %s with Class=\"%s\""
msgstr "нет метода или значения по умолчанию для as() замещения %s на Class=\"%s\""

#. R/as.R: gettextf("no method or default for coercing %s to %s", dQuote(thisClass),     dQuote(Class))
#: R/as.R:0
msgid "no method or default for coercing %s to %s"
msgstr "нет метода или значения по умолчанию для приведения %s к %s"

#. R/RMethodUtils.R: gettextf("no method or default matching the \"...\" arguments in %s",     deparse(sys.call(sys.parent()), nlines = 1))
#: R/RMethodUtils.R:0
msgid "no method or default matching the \"...\" arguments in %s"
msgstr "нет метода или соответствия по умолчанию \"...\" аргументов в %s"

#. R/RMethodUtils.R: gettextf("no methods found for %s; cacheGenericsMetaData() will have no effect",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "no methods found for %s; cacheGenericsMetaData() will have no effect"
msgstr "не найдено методов для %s; cacheGenericsMetaData() не будет иметь эффекта"

#. R/methodsTable.R: gettextf("no methods table for generic %s from package %s in package %s",     sQuote(generic@generic), sQuote(generic@package), sQuote(getPackageName(where)))
#: R/methodsTable.R:0
msgid "no methods table for generic %s from package %s in package %s"
msgstr "не могу найти таблицу методов для общего %s из пакета %s в пакете %s"

#. R/addedFunctions.R: gettextf("no non-generic function %s found", sQuote(name))
#: R/addedFunctions.R:0
msgid "no non-generic function %s found"
msgstr "не найдено не общей функции %s"

#. R/SClasses.R: gettextf("no package name supplied and no class definition found for %s",     dQuote(className))
#: R/SClasses.R:0
msgid "no package name supplied and no class definition found for %s"
msgstr "не дали имя пакета и определение класса для %s"

#. R/RMethodUtils.R: stop("no suitable arguments to dispatch methods in this function")
#: R/RMethodUtils.R:0
msgid "no suitable arguments to dispatch methods in this function"
msgstr "нет подходящих аргументов для методов отправки в данной функции"

#. R/RMethodUtils.R: gettext("non-empty string; got \"\"")
#: R/RMethodUtils.R:0
msgid "non-empty string; got \"\""
msgstr ""

#. R/RMethodUtils.R: gettextf("non-function action: %s", sQuote(fname))
#: R/RMethodUtils.R:0
msgid "non-function action: %s"
msgstr "действие без функции: %s"

#. R/Methods.R: gettextf("non-generic function '%s' given to findMethods()",     f)
#: R/Methods.R:0
msgid "non-generic function '%s' given to findMethods()"
msgstr "не общая функция '%s' отдана findMethods()"

#. R/refClass.R: gettextf("non-local assignment to method names is not allowed\n    %s\n( in method %s for class %s)",     paste(unlist(assigned$globals)[globalsInMethods], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"non-local assignment to method names is not allowed\n"
"    %s\n"
"( in method %s for class %s)"
msgstr ""
"нелокальное назначение имен методов не разрешено\n"
"    %s\n"
"(в методе %s класса %s)"

#. R/refClass.R: gettextf("non-local assignment to non-field names (possibly misspelled?)\n    %s\n( in method %s for class %s)",     paste(unlist(assigned$globals)[globalsNotFields], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"non-local assignment to non-field names (possibly misspelled?)\n"
"    %s\n"
"( in method %s for class %s)"
msgstr ""
"нелокальное назначение не имени поля (опечатка?)\n"
"    %s\n"
"(в методе %s класса %s)"

#. R/trace.R: stop("none of the objects in the source code could be found:  need to attach or specify the package")
#: R/trace.R:0
msgid "none of the objects in the source code could be found:  need to attach or specify the package"
msgstr "не могу найти ни одного объекта исходного кода: нужно приложить или указать пакет"

#. R/refClass.R: gettextf("not a reference class: %s", ClassDef@name)
#: R/refClass.R:0
msgid "not a reference class: %s"
msgstr "не ссылочный класс: %s"

#. R/oldClass.R: stop("not allowed to have test==TRUE and an S4Class definition")
#: R/oldClass.R:0
msgid "not allowed to have test==TRUE and an S4Class definition"
msgstr "не разрешается иметь test==TRUE и S4Class-определение"

#. R/Methods.R: gettext("not both functions!")
#: R/Methods.R:0
msgid "not both functions!"
msgstr "не обе функции!"

#. R/fixPrevious.R: gettextf("object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)",     sQuote(what))
#: R/fixPrevious.R:0
msgid "object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)"
msgstr "объект %s не изменен (кажется, что он не из версии R более ранней, чем 1.8.0)"

#. R/fixPrevious.R: gettextf("object %s not changed (it is not consistent with the current definition of class %s from %s)",     sQuote(what), dQuote(Class), sQuote(ClassDef@package))
#: R/fixPrevious.R:0
msgid "object %s not changed (it is not consistent with the current definition of class %s from %s)"
msgstr "объект %s не изменен (он не совместим с текущим определением класса %s из %s)"

#. R/fixPrevious.R: gettextf("object %s not found", sQuote(what))
#: R/fixPrevious.R:0
msgid "object %s not found"
msgstr "объект %s не найден"

#. R/BasicClasses.R: gettextf("object must be a valid data part for class %s; not true of type %s",     dQuote(cl), dQuote(class(data)))
#: R/BasicClasses.R:0
msgid "object must be a valid data part for class %s; not true of type %s"
msgstr "объект должен быть правильной частью данных для класса %s; это не так у типа %s"

#. R/MethodsList.R: gettextf("object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object",     sQuote(fun@generic), length(sigClasses), length(signature))
#: R/MethodsList.R:0
msgid "object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object"
msgstr "объект для использования в качестве идентификатора метода для функции %s не выглядит правильным идентификатором (вектором одиночного класса имен): там было %d классов имен, но %d элементов в идентификаторе"

#. R/trace.R: gettextf("objects found in multiple packages: using %s and ignoring %s",     sQuote(names(possible[[1L]])), paste(sQuote(names(possible[-1L])),         collapse = ", "))
#: R/trace.R:0
msgid "objects found in multiple packages: using %s and ignoring %s"
msgstr "объекты найдены во многих пакетах: использую %s и пропускаю %s"

#. R/Methods.R: gettextf("only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)",     inherited)
#: R/Methods.R:0
msgid "only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)"
msgstr "только FALSE имеет значение для 'inherited', когда указано 'where' (получен %s)"

#. R/SClasses.R: stop("only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object")
#: R/SClasses.R:0
msgid "only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object"
msgstr "только аргументы 'Class' и 'where' могут быть предоставлены когда аргумент 'representation' является объектом класса 'classRepresentation'"

#. R/SClasses.R: stop("only one data object (unnamed argument to prototype) allowed")
#: R/SClasses.R:0
msgid "only one data object (unnamed argument to prototype) allowed"
msgstr "разрешен только один объект данных (безымянный аргумент для прототипа)"

#. R/Methods.R: gettext("original function is prohibited as a generic function")
#: R/Methods.R:0
msgid "original function is prohibited as a generic function"
msgstr "исходной функции не позволено быть общей"

#. R/trace.R: gettextf("package %s is not attached and no namespace found for it",     sQuote(package))
#: R/trace.R:0
msgid "package %s is not attached and no namespace found for it"
msgstr "пакет %s не присоединен и его пространство имен не найдено"

#. R/Methods.R: gettextf("package slots  differ: %s, %s", .dQ(gpString(f1@package)),     .dQ(gpString(f2@package)))
#: R/Methods.R:0
msgid "package slots  differ: %s, %s"
msgstr "слоты пакетов различаются: %s, %s"

#. R/RClassUtils.R: gettextf("potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)",     dQuote(Class), paste(bad, collapse = ", "))
#: R/RClassUtils.R:0
msgid "potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)"
msgstr "возможный цикл в наследовании класса: %s имеет повторы в суперклассах и подклассах (%s)"

#. R/Methods.R: stop("primitive functions cannot be methods; they must be enclosed in a regular function")
#: R/Methods.R:0
msgid "primitive functions cannot be methods; they must be enclosed in a regular function"
msgstr "элементарные функции не могут быть методами; они должны быть вложены в регулярную функцию"

#. R/RClassUtils.R: warning("prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble.")
#: R/RClassUtils.R:0
msgid "prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble."
msgstr "прототип является списком с именованными элементами (может вызвать неоднозначность):  лучше использовать функцию prototype() чтобы избежать неприятности."

#. R/ClassExtensions.R: gettextf("replacement value must be of class %s, got one of class %s",     dQuote(CLASS), dQuote(class(value)[[1L]]))
#: R/ClassExtensions.R:0
msgid "replacement value must be of class %s, got one of class %s"
msgstr "заменяющее значение должно расширять класс %s, получил %s"

#. R/ClassExtensions.R: gettextf("replacement value must extend class %s, got %s", dQuote(needClass),     dQuote(S3Class[[1L]]))
#: R/ClassExtensions.R:0
msgid "replacement value must extend class %s, got %s"
msgstr "заменяющее значение должно расширять класс %s, получил %s"

#. R/oldClass.R: gettextf("restoring definition of class %s", dQuote(cl))
#: R/oldClass.R:0
msgid "restoring definition of class %s"
msgstr "восстанавливаю определение класса %s"

#. R/trace.R: gettextf("setting a method over the binding of symbol %s in environment/package %s",     sQuote(what), sQuote(getPackageName(where)))
#: R/trace.R:0
msgid "setting a method over the binding of symbol %s in environment/package %s"
msgstr "установка метода через связывание символа %s в окружении/пакете %s"

#. R/Methods.R: gettextf("signatures differ:  (%s), (%s)", paste(f1@signature,     collapse = ", "), paste(f2@signature, collapse = ", "))
#: R/Methods.R:0
msgid "signatures differ:  (%s), (%s)"
msgstr "подписи различаются:  (%s), (%s)"

#. R/RMethodUtils.R: gettextf("single string; got a character vector of length %s",     length(what))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "single string; got a character vector of length %s"
msgstr "простая строка; получен объект класса %s"

#. R/RMethodUtils.R: gettextf("single string; got an object of class %s", dQuote(class(what)[[1L]]))
#: R/RMethodUtils.R:0
msgid "single string; got an object of class %s"
msgstr "простая строка; получен объект класса %s"

#. R/oldClass.R: gettextf("slot %s: class %s should extend class %s", sQuote(what),     dQuote(slots1[[what]]), dQuote(slots2[[what]]))
#: R/oldClass.R:0
msgid "slot %s: class %s should extend class %s"
msgstr "позиция %s: класс %s должен расширить класс %s"

#. R/RMethodUtils.R: gettextf("some actions are missing: %s", paste(actions[!allExists],     collapse = ", "))
#: R/RMethodUtils.R:0
msgid "some actions are missing: %s"
msgstr "некоторые действия пропущены: %s"

#. R/trace.R: gettextf("supplied package, %s, differs from package inferred from source, %s",     sQuote(package), sQuote(envPackage))
#: R/trace.R:0
msgid "supplied package, %s, differs from package inferred from source, %s"
msgstr "предложенный пакет, %s, отличается от пакета, найденного в исходниках, %s"

#. R/methodsTable.R: gettextf("the \"ambiguousMethodSelection\" option should be a function to be called as the condition action; got an object of class %s",     dQuote(class(condAction)))
#: R/methodsTable.R:0
msgid "the \"ambiguousMethodSelection\" option should be a function to be called as the condition action; got an object of class %s"
msgstr "опция \"ambiguousMethodSelection\" должна быть функцией для вызова в качестве условного события; получен объект класса %s"

#. R/RMethodUtils.R: gettextf("the %s argument must be NULL or a generic function object; got an object of class %s",     sQuote("genericFunction"), dQuote(class(genericFunction)))
#: R/RMethodUtils.R:0
msgid "the %s argument must be NULL or a generic function object; got an object of class %s"
msgstr "аргумент %s должен быть NULL или объектом общей функции; получен объект класса %s"

#. R/RClassUtils.R: gettextf("the '%s' list for class %s, includes an undefined class %s",     if (superClassCase) "superClass" else "subClass", dQuote(className),     dQuote(.className(by)))
#: R/RClassUtils.R:0
msgid "the '%s' list for class %s, includes an undefined class %s"
msgstr "список '%s' для класса %s, включает неопределенный класс %s"

#. R/ClassExtensions.R: gettextf("the 'S3Class' argument must be a superclass of %s:  not true of class %s",     dQuote(class(object)), dQuote(S3Class))
#: R/ClassExtensions.R:0
msgid "the 'S3Class' argument must be a superclass of %s:  not true of class %s"
msgstr "аргумент 'S3Class' должен быть суперклассом %s: это не так для класса %s"

#. R/ClassExtensions.R: gettextf("the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s",     dQuote(class(coerce)))
#: R/ClassExtensions.R:0
msgid "the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s"
msgstr "аргумент 'coerce' для 'setIs' должен быть функцией одного аргумента, получен объект класса %s"

#. R/refClass.R: gettextf("the 'contains' argument should be the names of superclasses:  got an element of class %s",     dQuote(class(what)))
#: R/refClass.R:0
msgid "the 'contains' argument should be the names of superclasses:  got an element of class %s"
msgstr "аргумент 'contains' должен быть именами суперклассов: получен элемент класса %s"

#. R/ClassExtensions.R: gettextf("the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s",     dQuote(class(replace)))
#: R/ClassExtensions.R:0
msgid "the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s"
msgstr "аргумент 'replace' для setIs() должен быть функцией 2 или 3 аргументов, а получен объект класса %s"

#. R/Methods.R: gettextf("the 'where' environment (%s) is a locked namespace; cannot assign methods there",     getPackageName(where))
#: R/Methods.R:0
msgid "the 'where' environment (%s) is a locked namespace; cannot assign methods there"
msgstr "окружение 'where' (%s) является заблокированным пространством имен; не могу определить там методы"

#. R/oldClass.R: gettextf("the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")",     .class1(prototype), mainClass)
#: R/oldClass.R:0
msgid "the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")"
msgstr "S3-класс прототипа, \"%s\", не определен; такое разрешается только если это S3-класс в процессе регистрации (\"%s\")"

#. R/RMethodUtils.R: gettextf("the body of the generic function for %s calls 'standardGeneric' to dispatch on a different name (\"%s\")!",     sQuote(fname), paste(as.character(x[[2L]]), collapse = "\n"))
#: R/RMethodUtils.R:0
msgid "the body of the generic function for %s calls 'standardGeneric' to dispatch on a different name (\"%s\")!"
msgstr "тело общей функции для %s вызывает 'standardGeneric' для отправки под другим именем (\"%s\")!"

#. R/refClass.R: gettextf("the class of field %s in the object is not compatible with the desired class %s in the target",     sQuote(field), dQuote(fieldClasses[[field]]))
#: R/refClass.R:0
msgid "the class of field %s in the object is not compatible with the desired class %s in the target"
msgstr "класс или поле %s объекта несовместимо с желаемым классом %s цели"

#. R/ClassExtensions.R: gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n",     TO, dQuote(FROM), TO, dQuote(class(value)))
#: R/ClassExtensions.R:0
msgid "the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)"
msgstr "вычисление: 'as(object,\"%s\") <- value' правильно, когда объект имеет класс %s только если 'is(value, \"%s\")' является TRUE ('class(value)' было %s)"

#. R/refClass.R: gettextf("the definition of class %s in package %s is locked so fields may not be modified",     dQuote(def@className), sQuote(def@package))
#: R/refClass.R:0
msgid "the definition of class %s in package %s is locked so fields may not be modified"
msgstr "определение класса %s в пакете %s заблокировано, так что поля изменить нельзя"

#. R/refClass.R: gettextf("the definition of class %s in package %s is locked, methods may not be redefined",     dQuote(def@className), sQuote(def@package))
#: R/refClass.R:0
msgid "the definition of class %s in package %s is locked, methods may not be redefined"
msgstr "определение класса %s в пакете %s заблокировано, методы нельзя переопределить"

#. R/trace.R: stop("the editing in trace() can only change the body of the function, not the arguments or defaults")
#: R/trace.R:0
msgid "the editing in trace() can only change the body of the function, not the arguments or defaults"
msgstr "редактирование в trace() может менять только тело функции, а не аргументы или значения по умолчанию"

#. R/trace.R: gettextf("the editing in trace() can only change the body of the function; got an object of class %s",     dQuote(class(def2)))
#: R/trace.R:0
msgid "the editing in trace() can only change the body of the function; got an object of class %s"
msgstr "редактирование в trace() может менять только тело функции; получен объект класса %s"

#. R/Methods.R: gettextf("the environment %s is locked; cannot assign methods for function %s",     sQuote(getPackageName(where)), sQuote(f))
#: R/Methods.R:0
msgid "the environment %s is locked; cannot assign methods for function %s"
msgstr "окружение %s заблокировано; не могу назначить методы для функции %s"

#. R/RMethodUtils.R: gettextf("the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed",     what, sQuote(f))
#: R/RMethodUtils.R:0
msgid "the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed"
msgstr "функция, используемая как %s при создании общей функции для %s в данный момент отслеживается; для используемой функции трассировка будет удалена"

#. R/ClassUnion.R: gettextf("the member classes must be defined: not true of %s",     paste(.dQ(as(members[!membersDefined], "character")), collapse = ", "))
#: R/ClassUnion.R:0
msgid "the member classes must be defined: not true of %s"
msgstr "классы-члены класса должны быть определены: не верно для %s"

#. R/trace.R: gettextf("the method for %s for this signature was not being traced",     sQuote(what))
#: R/trace.R:0
msgid "the method for %s for this signature was not being traced"
msgstr "данный метод для %s для данной подписи не может быть отслежен"

#. R/Methods.R: gettextf("the method for function %s and signature %s is sealed and cannot be re-defined",     sQuote(f), .signatureString(fdef, signature))
#: R/Methods.R:0
msgid "the method for function %s and signature %s is sealed and cannot be re-defined"
msgstr "метод для функции %s и подпись %s запечатаны и не могут быть изменены"

#. R/MethodsListClass.R: gettext("the names in signature for method (%s) do not match %s's arguments (%s)",     domain = "R-methods")
#: R/MethodsListClass.R:0
msgid "the names in signature for method (%s) do not match %s's arguments (%s)"
msgstr "имена в идентификаторе для метода (%s) не совпадают с %s аргументами функции (%s)"

#. R/MethodsListClass.R: gettext("the names in signature for method (%s) do not match function's arguments (%s)",     domain = "R-methods")
#: R/MethodsListClass.R:0
msgid "the names in signature for method (%s) do not match function's arguments (%s)"
msgstr "имена в идентификаторе для метода (%s) не совпадают с аргументами функции (%s)"

#. R/refClass.R: gettextf("the overriding class (\"%s\") of field %s is not a subclass of the existing field definition (\"%s\")",     value[[field]], sQuote(field), fieldList[[field]])
#: R/refClass.R:0
msgid "the overriding class (\"%s\") of field %s is not a subclass of the existing field definition (\"%s\")"
msgstr "переписывание class(\"%s\") или поля %s не является подклассом в текущем определении поля (\"%s\")"

#. R/ClassExtensions.R: gettextf("there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error",     to, dQuote(Class))
#: R/ClassExtensions.R:0
msgid "there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error"
msgstr "нет автоматического определения для 'as(объект, \"%s\") <- value', где объект имеет класс %s и аргумент 'replace' не был предоставлен; замена будет ошибкой"

#. R/refClass.R: gettextf("topic %s is not a method name in class %s\nThe class definition follows\n",     sQuote(topic), dQuote(className))
#: R/refClass.R:0
msgid ""
"topic %s is not a method name in class %s\n"
"The class definition follows"
msgstr ""
"топик %s не является именем метода в классе %s\n"
"Определение класса ниже"

#. R/trace.R: gettextf("tracing the internal function %s is not allowed", sQuote(what))
#: R/trace.R:0
msgid "tracing the internal function %s is not allowed"
msgstr "трассировка внутренней функции %s не разрешена"

#. R/RClassUtils.R: gettextf("trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object",     dQuote(class(def)), dQuote(Class))
#: R/RClassUtils.R:0
msgid "trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object"
msgstr "попытка назначить объект класса %s определением класса %s: необходимо предоставить объект \"classRepresentation\""

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s in an object of class %s; expected a function definition",     msg, dQuote(class(def)))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s in an object of class %s; expected a function definition"
msgstr "пытаюсь изменить формальные аргументы в %s, объекте класса %s; ожидалось определение функции"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but getting the new formals from an object of class %s; expected a function definition",     msg, dQuote(class(def)))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but getting the new formals from an object of class %s; expected a function definition"
msgstr "пытаюсь изменить формальные аргументы в %s, но получаю новые формальные аргументы от объекта класса %s; ожидалось определение функции"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but the number of existing arguments is greater than the number of new arguments (the extra arguments won't be used): (%s) vs (%s)",     msg, paste0("\"", old, "\"", collapse = ", "), paste0("\"",         new, "\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but the number of existing arguments is greater than the number of new arguments (the extra arguments won't be used): (%s) vs (%s)"
msgstr "пытаюсь изменить формальные аргументы в %s, но число существующих аргументов больше, чем число новых аргументов (дополнительные аргументы не будут использованы): (%s) против (%s)"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but the number of existing arguments is less than the number of new arguments: (%s) vs (%s)",     msg, paste0("\"", old, "\"", collapse = ", "), paste0("\"",         new, "\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but the number of existing arguments is less than the number of new arguments: (%s) vs (%s)"
msgstr "пытаюсь изменить формальные аргументы в %s, но число существующих аргументов меньше, чем число новых аргументов: (%s) против (%s)"

#. R/methodsTable.R: gettextf("trying to check signature length of generic '%s', but it is not a generic function: i = %d, funs = %s, gnames = %s",     what, i, paste(unlist(funs), collapse = ", "), paste(as.character(gnames),         collapse = ", "))
#: R/methodsTable.R:0
msgid "trying to check signature length of generic '%s', but it is not a generic function: i = %d, funs = %s, gnames = %s"
msgstr "попытка проверить длину подписи общей '%s', но это не общая функция: i = %d, funs = %s, gnames = %s"

#. R/methodsTable.R: gettextf("trying to check signature length of group generic '%s', but it is not a group generic",     what)
#: R/methodsTable.R:0
msgid "trying to check signature length of group generic '%s', but it is not a group generic"
msgstr "пытаюсь проверить длину идентификатора общей группы '%s', но это не общая группа"

#. R/methodsTable.R: stop("trying to find a methods table in a non-generic function")
#: R/methodsTable.R:0
msgid "trying to find a methods table in a non-generic function"
msgstr "пытаюсь найти таблицу методов в не-общей функции"

#. R/MethodsList.R: gettextf("trying to match a method signature of class %s; expects a list or a character vector",     dQuote(class(signature)))
#: R/MethodsList.R:0
msgid "trying to match a method signature of class %s; expects a list or a character vector"
msgstr "попытка подобрать метод идентификатора класса %s; ожидается список или символьный вектор"

#. R/MethodsList.R: gettextf("trying to match a method signature to an object (of class %s) that is not a generic function",     dQuote(class(fun)))
#: R/MethodsList.R:0
msgid "trying to match a method signature to an object (of class %s) that is not a generic function"
msgstr "попытка сопоставить идентификатор метода с объектом (класса %s), который не является общей функцией"

#. R/as.R: gettextf("trying to set an 'as' relation from %s to itself",     dQuote(.class1(from)))
#: R/as.R:0
msgid "trying to set an 'as' relation from %s to itself"
msgstr "пытаюсь установить отношение 'as' от %s на себя"

#. R/ClassUnion.R: gettextf("unable to create union class:  could not set members %s",     paste(.dQ(failed), collapse = ", "))
#: R/ClassUnion.R:0
msgid "unable to create union class:  could not set members %s"
msgstr "не могу создать класс union:  не могу установить членов %s"

#. R/RClassUtils.R: gettextf("unable to find a consistent ordering of superclasses for class %s: order chosen is inconsistent with the superclasses of %s",     .dQ(className), paste(.dQ(setdiff(newconflicts, conflicts)),         collapse = ", "))
#: R/RClassUtils.R:0
msgid "unable to find a consistent ordering of superclasses for class %s: order chosen is inconsistent with the superclasses of %s"
msgstr "не могу найти совместимого порядка суперклассов для класса %s: выбранный порядок несовместим с суперклассами %s"

#. R/RClassUtils.R: gettextf("unable to find an environment containing class %s",     dQuote(Class))
#: R/RClassUtils.R:0
msgid "unable to find an environment containing class %s"
msgstr "не могу найти окружение, содержащее класс %s"

#. R/methodsTable.R: gettextf("unable to find an inherited method for function %s for signature %s",     sQuote(fdef@generic), sQuote(cnames))
#: R/methodsTable.R:0
msgid "unable to find an inherited method for function %s for signature %s"
msgstr "невозможно найти наследованный метод для функции %s для подписи %s"

#. R/RClassUtils.R: gettextf("unable to load required package %s", sQuote(package))
#: R/RClassUtils.R:0
#, fuzzy
msgid "unable to load required package %s"
msgstr "не могу найти требуемый пакет %s"

#. R/as.R: stop("undefined 'coerce' method")
#: R/as.R:0
msgid "undefined 'coerce' method"
msgstr "метод \"coerce' не определен"

#. R/methodsTable.R: gettextf("undefined classes (%s) will be ignored for argument '%s'",     paste0("\"", unique(.undefClasses), "\"", collapse = ", "),     colnames(sigs)[[j]])
#: R/methodsTable.R:0
msgid "undefined classes (%s) will be ignored for argument '%s'"
msgstr "неопределенные классы (%s) будут проигнорированы для аргумента '%s'"

#. R/RClassUtils.R: gettext("undefined slot classes in definition of %s: %s", domain = "R-methods")
#: R/RClassUtils.R:0
msgid "undefined slot classes in definition of %s: %s"
msgstr "неопределенные слотовые классы в определении %s: %s"

#. R/RClassUtils.R: gettextf("undefined subclass %s of class %s; definition not updated",     .dQ(what), .dQ(def@className))
#: R/RClassUtils.R:0
msgid "undefined subclass %s of class %s; definition not updated"
msgstr "неопределенный подкласс %s класса \"%s\"; определение не обновлено"

#. R/zzz.R: message("unloading 'methods' package ...")
#: R/zzz.R:0
msgid "unloading 'methods' package ..."
msgstr "выгружаю пакет 'methods'..."

#. R/BasicClasses.R: gettextf("unnamed argument must extend either the S3 class or the class of the data part; not true of class %s",     dQuote(Classi))
#: R/BasicClasses.R:0
msgid "unnamed argument must extend either the S3 class or the class of the data part; not true of class %s"
msgstr "безымянный аргумент должен расширять либо S3-класс, либо класс части данных; это не так для класса %s"

#. R/BasicClasses.R: gettextf("unnamed argument to initialize() for S3 class must have a class definition; %s does not",     dQuote(Classi))
#: R/BasicClasses.R:0
msgid "unnamed argument to initialize() for S3 class must have a class definition; %s does not"
msgstr "безымянный аргумент в initialize() для S3-класса должен иметь определение класса; а %s -- не имеет"

#. R/BasicClasses.R: stop("unnamed argument to new() must be an environment for the new object")
#: R/BasicClasses.R:0
msgid "unnamed argument to new() must be an environment for the new object"
msgstr "неименованный аргумент у new() должен быть окружением для нового объекта"

#. R/refClass.R: gettextf("unnamed arguments to $new() must be objects from a reference class; got an object of class %s",     dQuote(class(super)))
#: R/refClass.R:0
msgid "unnamed arguments to $new() must be objects from a reference class; got an object of class %s"
msgstr "непоименованные аргументы $new() должны быть объектами ссылочного класса; получен объект класса %s"

#. R/SClasses.R: stop("validity method must be NULL or a function of one argument")
#: R/SClasses.R:0
msgid "validity method must be NULL or a function of one argument"
msgstr "правильный метод должен быть NULL или функцией с одним аргументом"

#. R/Methods.R: gettextf("value classes differ: %s, %s", .dQ(gpString(f1@valueClass)),     .dQ(gpString(f2@valueClass)))
#: R/Methods.R:0
msgid "value classes differ: %s, %s"
msgstr "значения классов различаются: %s, %s"

#. R/methodsTable.R: ngettext(length(candidates), "Choosing method %s from %d ambiguous possibility",     "Choosing method %s from %d ambiguous possibilities")
#: R/methodsTable.R:0
msgid "Choosing method %s from %d ambiguous possibility"
msgid_plural "Choosing method %s from %d ambiguous possibilities"
msgstr[0] "Выбран метод %s из %d сомнительной возможности"
msgstr[1] "Выбран метод %s из %d сомнительных возможностей"
msgstr[2] "Выбран метод %s из %d сомнительных возможностей"

#. R/MethodsListClass.R: ngettext(nreport, "Reported %d ambiguous selection out of %d for function %s\n",     "Reported %d ambiguous selections out of %d for function %s\n")
#: R/MethodsListClass.R:0
msgid "Reported %d ambiguous selection out of %d for function %s\n"
msgid_plural "Reported %d ambiguous selections out of %d for function %s\n"
msgstr[0] "Сообщен %d сомнительный выбор из %d для функции %s\n"
msgstr[1] "Сообщено %d сомнительных выборов из %d для функции %s\n"
msgstr[2] "Сообщено %d сомнительных выборов из %d для функции %s\n"

#. R/methodsTable.R: ngettext(which2, "Selecting %d method of minimum distance", "Selecting %d methods of minimum distance")
#: R/methodsTable.R:0
msgid "Selecting %d method of minimum distance"
msgid_plural "Selecting %d methods of minimum distance"
msgstr[0] "Выбираю %d метод минимальной дистанции"
msgstr[1] "Выбираю %d методов минимальной дистанции"
msgstr[2] "Выбираю %d методов минимальной дистанции"

#. R/methodsTable.R: ngettext(length(which), "Selecting %d non-group method", "Selecting %d non-group methods")
#: R/methodsTable.R:0
msgid "Selecting %d non-group method"
msgid_plural "Selecting %d non-group methods"
msgstr[0] "Выбираю %d негрупповой метод"
msgstr[1] "Выбираю %d негрупповых методов"
msgstr[2] "Выбираю %d негрупповых методов"

#. R/methodsTable.R: ngettext(length(which), "Selecting %d partially exact-matching method",     "Selecting %d partially exact-matching methods")
#: R/methodsTable.R:0
msgid "Selecting %d partially exact-matching method"
msgid_plural "Selecting %d partially exact-matching methods"
msgstr[0] "Выбираю %d частично полностью соответствующих метод"
msgstr[1] "Выбираю %d частично полностью соответствующих методов"
msgstr[2] "Выбираю %d частично полностью соответствующих методов"

#. R/is.R: ngettext(sum(is.na(match(n2, n1))), "class %s is missing slot from class %s (%s), and no coerce method was supplied",     "class %s is missing slots from class %s (%s), and no coerce method was supplied")
#: R/is.R:0
msgid "class %s is missing slot from class %s (%s), and no coerce method was supplied"
msgid_plural "class %s is missing slots from class %s (%s), and no coerce method was supplied"
msgstr[0] "у класса %s отсутствует слот из класса %s (%s), и не предоставлен метод приведения"
msgstr[1] "у класса %s отсутствуют слоты из класса %s (%s), и не предоставлен метод приведения"
msgstr[2] "у класса %s отсутствуют слоты из класса %s (%s), и не предоставлен метод приведения"

#. R/SClasses.R: ngettext(length(dslots), "duplicated slot name: %s", "duplicated slot names: %s")
#: R/SClasses.R:0
msgid "duplicated slot name: %s"
msgid_plural "duplicated slot names: %s"
msgstr[0] "совпадающие имена слота: %s"
msgstr[1] "совпадающие имена слотов: %s"
msgstr[2] "совпадающие имена слотов: %s"

#. R/methodsTable.R: ngettext(length(methods), "found %d equally good next method",     "found %d equally good next methods")
#: R/methodsTable.R:0
msgid "found %d equally good next method"
msgid_plural "found %d equally good next methods"
msgstr[0] "нашел %d такой же хороший следующий метод"
msgstr[1] "нашел %d такие же хорошие следующие методы"
msgstr[2] "нашел %d такие же хорошие следующие методы"

#. R/MethodsList.R: ngettext(sum(is.na(which)), "in the method signature for function %s invalid argument name in the signature: %s",     "in the method signature for function %s invalid argument names in the signature: %s")
#: R/MethodsList.R:0
msgid "in the method signature for function %s invalid argument name in the signature: %s"
msgid_plural "in the method signature for function %s invalid argument names in the signature: %s"
msgstr[0] "в идентификаторе метода для функции %s неверное именя аргумента в идентификаторе: %s"
msgstr[1] "в идентификаторе метода для функции %s неверные имена аргументов в идентификаторе: %s"
msgstr[2] "в идентификаторе метода для функции %s неверные имена аргументов в идентификаторе: %s"

#. R/SClasses.R: ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s",     "invalid names for slots of class %s: %s")
#: R/SClasses.R:0
msgid "invalid name for slot of class %s: %s"
msgid_plural "invalid names for slots of class %s: %s"
msgstr[0] "неверные имена для слотов класса %s: %s"
msgstr[1] "неверные имена для слотов класса %s: %s"
msgstr[2] "неверное имя для слотов класса %s: %s"

#. R/SClasses.R: ngettext(length(pkgs), "multiple definition of class %s visible (%s); using the definition\n   in package %s for %s",     "multiple definitions of class %s visible (%s); using the definition\n   in package %s for %s")
#: R/SClasses.R:0
msgid ""
"multiple definition of class %s visible (%s); using the definition\n"
"   in package %s for %s"
msgid_plural ""
"multiple definitions of class %s visible (%s); using the definition\n"
"   in package %s for %s"
msgstr[0] ""
"найдено несколько видимых определений класса %s (%s); использую определение\n"
"   в пакете %s для %s"
msgstr[1] ""
"найдено несколько видимых определений класса %s (%s); использую определение\n"
"   в пакете %s для %s"
msgstr[2] ""
"найдено несколько видимых определений класса %s (%s); использую определение\n"
"   в пакете %s для %s"

#. R/RClassUtils.R: ngettext(sum(is.na(match(pnames, slots))), "named elements of prototype do not correspond to slot name: %s",     "named elements of prototype do not correspond to slot names: %s")
#: R/RClassUtils.R:0
msgid "named elements of prototype do not correspond to slot name: %s"
msgid_plural "named elements of prototype do not correspond to slot names: %s"
msgstr[0] "именованные элементы прототипа не соответствуют имени слота: %s"
msgstr[1] "именованные элементы прототипа не соответствуют именам слотов: %s"
msgstr[2] "именованные элементы прототипа не соответствуют именам слотов: %s"

#. R/MethodsList.R: ngettext(length(unknown), "no definition for class %s", "no definition for classes %s")
#: R/MethodsList.R:0
msgid "no definition for class %s"
msgid_plural "no definition for classes %s"
msgstr[0] "нет определения класса \"%s\""
msgstr[1] "нет определений классов \"%s\""
msgstr[2] "нет определений классов \"%s\""

#. R/promptClass.R: ngettext(length(whereClass), "no definition of class %s in the specified position, %s, definition on : %s",     "no definition of class %s in the specified position, %s, definitions on : %s")
#: R/promptClass.R:0
msgid "no definition of class %s in the specified position, %s, definition on : %s"
msgid_plural "no definition of class %s in the specified position, %s, definitions on : %s"
msgstr[0] "нет определения класса %s в указанной позиции, %s, определение: %s"
msgstr[1] "нет определения класса %s в указанной позиции, %s, определения: %s"
msgstr[2] "нет определения класса %s в указанной позиции, %s, определения: %s"

#. R/RMethodUtils.R: ngettext(sum(not.s.in.a), "non-argument found in the signature: %s",     "non-arguments found in the signature: %s")
#: R/RMethodUtils.R:0
msgid "non-argument found in the signature: %s"
msgid_plural "non-arguments found in the signature: %s"
msgstr[0] "не найдено аргумента в идентификаторе: %s"
msgstr[1] "не найдено аргументов в идентификаторе: %s"
msgstr[2] "не найдено аргументов в идентификаторе: %s"

#. R/is.R: ngettext(length(bad), "slot in class %s must extend corresponding slot in class %s: fails for %s",     "slots in class %s must extend corresponding slots in class %s: fails for %s")
#: R/is.R:0
msgid "slot in class %s must extend corresponding slot in class %s: fails for %s"
msgid_plural "slots in class %s must extend corresponding slots in class %s: fails for %s"
msgstr[0] "слот в классе %s должен расширить соответствующий слот в классе %s: сбои в %s"
msgstr[1] "слоты в классе %s должны расширить соответствующие слоты в классе %s: сбои в %s"
msgstr[2] "слоты в классе %s должны расширить соответствующие слоты в классе %s: сбои в %s"

#. R/RMethodUtils.R: ngettext(length(fdef), "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)",     "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)")
#: R/RMethodUtils.R:0
msgid "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)"
msgid_plural "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)"
msgstr[0] "формальный аргумент общей функции для \"%s\" (%s) отличается от не-общего, используемого по умолчанию (%s)"
msgstr[1] "формальные аргументы общей функции для \"%s\" (%s) отличаются от не-общих, используемых по умолчанию (%s)"
msgstr[2] "формальные аргументы общей функции для \"%s\" (%s) отличаются от не-общих, используемых по умолчанию (%s)"

#~ msgid "Function must be an S4 generic"
#~ msgstr "Функция должна быть S4 общей"

#~ msgid "E := environment(): %s; parent.env(E): %s"
#~ msgstr "E := environment(): %s; parent.env(E): %s"

#~ msgid "(and methods)"
#~ msgstr "(и методы)"

#~ msgid "invalid method sublist"
#~ msgstr "неверный подсписок методов"

#~ msgid "%f is not a valid generic function: methods list was an object of class %s"
#~ msgstr "%f не является правильной общей функцией: список методов был объектом класса %s"

#~ msgid "%s must be TRUE, FALSE, or a named logical vector of those values; got an object of class %s"
#~ msgstr "%s должен быть TRUE, FALSE, или именованным логическим вектором этих значений; получен объект класса %s"

#~ msgid "skipping methods list element %s of unexpected class %s"
#~ msgstr "пропускаю элемент списка методов %s неожиданного класса %s"

#~ msgid "invalid call in method dispatch to '%s' (no default method)"
#~ msgstr "неверный вызов в методе оправки к '%s' (нет метода по умолчанию)"

#~ msgid "subclass %s of class %s is not local and cannot be updated for new inheritance information; consider setClassUnion()"
#~ msgstr "подкласс %s класса %s не является локальным и не может быть обновлен; рассмотрите setClassUnion()"

#~ msgid "Note: the specification for S3 class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class."
#~ msgstr "Замечание: спецификация класса S3 %s в пакете %s похожа на спецификацию из пакета %s: не превращается в дублированное определение для этого класса."

#~ msgid "methods cannot be defined for the primitive function %s"
#~ msgstr "методы не могут быть определены для элементарной функции %s"

#~ msgid "package %s seems to have out-of-date methods; need to reinstall from source"
#~ msgstr "пакет %s возможно, содержит устаревшие методы; необходимо переустановить его из источника"

#~ msgid "trying to execute load actions without 'methods' package"
#~ msgstr "попытка выполнить команды загрузки без пакета 'methods'"

#~ msgid "special function %s is not permitted to have methods"
#~ msgstr "специальной функции %s не разрешено иметь методов"

#~ msgid "special function %s has no known argument list; will assume '(x, ...)'"
#~ msgstr "специальная функция %s не имеет известного списка аргументов; будет присвоено '(x, ...)'"

#~ msgid "'callGeneric' with a primitive needs explicit arguments (no formal args defined)"
#~ msgstr "'callGeneric' с примитивом нуждается в явных аргументах (не определены формальные аргументы)"

#~ msgid "\""
#~ msgstr "\""

#~ msgid "could not find superclass %s to clean up when removing subclass references to class %s"
#~ msgstr "не могу найти суперкласс %s для очистки при удалении ссылок подкласса на класс %s"

#~ msgid "no class %s found as expected in removing subclass %s"
#~ msgstr "не найдено класса %s, ожидаемого при удалении подкласса %s"

#~ msgid "replacement value is not a matrix"
#~ msgstr "замещающее значение не является матрицей"

#~ msgid "field %s is read-only"
#~ msgstr "поле %s только для чтения"

#~ msgid "not a package name: %s"
#~ msgstr "не является именем пакета: %s"

#~ msgid "a list argument for 'fields' must have nonempty names for all the fields"
#~ msgstr "Список аргументов для полей должен иметь непустые имена во всех полях"

#~ msgid "argument 'fields' must be a list of the field classes or definitions or the names of the fields; got an object of class %s"
#~ msgstr "Поля аргумента должны быть списком классов поля или определений, или просто именами полей, а был получен объект класса %s"

#~ msgid "Warning:  using defunct methods list search"
#~ msgstr "Предупреждение: использую нерабочие методы поиска в списке"

#~ msgid "apparent inconsistency in the methods for function %s; argument %s in the signature corresponds to %s in the methods list object"
#~ msgstr "очевидная противоречивость в методах функции %s; аргумент %s в идентификаторе соответствует %s в объекте списка методов."

#~ msgid "no S4 method for function %s and signature %s; consider getS3method() if you wanted the S3 method"
#~ msgstr "нет S4 метода для функции %s и идентификатора %s; обратите внимание на getS3method() если ходите использовать S3 метод"

#~ msgid "no method defined in methods list object for function %s and signature %s"
#~ msgstr "не определено метода для функции %s и идентификатора %s"

#~ msgid "multiple equivalent inherited matches:"
#~ msgstr "множественные эквивалентные унаследованные соответствия:"

#~ msgid "; using the first of these"
#~ msgstr "; использую первый из них"

#~ msgid "'traceOn' is deprecated: use the function 'trace' in the 'methods' package instead"
#~ msgstr "'traceOn' не рекомендуется к использованию: вместо этого используйте функцию 'trace' в пакете 'methods'"

#~ msgid "'traceOff' is deprecated: use the function 'untrace' in the 'methods' package instead"
#~ msgstr "'traceOff' не рекомендуется к использованию: вместо этого используйте функцию 'untrace' из пакета 'methods'"

#~ msgid "The class of field %s in the object is not compatible with the desired class %s in the target"
#~ msgstr "Класс или поле \"%s\" объекта несовместимо с желаемым классом %s цели"

#~ msgid "in .OldClassesPrototypes"
#~ msgstr "в .OldClassesPrototypes"

#~ msgid "internal error: did not get a valid generic function object for function %s"
#~ msgstr "внутренняя ошибка: не получен верный объект общей функции для функции %s"

#~ msgid "apparent internal error: a generic function was found for \"%s\", but no corresponding object was found searching from \"%s\""
#~ msgstr "очевидная внутренняя ошибка: для \"%s\" была найдена общая функция, но поиском по \"%s\" не было найдено соответствующего объекта"

#~ msgid "selectMethod(): mlist is not an environment or NULL :"
#~ msgstr "selectMethod(): mlist не является окружением или NULL :"

#~ msgid "** should no longer happen!"
#~ msgstr "** больше не должно случаться!"

#~ msgid "Classes: %s, %s"
#~ msgstr "Классы: %s, %s"

#~ msgid "internal error: Bad methods list object in fixing methods for primitive function %s"
#~ msgstr "внутренняя ошибка: Плохой объект списка методов в фиксированных методах для элементарной функции %s"

#~ msgid "botched namespace: failed to find 'base' namespace in its parents"
#~ msgstr "поврежденное пространство имен: не могу найти пространство имен 'base' в его родителе"

#~ msgid "multiple direct matches:"
#~ msgstr "множественные прямые соответствия:"

#~ msgid "Internal error: definition of class %s not properly assigned"
#~ msgstr "Внутренняя ошибка: определение класса \"%s\" не присвоено как следует"

#~ msgid "internal problem in as(): %s is(object, \"%s\") is TRUE, but the metadata asserts that the 'is' relation is FALSE"
#~ msgstr "внутренняя проблема в as(): \"%s\" is(объект, \"%s\") является TRUE, но метаданные утверждают, что 'is' зависимость является FALSE"

#~ msgid "connection"
#~ msgstr "соединение"

#~ msgid "Internal error in finding inherited methods; didn't return a unique method"
#~ msgstr "Внутренняя ошибка при поиске наследованных методов; не возвращен уникальный метод"

#~ msgid "\", but it is not a group generic"
#~ msgstr "\", но не является групповой общей"

#~ msgid "Trying to check signature length of generic \""
#~ msgstr "Пытаюсь проверить длину идентификатора общей \""

#~ msgid "\", but it is not a  generic function: i ="
#~ msgstr "\", но не является  общей функцией: i ="

#~ msgid ", funs ="
#~ msgstr ", funs ="

#~ msgid ","
#~ msgstr ","

#~ msgid "; gnames ="
#~ msgstr "; gnames ="

#~ msgid "Something weird:  inconsistent number of args in methods table strings:"
#~ msgstr "Что-то не так: несоответствующее количество аргументов в строках таблицы методов:"

#~ msgid "(using the largest value)"
#~ msgstr "(использую наибольшее значение)"

#~ msgid "Undefined classes ("
#~ msgstr "Неопределенные классы ("

#~ msgid "Method %s from class %s was not processed into a class method until being installed.  Possible corruption of the methods in the class."
#~ msgstr "Метод %s из класса %s не был преобразован в метод класса, покуда не был установлен. Возможно повреждение методов в классе."

#~ msgid ".TraceWithMethods: after computing what, whereF"
#~ msgstr ".TraceWithMethods: после расчета, что, whereF"

#~ msgid ".TraceWithMethods: untrace case"
#~ msgstr ".TraceWithMethods: не трассируемый случай"

#~ msgid ".TraceWithMethods: about to assign or setMethod"
#~ msgstr ".TraceWithMethods: готово к присвоению либо к setMethod"

#~ msgid "Constructing traceable class %s"
#~ msgstr "Конструирование отслеживаемого класса %s"

#~ msgid "Pretend we inserted class"
#~ msgstr "Предположим, мы вставили класс"

#~ msgid "= \"missing\""
#~ msgstr "= \"отсутствует\""

#~ msgid "found"
#~ msgstr "найдено"

#~ msgid "Invalid mlist element for signature \""
#~ msgstr "Неверный mlist элемент для идентификатора \""

#~ msgid "\" at level"
#~ msgstr "\" на уровне"

#~ msgid "\")"
#~ msgstr "\")"

#~ msgid "Invalid object in methods table (\""
#~ msgstr "неверный объект в таблице методов (\""

#~ msgid "\"), expected a method, got an object of class \""
#~ msgstr "\"), ожидался метод, получен объект класса \""

#~ msgid "Environment of class \""
#~ msgstr "Окружение класса \""

#~ msgid "Replacement value must be of class \""
#~ msgstr "Замещающее значение должно быть класса \""

#~ msgid "\", got one of class \""
#~ msgstr "\", получил класса \""

#~ msgid "\", for signature"
#~ msgstr "\", для идентификатора"

#~ msgid "Field \""
#~ msgstr "Поле \""

#~ msgid "the supplied generic function definition for"
#~ msgstr "указанное определение общей функции для"

#~ msgid "does not seem to call 'standardGeneric'; no methods will be dispatched!"
#~ msgstr "похоже, не вызвано 'standardGeneric'; методы не будут переданы!"

#~ msgid "no generic function \"'%s\" found"
#~ msgstr "Не найдено общей функции \"'%s\""

#~ msgid ""
#~ "Restoring the implicit generic function for %s from package %s\n"
#~ "    into package %s; the generic differs from the default conversion (%s)"
#~ msgstr ""
#~ "Восстановление имплицитной общей функции для %s из пакета %s\n"
#~ "    в пакет %s; общие различаются после конверсии по умолчанию (%s)"

#~ msgid ""
#~ "Creating a generic for %s in package %s\n"
#~ "    (the supplied definition differs from and overrides the implicit generic\n"
#~ "    in package %s: %s)"
#~ msgstr ""
#~ "Создание общего для %s в пакете %\n"
#~ "    (предложенное определение отличается от и переписывает имплицитное общее\n"
#~ "    в пакете %s: %s)"

#~ msgid "\" is not a known action (warn, stop, once, ignore); no action recorded for function \""
#~ msgstr "\" не относится к известным акциям (warn, stop, once, ignore); акция для функции не записана \""

#~ msgid "must give named list of refdefined fields"
#~ msgstr "надо дать список переопределенных полей"

#~ msgid "Only accessor fields can be replaced:  field \"%s\" has class \"%s\""
#~ msgstr "Только сопроводительные поля могут быть заменены:  поле \"%s\" имеет класс \"%s\""

#~ msgid ")"
#~ msgstr ")"

#~ msgid "\"%s\" is not a known reference class"
#~ msgstr "\"%s\" не является ссылочным классом"

#~ msgid "Defining type \"%s\" as a superclass via class \"%s\""
#~ msgstr "Определяю тип \"%s\" как суперкласс через класс \"%s\""

#~ msgid "invalid argument 'f', expected a function or its name, got an object of class %s"
#~ msgstr "неверный аргумент \"f\", ожидается функция или ее имя, получен объект класса \"%s\""

#~ msgid "in the method signature for function \"%s\" no definition for class: %s"
#~ msgid_plural "in the method signature for function \"%s\" no definition for classes: %s"
#~ msgstr[0] "в идентификаторе метода для функции \"%s\" нет определения для класса: %s"
#~ msgstr[1] "в идентификаторе метода для функции \"%s\" нет определения для классов: %s"
#~ msgstr[2] "в идентификаторе метода для функции \"%s\" нет определения для классов: %s"

#~ msgid "None of the orderings of the superclasses of class \"%s\" is consistent with the superclass ordering of  its direct superclasses; using an ordering which conflicts with %s"
#~ msgstr "Ни одно из упорядочений суперклассов класса \"%s\" не соответствует упорядочиванию суперкласса его прямых суперклассов; использую упорядочивание, которое конфликтует с %s"

#~ msgid "Some of the superclasses in the definition of class \""
#~ msgstr "Некоторые суперклассы в определении класса \""

#~ msgid ""
#~ "S3 methods written for S4 classes will fail inheritance!\n"
#~ "Package"
#~ msgstr ""
#~ "S3 методы, написанные для S4 классов, не смогут наследоваться!\n"
#~ "Пакет"

#~ msgid "apparently has"
#~ msgstr "очевидно имеет"

#~ msgid "such methods  for the functions"
#~ msgstr "такие методы для функций"

#~ msgid "Possible dangerous methods:"
#~ msgstr "Возможные опасные методы:"

#~ msgid "(Warnings generated once per package per session)"
#~ msgstr "(Предупреждения выдаются одно на пакет на сессию)"

#~ msgid "There are apparent S3 methods for class \""
#~ msgstr "Есть очевидные S3 методы для класса \""

#~ msgid ""
#~ "\"\n"
#~ "DANGER: any subclasses of this class will not inherit the methods"
#~ msgstr ""
#~ "\"\n"
#~ "ОПАСНО: любой субкласс этого класса не будет наследовать методы"

#~ msgid ""
#~ "\" have apparent S3 methods.\n"
#~ "\n"
#~ "DANGER: the new class will not inherit these methods.\n"
#~ "Complain to the author of the superclass definitions."
#~ msgstr ""
#~ "\" имеет очевидные S3 методы.\n"
#~ "\n"
#~ "ОПАСНО: новый класс на будет наследовать эти методы.\n"
#~ "Пожалуйтесь автору определений суперкласса."

#~ msgid "signature must be a vector of classes or an environment"
#~ msgstr "идентификатор должен быть вектором классов или окружением"

#~ msgid "selectMethod(): .SelectMethodOn - old stuff - please report"
#~ msgstr "selectMethod(): .SelectMethodOn - это старье - пожалуйста, сообщите"

#~ msgid "no unique method corresponding to this signature"
#~ msgstr "не существует единственного метода соответствующего данному идентификатору"

#~ msgid "unable to match signature to methods"
#~ msgstr "невозможно сопоставить идентификатор к методам"

#~ msgid "class \"%s\" cannot be used as the data part of another class"
#~ msgstr "класс \"%s\" не может быть использован как часть данных другого класса"

#~ msgid "internal error: bad code for 'setPrimitiveMethods': %s"
#~ msgstr "внутренняя ошибка: плохой код для 'setPrimitiveMethods': %s"

#~ msgid "Ambiguous method selection for \"%s\", target \"%s\""
#~ msgstr "Неочевидный выбор метода для \"%s\", цель \"%s\""

#~ msgid ""
#~ "(the first of the signatures shown will be used)\n"
#~ "%s"
#~ msgstr ""
#~ "(будет использован первый из показанных идентификаторов)\n"
#~ "%s"

#~ msgid "Couldn't find methods table for \"%s\", package \"%s\" may be out of date"
#~ msgstr "Не могу найти таблицу методов для \"%s\", пакет \"%s\" может быть устаревшим"

#~ msgid "The class to be removed  (\""
#~ msgstr "Данный класс будет удален  (\""

#~ msgid "\") has defined subclasses that should also be removed: ("
#~ msgstr "\") содержит определенные подклассы, которые должны быть удалены: ("

#~ msgid "'NextMethod' not defined because the current method is not a 'MethodDefinition' object"
#~ msgstr "'NextMethod' не определен, потому-что текущий метод не является объектом 'MethodDefinition'"

#~ msgid "expected a list of signature objects, got \"%s\""
#~ msgstr "ожидался список идентификаторов, получен \"%s\""

#~ msgid "New generic for \"%s\" does not agree with implicit generic from package \"%s\"; a new generic will be assigned with package \"%s\""
#~ msgstr "Новая общая функция для \"%s\" не согласуется с подразумеваемой общей функцией из пакета \"%s\"; новая общая функция будет присвоена пакету \"%s\""

#~ msgid "Function \"%s\" may not be used as a generic (implicitly prohibited)"
#~ msgstr "Функция \"%s\" не может быть использована в качестве общей (запрещается безоговорочно)"

#~ msgid "Implicit generic exists for \"%s\", but will be overriden by explicit call to setGeneric()"
#~ msgstr "Подразумеваемая общая функция для \"%s\" существует, но будет переписана четким вызовом setGeneric()"

#~ msgid "Unable to find package environment for class \"%s\" to revise subclass information"
#~ msgstr "Не могу найти окружение пакета для класса \"%s\" для пересмотра информации подкласса"

#~ msgid "No generic function found for \"%s\"; no action taken in removeMethodsObject"
#~ msgstr "Не найдено общей функции для \"%s\"; не предпринято никаких действий в removeMethodsObject"

#~ msgid "the environment/package \"%s\" is locked; cannot remove methods data for \"%s\""
#~ msgstr "окружение/пакет \"%s\" заблокировано; не могу удалить данные методов для \"%s\""

#~ msgid "the methods object name for \"%s\" must include the name of the package that contains the generic function, but no generic function of this name was found"
#~ msgstr "имя объекта методов для \"%s\" должно включать имя пакета, содержащего общую функцию, но общей функции с таким именем не найдено"

#~ msgid "no way to associate a generic function with an object of class \"%s\""
#~ msgstr "нет способа ассоциировать общую функцию с объектом класса \"%s\""

#~ msgid "Could not find generic function \"%s\" to initialize cached methods"
#~ msgstr "Не могу найти общую функцию \"%s\" для инициализации кэшированных методов"

#~ msgid "trying to change the argument list of %s with %d arguments to have arguments (%s)"
#~ msgstr "пытаюсь изменить список аргументов %s с %d аргументами чтобы иметь аргументы (%s)"

#~ msgid "get rid of variables in definition %s (%s); they conflict with the needed change to argument names (%s)"
#~ msgstr "избавляюсь от переменных в определении %s (%s); они конфликтуют с необходимым изменением в именах аргумента (%s)"

#~ msgid "arguments in definition %s changed from (%s) to (%s)"
#~ msgstr "аргументы в определении %s изменены с (%s) на (%s)"

#~ msgid "no methods found for generic \"%s\""
#~ msgstr "не найдено методов для общей функции \"%s\""

#~ msgid "\"%s\" is not one of the basic functions"
#~ msgstr "\"%s\" не является одной из основных функций"

#~ msgid "cannot reset \"%s\", the definition is not a generic function object"
#~ msgstr "не могу сбросить \"%s\", определение не является объектом общей функции"

#~ msgid "No nongeneric version of function \"%s\" exists to be restored"
#~ msgstr "Не обнаружено не общей версии функции \"%s\" для того чтобы ее восстановить"

#~ msgid "\"%s\" from \"%s\" is a non-generic function; no methods available"
#~ msgstr "\"%s\" из \"%s\" не является общей функции; нет доступных методов"

#~ msgid "invalid 'fdef' for \"%s\" in 'getAllMethods'; expected either a 'genericFunction object' or a primitive function, got an object of class \"%s\""
#~ msgstr "неверный 'fdef' для \"%s\" в 'getAllMethods'; ожидалась либо 'genericFunction object' либо элементарная функция, получен объект класса \"%s\""

#~ msgid "Methods list for generic \""
#~ msgstr "Список методов для общей \""

#~ msgid "\" not found"
#~ msgstr "\" не найдено"

#~ msgid ".UsingMethodsTables: 'onOff' is not TRUE or FALSE"
#~ msgstr ".UsingMethodsTables: 'onOff' не является TRUE либо FALSE"

#~ msgid "Package \"%s\" is not loaded"
#~ msgstr "Пакет \"%s\" не загружен"
