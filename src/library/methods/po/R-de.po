# Translation of src/library/methods/po/R-methods.pot to German
# Copyright (C) 2005-2022 The R Foundation
# This file is distributed under the same license as the R package.
# Detlef Steuer <steuer@hsu-hh.de>, 2007-2022.
msgid ""
msgstr ""
"Project-Id-Version: R-4.2.0\n"
"Report-Msgid-Bugs-To: bugs.r-project.org\n"
"POT-Creation-Date: 2024-10-05 20:06\n"
"PO-Revision-Date: 2024-03-19 12:53+0000\n"
"Last-Translator: Michael Chirico <michaelchirico4@gmail.com>\n"
"Language-Team: R-core <R-core@r-project.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.16.4\n"

#. R/RMethodUtils.R: warning("\"MethodsList\" is defunct; allMethods now are empty")
#: R/RMethodUtils.R:0
msgid "\"MethodsList\" is defunct; allMethods now are empty"
msgstr "\"MethodsList\" exisitiert nicht mehr; allMethods sind jetzt leer"

#. R/RClassUtils.R: stop("\"class\" is a reserved slot name and cannot be redefined")
#: R/RClassUtils.R:0
msgid "\"class\" is a reserved slot name and cannot be redefined"
msgstr "\"class\" ist ein reservierter Slotname und kann nicht umdefiniert werden"

#. R/MethodsListClass.R: gettextf("%d: target \"%s\": chose \"%s\" (others: %s)", i, target[[i]],     selected[[i]], paste0("\"", these, "\"", collapse = ", "))
#: R/MethodsListClass.R:0
msgid "%d: target \"%s\": chose \"%s\" (others: %s)"
msgstr "%d: Ziel \"%s\": gewählt \"%s\" (andere: %s)"

#. R/RMethodUtils.R: gettextf("%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list",     .renderSignature(generic@generic, signature), paste(sQuote(trailingArgs),         collapse = ", "), sQuote("..."))
#: R/RMethodUtils.R:0
msgid "%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list"
msgstr "%s Argumente (%s) nach '%s' in der Generischen müssen in der Methode an derselben Stelle am Ende der Argumentliste auftreten"

#. R/Methods.R: gettextf("%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed.",     sQuote(name))
#: R/Methods.R:0
msgid "%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed."
msgstr "\"%s\" dispatched intern; es können Methoden definiert werden, die generische Funktion ist jedoch implizit und kann nicht geändert werden"

#. R/SClasses.R: gettextf("%s has a sealed class definition and cannot be redefined",     dQuote(Class))
#: R/SClasses.R:0
msgid "%s has a sealed class definition and cannot be redefined"
msgstr "%s besitzt eine versiegelte Klassendefinition und kann nicht umdefiniert werden"

#. R/Methods.R: gettextf("%s has no methods defined", sQuote(f))
#: R/Methods.R:0
msgid "%s has no methods defined"
msgstr "%s hat keine Methoden definiert"

#. R/Methods.R: gettextf("%s is a primitive function; its generic form cannot be redefined",     sQuote(name))
#: R/Methods.R:0
msgid "%s is a primitive function; its generic form cannot be redefined"
msgstr "%s ist eine primitive Funktion, ihre generische Form kann nicht umdefiniert werden"

#. R/SClasses.R: gettextf("%s is not a defined class", dQuote(Class))
#: R/SClasses.R:0
msgid "%s is not a defined class"
msgstr "%s ist keine definierte Klasse"

#. R/refClass.R: gettextf("%s is not a defined class in this environment", dQuote(Class))
#: R/refClass.R:0
msgid "%s is not a defined class in this environment"
msgstr "Klasse %s ist in dieser Umgebung nicht definiert"

#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(field), dQuote(thisClass@className))
#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(what), dQuote(def@className))
#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(what), dQuote(className))
#: R/refClass.R:0
msgid "%s is not a field in class %s"
msgstr "%s ist kein Feld in Klasse %s"

#. R/refClass.R: gettextf("%s is not a field in this class", sQuote(name))
#: R/refClass.R:0
msgid "%s is not a field in this class"
msgstr "%s ist kein Feld dieser Klasse"

#. R/RMethodUtils.R: gettextf("%s is not a generic function (or not visible here)",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "%s is not a generic function (or not visible here)"
msgstr "%s ist keine generische Funktion (oder hier nicht sichtbar)"

#. R/trace.R: gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)),     dQuote(class(where)))
#: R/trace.R:0
msgid "%s is not a method for reference class %s"
msgstr "%s ist keine Methode für die Referenzklasse %s"

#. R/refClass.R: gettextf("%s is not a reference class", dQuote(Class))
#. R/refClass.R: gettextf("%s is not a reference class", dQuote(def@className))
#: R/refClass.R:0
msgid "%s is not a reference class"
msgstr "%s ist keine Referenzklasse"

#. R/SClasses.R: gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl))
#. R/SClasses.R: gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl))
#: R/SClasses.R:0
msgid "%s is not a slot in class %s"
msgstr "%s ist kein Slot in Klasse %s"

#. R/refClass.R: gettextf("%s is not a valid field or method name for reference class %s",     sQuote(field), dQuote(thisClass@className))
#: R/refClass.R:0
msgid "%s is not a valid field or method name for reference class %s"
msgstr "Feld %s ist kein gültiges Feld und kein Methodenname für die Referenzklasse %s"

#. R/refClass.R: gettextf("%s is not a valid field or method name for this class",     sQuote(what))
#: R/refClass.R:0
msgid "%s is not a valid field or method name for this class"
msgstr "%s ist keine gültiges Feld und kein Methodenname für diese Klasse"

#. R/Methods.R: gettextf("%s is not an S4 generic function in %s; methods not removed",     sQuote(f), sQuote(getPackageName(where)))
#: R/Methods.R:0
msgid "%s is not an S4 generic function in %s; methods not removed"
msgstr "%s ist keine generische S4 Funktion in %s; Methoden nicht entfernt"

#. R/Methods.R: gettextf("%s is not currently a generic:  define it first to create a non-default implicit form",     sQuote(name))
#: R/Methods.R:0
msgid "%s is not currently a generic:  define it first to create a non-default implicit form"
msgstr "%s ist momentan nicht generisch; definiere sie zuerst, um eine nicht-standard implizite Form zu erzeugen"

#. R/RClassUtils.R: gettextf("%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)",     dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)"
msgstr "%s kann nicht der Datenteil einer anderen Klasse sein (muss eine Grundklasse oder eine virtuelle Klasse ohne Slots sein)"

#. R/addedFunctions.R: gettextf("%s is not one of the element names", sQuote(name))
#: R/addedFunctions.R:0
msgid "%s is not one of the element names"
msgstr "%s ist kein Elementname"

#. R/refClass.R: gettextf("%s is not one of the reference super classes for this object",     dQuote(Class))
#: R/refClass.R:0
msgid "%s is not one of the reference super classes for this object"
msgstr "%s ist keine der Referenzsuperklassen für dieses Objekt"

#. R/trace.R: gettextf("%s() is not a generic function in the target environment -- methods will not be inserted",     f)
#: R/trace.R:0
msgid "%s() is not a generic function in the target environment -- methods will not be inserted"
msgstr "%s() ist keine generische Funktion in der Zielumgebung -- Methoden werden nicht eingefügt"

#. R/MethodsList.R: gettextf("%s, along with other use of the \"MethodsList\" metadata objects, is defunct.",     dQuote(this))
#: R/MethodsList.R:0
msgid "%s, along with other use of the \"MethodsList\" metadata objects, is defunct."
msgstr ""
"%s ist, zusammen mit der Nutzung der \"MethodsList\" Metadatenobjekte,\n"
" nicht mehr vorhanden."

#. R/MethodsList.R: gettextf("%s, along with other use of the \"MethodsList\" metadata objects, is deprecated.",     dQuote(this))
#: R/MethodsList.R:0
msgid "%s, along with other use of the \"MethodsList\" metadata objects, is deprecated."
msgstr "%s ist, zusammen mit der Nutzung der \"MethodsList\" Metadatenobjekte, veraltet."

#. R/Methods.R: gettextf("'%s' is not a known generic function {and 'package' not specified}",     f)
#: R/Methods.R:0
msgid "'%s' is not a known generic function {and 'package' not specified}"
msgstr "'%s' ist keine bekannte generische Funktion {und 'package' nicht angegeben}"

#. R/RClassUtils.R: stop("'Class' must be a valid class definition or class")
#: R/RClassUtils.R:0
msgid "'Class' must be a valid class definition or class"
msgstr "'Class' muss  eine gültige Klassendefinition oder eine Klasse sein"

#. R/oldClass.R: gettextf("'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s",     dQuote(class(object)))
#: R/oldClass.R:0
msgid "'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s"
msgstr "'S3Class' kann nur S4 Objekten zugewiesen werden, die \"oldClass\" erweitern; gilt nicht für Klasse %s"

#. R/oldClass.R: gettextf("'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s",     dQuote("oldClass"), dQuote(class(object)))
#: R/oldClass.R:0
msgid "'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s"
msgstr "'S3Class' ist nur definiert für Erweiterungen von %s oder Klassen mit Datenteil: gilt nicht für Klasse %s\""

#. R/as.R: gettextf("'as' method should have one argument, or match the arguments of coerce(): got  (%s)",     paste(formalArgs(def), collapse = ", "))
#: R/as.R:0
msgid "'as' method should have one argument, or match the arguments of coerce(): got  (%s)"
msgstr "'as' Methode sollte ein Argument haben oder mit coerce() übereinstimmen:  bekam (%s)"

#. R/is.R: stop("'class1' must be the name of a class or a class definition")
#: R/is.R:0
msgid "'class1' must be the name of a class or a class definition"
msgstr "'class1' muss der Name einer Klasse oder eine Klassendefinition sein"

#. R/is.R: stop("'class2' must be the name of a class or a class definition")
#: R/is.R:0
msgid "'class2' must be the name of a class or a class definition"
msgstr "'class2' muss der Name einer Klasse oder eine Klassendefinition sein"

#. R/RClassUtils.R: stop("'externalptr' objects cannot be initialized from new()")
#: R/RClassUtils.R:0
msgid "'externalptr' objects cannot be initialized from new()"
msgstr "'externalptr'-Objekte können nicht aus new() initialisiert werden"

#. R/Methods.R: stop("'file' must be a character string or a connection")
#. R/Methods.R: stop("'file' must be a character string or a connection")
#: R/Methods.R:0
msgid "'file' must be a character string or a connection"
msgstr "'file' muss eine Zeichenkette oder eine Verbindung sein"

#. R/MethodsListClass.R: gettextf("'initialize' method returned an object of class %s instead of the required class %s",     paste(dQuote(class(value)), collapse = ", "), dQuote(class(.Object)))
#: R/MethodsListClass.R:0
msgid "'initialize' method returned an object of class %s instead of the required class %s"
msgstr "'initialize'-Methode gibt ein Objekt der Klasse %s zurück anstelle der verlangten Klasse %s"

#. R/RClassUtils.R: gettextf("(class %s)", .dQ(unlist(properties, recursive = FALSE)[undefClasses]))
#: R/RClassUtils.R:0
msgid "(class %s)"
msgstr "(Klasse %s)"

#. R/RMethodUtils.R: message("--- caching class ", sQuote(cl))
#: R/RMethodUtils.R:0
msgid "--- caching class"
msgstr "--- cache Klasse"

#. R/RMethodUtils.R: gettextf("--- done caching class %s", sQuote(cl))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "--- done caching class %s"
msgstr "--- Cachen der Klasse abgeschlossen"

#. R/RMethodUtils.R: message("--- done getting generic ", sQuote(f))
#: R/RMethodUtils.R:0
msgid "--- done getting generic"
msgstr "--- holen der Generischen abgeschlossen"

#. R/RMethodUtils.R: gettextf("--- getting generic %s (and methods)", sQuote(f))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "--- getting generic %s (and methods)"
msgstr "--- hole Generische"

#. R/SClasses.R: gettextf("All %s names must be distinct in:\n(%s)", what, paste(sQuote(propNames),     collapse = ", "))
#: R/SClasses.R:0
msgid ""
"All %s names must be distinct in:\n"
"(%s)"
msgstr ""
"Alle %s Namen müssen unterschiedlich sein in:\n"
"(%s)"

#. R/SClasses.R: gettextf("All %s names must be nonempty in:\n(%s)", what, paste(sQuote(propNames),     collapse = ", "))
#: R/SClasses.R:0
msgid ""
"All %s names must be nonempty in:\n"
"(%s)"
msgstr ""
"Alle %s Namen müssen nicht-leer sein in:\n"
"(%s)"

#. R/RClassUtils.R: message("Also defined by ", paste(sQuote(pkgs[-1]), collapse = " "))
#: R/RClassUtils.R:0
msgid "Also defined by"
msgstr "Auch definiert durch"

#. R/show.R: gettextf("An object of class %s", dQuote(class(object)))
#: R/show.R:0
msgid "An object of class %s"
msgstr "Ein Objekt der Klasse %s"

#. R/SClasses.R: stop("Argument \"representation\" cannot be used if argument \"slots\" is supplied")
#: R/SClasses.R:0
msgid "Argument \"representation\" cannot be used if argument \"slots\" is supplied"
msgstr "Argument \"representation\" kann nicht benutzt werden, wenn Argument \"slot\" angegeben wird"

#. R/refClass.R: gettextf("Class %s is not a subclass of %s; functional semantics not defined for this class",     dQuote(class(object)), dQuote("envRefClass"))
#: R/refClass.R:0
msgid "Class %s is not a subclass of %s; functional semantics not defined for this class"
msgstr "Klasse %s ist keine Subklasse von %s: funktionale Semantik nicht definiert für diese Klasse"

#. R/Methods.R: gettextf("Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)",     sQuote(f), sQuote(getPackageName(where)), sQuote(getPackageName(gwhere)))
#: R/Methods.R:0
msgid "Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)"
msgstr "kopiere die generische Funktion %s in die Umgebung %s, da die vorhergehende Version in einem versiegelten Namensraum (%s) war"

#. R/refClass.R: stop("Could not find local object in supplied environment")
#: R/refClass.R:0
msgid "Could not find local object in supplied environment"
msgstr "konnte lokales Objekt in angegebener Umgebung nicht finden"

#. R/packageName.R: gettextf("Created a package name, %s, when none found", sQuote(pkg))
#: R/packageName.R:0
msgid "Created a package name, %s, when none found"
msgstr "Habe Paketnamen erzeugt, %s, wenn keinen gefunden"

#. R/Methods.R: gettextf("Creating a generic function for %s from %s in %s\n    (from the saved implicit definition)",     sQuote(name), sQuote(package), thisPName)
#: R/Methods.R:0
msgid ""
"Creating a generic function for %s from %s in %s\n"
"    (from the saved implicit definition)"
msgstr ""
"Erzeuge eine generische Functon für %s aus %s in %s\n"
"    (aus der gespeicherten impliziten Definition)"

#. R/Methods.R: gettextf("Creating a generic function for %s from package %s in %s",     sQuote(f), sQuote(fdef@package), thisPName)
#: R/Methods.R:0
msgid "Creating a generic function for %s from package %s in %s"
msgstr "Erzeuge generische Funktion für %s aus Paket %s in %s"

#. R/Methods.R: gettextf("Creating a generic function from function %s in %s",     sQuote(f), thisPName)
#: R/Methods.R:0
msgid "Creating a generic function from function %s in %s"
msgstr "Erzeuge generische Funktion aus Funktion %s in %s"

#. R/Methods.R: gettextf("Creating a new generic function for %s in %s", sQuote(name),     thisPName)
#: R/Methods.R:0
msgid "Creating a new generic function for %s in %s"
msgstr "Erzeuge neue generische Funktion für %s in %s"

#. R/RClassUtils.R: stop("Data part is undefined for general S4 object")
#: R/RClassUtils.R:0
msgid "Data part is undefined for general S4 object"
msgstr "Der Datenteil ist für ein allgemeines S4 Objekt undefiniert"

#. R/RClassUtils.R: gettextf("Debugging .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);\nE := environment(): %s; parent.env(E): %s",     what, format(cwhere), format(E <- environment()), format(parent.env(E)))
#: R/RClassUtils.R:0
msgid ""
"Debugging .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);\n"
"E := environment(): %s; parent.env(E): %s"
msgstr ""

#. R/RClassUtils.R: gettextf("Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s",     sQuote(dup), dQuote(name), dQuote(elNamed(allProps, dup)),     dQuote(cl), dQuote(elNamed(theseProperties, dup)))
#: R/RClassUtils.R:0
msgid "Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s"
msgstr "Definition von slot %s, in Klasse %s, als %s widerspricht der geerbten Definition aus Klasse %s, als %s"

#. R/RMethodUtils.R: message("Empty function name in .getGeneric")
#: R/RMethodUtils.R:0
msgid "Empty function name in .getGeneric"
msgstr "Leerer Funktionsname in .getGeneric"

#. R/trace.R: gettextf("Environment of class %s is locked; using global environment for new class",     dQuote(className))
#: R/trace.R:0
msgid "Environment of class %s is locked; using global environment for new class"
msgstr "Umgebung der Klasse %s ist gesichert; nutze die globale Umgebung für die neue Klasse"

#. R/Methods.R: gettextf("For function %s, signature %s: argument in method definition changed from (%s) to (%s)",     sQuote(f), sQuote(signature), mnames, fnames)
#: R/Methods.R:0
msgid "For function %s, signature %s: argument in method definition changed from (%s) to (%s)"
msgstr "Für die Funktion %s, Signatur %s: Argument in der Methodendefinition von (%s) auf (%s) geändert"

#. R/RClassUtils.R: gettextf("Found more than one class \"%s\" in cache; using the first, from namespace '%s'",     value[[1]]@className, pkgs[1])
#: R/RClassUtils.R:0
msgid "Found more than one class \"%s\" in cache; using the first, from namespace '%s'"
msgstr "Mehr als eine Klasse \"%s\" im Cache gefunden; nutze die erste, kommt aus Namensraum '%s'"

#. R/Methods.R: gettextf("Function %s is a group generic; do not call it directly",     sQuote(name))
#: R/Methods.R:0
msgid "Function %s is a group generic; do not call it directly"
msgstr "Funktion %s ist gruppengenerisch; nicht direkt aufrufen"

#. R/Methods.R: gettextf("Function %s is already a group generic; no change",     sQuote(name))
#: R/Methods.R:0
msgid "Function %s is already a group generic; no change"
msgstr "Funktion %s ist bereits gruppengenerisch; keine Änderung"

#. R/debug.R: stop("Function must be an S4 generic")
#: R/debug.R:0
msgid "Function must be an S4 generic"
msgstr "Funktion muss eine S4 Generische sein"

#. R/MethodsList.R: gettextf("In %s: use of \"MethodsList\" metadata objects is defunct.",     deparse(this))
#: R/MethodsList.R:0
msgid "In %s: use of \"MethodsList\" metadata objects is defunct."
msgstr "In %s: Nutzung der \"MethodsList\" Metadatenobjekte ist nicht mehr möglich."

#. R/MethodsList.R: gettextf("In %s: use of \"MethodsList\" metadata objects is deprecated.",     deparse(this))
#: R/MethodsList.R:0
msgid "In %s: use of \"MethodsList\" metadata objects is deprecated."
msgstr "In %s: Nutzung der \"MethodsList\" Metadatenobjekte ist veraltet."

#. R/trace.R: gettextf("Methods inserted for function %s(): %s", f, paste(methodsInserted,     collapse = ", "))
#: R/trace.R:0
msgid "Methods inserted for function %s(): %s"
msgstr "Methoden eingefügt für Funktion %s(): %s"

#. R/RMethodUtils.R: gettextf("Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information",     sQuote(fdef@generic))
#: R/RMethodUtils.R:0
msgid "Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information"
msgstr ""
"MethodsList Objekte werden in dieser R Version nicht mehr unterstützt: Frage nach \n"
"Funktion %s liefert evtl. falsche  Information"

#. R/refClass.R: gettextf("Methods not found: %s", paste(dQuote(methods[missing]),     collapse = ", "))
#: R/refClass.R:0
msgid "Methods not found: %s"
msgstr "Methoden nicht gefunden: %s"

#. R/trace.R: gettextf("Modified functions inserted through trace(): %s", paste(objectsDone,     collapse = ", "))
#: R/trace.R:0
msgid "Modified functions inserted through trace(): %s"
msgstr "Modifizierte Funktionen eingefügt über trace(): %s"

#. R/trace.R: gettextf("New functions are not currently inserted (not untraceable): %s",     paste(newObjects, collapse = ", "))
#: R/trace.R:0
msgid "New functions are not currently inserted (not untraceable): %s"
msgstr "Neue Funktionen sind aktuell nicht eingefügt (nicht verfolgbar): %s"

#. R/SClasses.R: gettextf("No %s names supplied", what)
#: R/SClasses.R:0
msgid "No %s names supplied"
msgstr "Keine %s Namen angegeben"

#. R/NextMethod.R: stop("No next method available")
#: R/NextMethod.R:0
msgid "No next method available"
msgstr "Keine weitere Methode verfügbar"

#. R/methodsTable.R: gettextf("No simply inherited methods found for function %s; using non-simple method",     sQuote(fdef@generic))
#: R/methodsTable.R:0
msgid "No simply inherited methods found for function %s; using non-simple method"
msgstr "Keine einfach vererbten Methoden für Funktion %s gefunden; nutze nicht-einfache Methode"

#. R/trace.R: gettextf("Non-function objects are not currently inserted (not traceable): %s",     paste(notTraceable, collapse = ", "))
#: R/trace.R:0
msgid "Non-function objects are not currently inserted (not traceable): %s"
msgstr "Nicht-Funktionen Objekte sind aktuell nicht eingefügt (nicht verfolgbar): %s"

#. R/methodsTable.R: gettextf("Note: method with signature %s chosen for function %s,\n target signature %s.\n %s would also be valid",     sQuote(selected), sQuote(attr(cond, "generic")), sQuote(attr(cond,         "target")), paste0("\"", possible[is.na(match(possible,         selected))], "\"", collapse = ", "))
#: R/methodsTable.R:0
msgid ""
"Note: method with signature %s chosen for function %s,\n"
" target signature %s.\n"
" %s would also be valid"
msgstr ""
"Bemerkung: Methode mit Signatur %s für Funktion %s gewählt,\n"
" Zielsignatur %s.\n"
" %s wäre ebenfalls gültig."

#. R/RClassUtils.R: gettextf("Note: some superclasses of class %s in package %s have duplicate definitions.  This definition is not being treated as equivalent to that from package %s",     dQuote(def@className), sQuote(def@package), sQuote(prev@package))
#: R/RClassUtils.R:0
msgid "Note: some superclasses of class %s in package %s have duplicate definitions.  This definition is not being treated as equivalent to that from package %s"
msgstr "Einige Superklassen der Klasse %s in Paket %s haben duplizierte Definitionen. Diese Definition wird nicht als äquivalent zu der aus Paket %s behandelt."

#. R/RClassUtils.R: gettextf("Note: the specification for class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class.",     dQuote(def@className), sQuote(def@package), sQuote(prev@package))
#: R/RClassUtils.R:0
msgid "Note: the specification for class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class."
msgstr "Die Spezifikation für die Klasse %s in Paket %s scheint äquivalent zu einer aus Paket %s; für diese Klasse werden  die Klassendefinitionen nicht dupliziert"

#. R/MethodsListClass.R: gettextf("\n    Notes: %s.\n", notei)
#: R/MethodsListClass.R:0
msgid "Notes: %s."
msgstr "Bemerkung: %s."

#. R/BasicClasses.R: gettextf("OOPS: something wrong with '.OldClassesPrototypes[[%d]]'",     i)
#: R/BasicClasses.R:0
msgid "OOPS: something wrong with '.OldClassesPrototypes[[%d]]'"
msgstr "OOPS: irgendetwas ist falsch mit '.OldClassesPrototypes[[%d]]'"

#. R/refClass.R: gettextf("Reference superclasses must come from the same package for the environment to be defined:  got %s and %s",     .nQuote(clRefMethods$.objectPackage), .nQuote(pkg))
#: R/refClass.R:0
msgid "Reference superclasses must come from the same package for the environment to be defined:  got %s and %s"
msgstr ""
"Referenzoberklasse muss aus dem selben Paket stammen, damit die Umgebung\n"
"definiert ist: bekam %s und %s"

#. R/Methods.R: gettextf("Restoring default function definition of %s", sQuote(f))
#: R/Methods.R:0
msgid "Restoring default function definition of %s"
msgstr "stelle Standardfunktionsdefinitionen für %s wieder her"

#. R/ClassExtensions.R: gettextf("S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s",     dQuote(class(object)))
#: R/ClassExtensions.R:0
msgid "S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s"
msgstr "S3Part() ist nur definiert für Klassen, die durch setOldCLass(), Basisklassen oder deren Subklassen erzeugt werden; gilt nicht für Klasse %s"

#. R/method.skeleton.R: gettextf("Skeleton of method written to %s", if (is.character(file)) file else "connection")
#: R/method.skeleton.R:0
msgid "Skeleton of method written to %s"
msgstr "Skelett der Methode geschrieben in %s"

#. R/RClassUtils.R: gettextf("The prototype for class %s has undefined slot(s): %s",     dQuote(name), paste0("'", undefinedPrototypeSlots, "'", collapse = ", "))
#: R/RClassUtils.R:0
msgid "The prototype for class %s has undefined slot(s): %s"
msgstr "Der Prototyp für Klasse %s hat nicht definierte Slot(s): %s"

#. R/MethodsList.R: gettextf("Use %s instead. ", dQuote(instead))
#. R/MethodsList.R: gettextf("Use %s instead. ", dQuote(instead))
#: R/MethodsList.R:0
msgid "Use %s instead."
msgstr "Nutze stattdessen %s."

#. R/as.R: gettextf("a 'replace' method definition in 'setAs' must be a function of two arguments, got %d",     length(args))
#: R/as.R:0
msgid "a 'replace' method definition in 'setAs' must be a function of two arguments, got %d"
msgstr "eine 'replace' Methodendefinition in 'setAs' muss eine Funktion von zwei Argumenten sein; bekam %d"

#. R/NextMethod.R: gettextf("a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'",     sQuote(f))
#: R/NextMethod.R:0
msgid "a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'"
msgstr "ein Aufruf von callNextMethod() tritt in einem Aufruf von %s auf, aber der Aufruf stammt weder von einer generischen Funktion, noch von einem anderen Aufruf von 'callNextMethod'"

#. R/refClass.R: gettextf("a call to superClass() is in the method %s but there is no superclass definition of this method for class %s",     sQuote(me), dQuote(thisClass@className))
#: R/refClass.R:0
msgid "a call to superClass() is in the method %s but there is no superclass definition of this method for class %s"
msgstr "in der Methode \"%s\" ist ein Aufruf von superClass(), aber es gibt keine Superklassendefiniton dieser Methode für die Klasse %s"

#. R/Methods.R: stop("a function for argument 'f' must be a generic function")
#. R/trace.R: stop("a function for argument 'f' must be a generic function")
#: R/Methods.R:0 R/trace.R:0
msgid "a function for argument 'f' must be a generic function"
msgstr "eine Funktion für Argument 'f' muss eine generische Funktion sein"

#. R/RClassUtils.R: gettextf("a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s",     dQuote(class(prototype@object)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s"
msgstr "ein Prototypenobjekt wurde mit dem Objektslot der Klasse %s angegeben, aber die Klassendefinition verlangt ein Objekt der Klasse %s"

#. R/RClassUtils.R: gettextf("a prototype was supplied of class %s, but the class definition requires an object that is class %s",     dQuote(class(prototype)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "a prototype was supplied of class %s, but the class definition requires an object that is class %s"
msgstr "ein Prototyp der Klasse %s wurde angegeben, aber die Klassendefiniton verlangt eine Objekt der Klasse %s"

#. R/refClass.R: gettextf("a single class name is needed for field %s, got a character vector of length %d",     sQuote(thisName), length(thisField))
#: R/refClass.R:0
msgid "a single class name is needed for field %s, got a character vector of length %d"
msgstr "Einzelner Klassenname nötig für Feld %s, bekam eine Zeichenkette der Länge %d"

#. R/RClassUtils.R: gettextf("a validity method must be a function of one argument, got an object of class %s",     dQuote(class(validity)))
#: R/RClassUtils.R:0
msgid "a validity method must be a function of one argument, got an object of class %s"
msgstr "eine Validierungsmethode muss eine Funktion mit einem Argument sein, bekam Objekt der Klasse %s"

#. R/SClasses.R: gettextf("abnormal type %s is not supported as a superclass of a class definition",     dQuote(type))
#: R/SClasses.R:0
msgid "abnormal type %s is not supported as a superclass of a class definition"
msgstr "Sorry, der unnormaler Typ %s wird als  Superklasse der Klassendefinition nicht unterstützt"

#. R/RMethodUtils.R: gettextf("action function %s has no arguments, should have at least 1",     sQuote(fname))
#: R/RMethodUtils.R:0
msgid "action function %s has no arguments, should have at least 1"
msgstr "Aktionsfunktion %s hat kein Argument, sollte mindestens 1 haben"

#. R/as.R: warning("ambiguous object (length != 1) to coerce to \"name\"")
#: R/as.R:0
msgid "ambiguous object (length != 1) to coerce to \"name\""
msgstr "zweideutiges Objekt (Länge ungleich 1) für Umwandlung in \"name\""

#. R/zzz.R: warning("apparently bad method or class metadata in saved environment;\n",     "move the file or remove the class/method")
#: R/zzz.R:0
msgid "apparently bad method or class metadata in saved environment;"
msgstr "anscheinend unbrauchbare Methode oder Klassenmetadaten in gespeicherter Umgebung;"

#. R/Methods.R: gettextf("argument %s is not S4", deparse1(substitute(f1)))
#. R/Methods.R: gettextf("argument %s is not S4", deparse1(substitute(f2)))
#: R/Methods.R:0
msgid "argument %s is not S4"
msgstr "Argument %s ist nicht S4"

#. R/Methods.R: gettextf("argument %s must be a generic function or a single character string; got an object of class %s",     sQuote("f"), dQuote(class(f)))
#: R/Methods.R:0
msgid "argument %s must be a generic function or a single character string; got an object of class %s"
msgstr "Argument %s muss eine generische Funktion oder eine Zeichenkette sein; bekam ein Objekt aus Klasse %s"

#. R/SClasses.R: gettextf("argument %s must be a list or a character vector; got an object of class %s",     dQuote(what), dQuote(class(fields)))
#: R/SClasses.R:0
msgid "argument %s must be a list or a character vector; got an object of class %s"
msgstr "Argument %s muss eine Liste oder eine Zeichenkette sein; bekam ein Objekt aus Klasse %s"

#. R/oldClass.R: gettextf("argument 'Classes' must be a vector of two classes; got an argument of length %d",     length(Classes))
#: R/oldClass.R:0
msgid "argument 'Classes' must be a vector of two classes; got an argument of length %d"
msgstr "Argument 'Classes' muss ein Vektor aus zwei Klassen sein: bekam Argument der Länge %d"

#. R/oldClass.R: gettextf("argument 'S4Class' must be a class definition: got an object of class %s",     dQuote(class(S4Class)))
#: R/oldClass.R:0
msgid "argument 'S4Class' must be a class definition: got an object of class %s"
msgstr "Argument 'S4Class' muss eine Klassendefinition sein; bekam ein Objekt aus Klasse %s"

#. R/RClassUtils.R: stop("argument 'abbreviate' must be 0, 1, 2, or 3")
#: R/RClassUtils.R:0
msgid "argument 'abbreviate' must be 0, 1, 2, or 3"
msgstr "Argument 'abbreviate' muss 0, 1, 2 oder 3 sein"

#. R/SClasses.R: stop("argument 'classDef' must be a class definition or the name of a class")
#: R/SClasses.R:0
msgid "argument 'classDef' must be a class definition or the name of a class"
msgstr "Argument 'classdef' muss eine Klassendefinition oder der Name einer Klasse sein"

#. R/SClasses.R: gettextf("argument 'classDef' must be a string or a class representation; got an object of class %s",     dQuote(class(classDef)))
#: R/SClasses.R:0
msgid "argument 'classDef' must be a string or a class representation; got an object of class %s"
msgstr "Argument 'classDef' muss eine Zeichenkette oder eine Klassenrepräsentation sein; bekam ein Objekt aus Klasse %s"

#. R/Methods.R: gettextf("argument 'f' must be a generic function or %s", .notSingleString(f))
#: R/Methods.R:0
msgid "argument 'f' must be a generic function or %s"
msgstr "Argument 'f' muss eine generische Funktion oder %s sein"

#. R/RMethodUtils.R: stop("argument 'f' must be a string, generic function, or primitive: got an ordinary function")
#: R/RMethodUtils.R:0
msgid "argument 'f' must be a string, generic function, or primitive: got an ordinary function"
msgstr "Argument 'f' muss eine Zeichenkette, eine generische Funktion oder eine Primitive sein: bekam eine gewöhnliche Funktion"

#. R/RClassUtils.R: stop("argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'")
#: R/RClassUtils.R:0
msgid "argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'"
msgstr "Argument 'includeSubclasses' muss boolesch sein, entweder ein Wert oder ein Vektor der Länge der Argumentklassen"

#. R/trace.R: stop("argument 'signature' is not meaningful for tracing reference methods")
#: R/trace.R:0
msgid "argument 'signature' is not meaningful for tracing reference methods"
msgstr "Argument 'signature' ist nicht sinnvoll um Referenzmethoden zu verfolgen"

#. R/Methods.R: warning("argument 'signature' is not meaningful with the current implementation and is ignored \n(extract a subset of the methods list instead)")
#: R/Methods.R:0
msgid ""
"argument 'signature' is not meaningful with the current implementation and is ignored \n"
"(extract a subset of the methods list instead)"
msgstr ""
"Argument 'signatur' ist in der aktuellen Implementierung ohne Bedeutung und wird ignoriert\n"
"(stattdessen wird Teilmenge der Methodenliste extrahiert)"

#. R/methodsTable.R: stop("argument 'signatures' must be a character matrix whose rows are method signatures")
#: R/methodsTable.R:0
msgid "argument 'signatures' must be a character matrix whose rows are method signatures"
msgstr "Argument 'signatures' muss eine Zeichenmatrix sein, deren Zeilen Methodensignaturen enthalten"

#. R/trace.R: stop("argument 'what' should be the name of a function")
#: R/trace.R:0
msgid "argument 'what' should be the name of a function"
msgstr "Argument 'what' sollte der Name einer Funktion sein"

#. R/RMethodUtils.R: stop("argument f must be a generic function with signature \"...\"")
#: R/RMethodUtils.R:0
msgid "argument f must be a generic function with signature \"...\""
msgstr "Argument f muss eine generische Funktion mit Signatur \"...\" sein"

#. R/as.R: gettextf("argument names in 'replace' changed to agree with 'coerce<-' generic:\n%s",     paste(deparse(replace), sep = "\n    "))
#: R/as.R:0
msgid ""
"argument names in 'replace' changed to agree with 'coerce<-' generic:\n"
"%s"
msgstr ""
"Argumentnamen in 'replace' geändert, so dass diese mit der 'coerce<-' Generischen zusammenpassen: \n"
"%s"

#. R/MethodsList.R: stop("arguments 'names' and 'signature' must have the same length")
#: R/MethodsList.R:0
msgid "arguments 'names' and 'signature' must have the same length"
msgstr "Argumente 'names' und 'signature' müssen dieselbe Länge haben"

#. R/refClass.R: stop("arguments must all be character string names of fields")
#: R/refClass.R:0
msgid "arguments must all be character string names of fields"
msgstr "Argumente müssen alle Feldnamen als Zeichenketten sein"

#. R/refClass.R: stop("arguments to methods() must be named, or one named list")
#: R/refClass.R:0
msgid "arguments to methods() must be named, or one named list"
msgstr "Argumente für methods() müssen entweder benannt sein oder eine benannte Liste"

#. R/RClassUtils.R: gettextf("assigning as %s a class representation with internal name %s",     dQuote(Class), dQuote(def@className))
#: R/RClassUtils.R:0
msgid "assigning as %s a class representation with internal name %s"
msgstr "Zuweisen als %s einer Klassenrepräsentation mit internem Namen %s"

#. R/trace.R: gettextf("assigning over the binding of symbol %s in environment/package %s",     sQuote(what), sQuote(pname))
#: R/trace.R:0
msgid "assigning over the binding of symbol %s in environment/package %s"
msgstr "Zuweisung über die Bindung des Symbols %s in der Umbegung / im Paket %s"

#. R/SClasses.R: gettextf("assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE",     dQuote(valueClass), sQuote(name), dQuote(cl), slotClass)
#: R/SClasses.R:0
msgid "assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE"
msgstr "Zuweisung eines Objektes der Klasse %s ist für @%s in einem Objekt aus Klasse %s nicht zulässig; is(value, \"%s\") ist nicht TRUE"

#. R/SClasses.R: gettextf("assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE",     dQuote(valueClass), sQuote(name), dQuote(cl), slotClass)
#: R/SClasses.R:0
msgid "assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE"
msgstr "Zuweisung eines Objektes der Klasse %s ist für Slot \"%s\" in einem Objekt aus Klasse %s nicht zulässig; is(value, \"%s\") ist nicht TRUE"

#. R/Methods.R: gettextf("bad class specified for element %d (should be a single character string)",     i)
#: R/Methods.R:0
msgid "bad class specified for element %d (should be a single character string)"
msgstr "ungültige Klasse für Element %d spezifiziert (sollte eine Zeichenkette sein)"

#. R/methodsTable.R: gettextf("bad method object stored in method table, class %s",     dQuote(class(current)))
#: R/methodsTable.R:0
msgid "bad method object stored in method table, class %s"
msgstr "ungültiges Methodenobjekt in der Methodentabelle, Klasse %s"

#. R/NextMethod.R: gettextf("bad object found as method (class %s)", dQuote(class(method)))
#: R/NextMethod.R:0
msgid "bad object found as method (class %s)"
msgstr "ungültiges Objekt als Methode (Klasse %s) gefunden"

#. R/is.R: gettext("both classes must be defined")
#: R/is.R:0
msgid "both classes must be defined"
msgstr "beide Klassen müssen definiert sein"

#. R/NextMethod.R: stop("call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context")
#: R/NextMethod.R:0
msgid "call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context"
msgstr "Aufruf von 'callNextMethod' ist anscheinend nicht in einem 'method' oder 'callNextMethod' Kontext"

#. R/Methods.R: stop("callGeneric() must be called from within a method body")
#: R/Methods.R:0
msgid "callGeneric() must be called from within a method body"
msgstr "'callGeneric' muss in einer Methode aufgerufen werden"

#. R/is.R: gettextf("cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package",     dQuote(class1), dQuote(class2))
#: R/is.R:0
msgid "cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package"
msgstr "kann keine 'setIs' Relation erzeugen, wenn keine der Klassen (%s und %s) lokal und modifizierbar in diesem Paket ist"

#. R/trace.R: gettextf("cannot find an environment corresponding to package name '%s\"",     package)
#: R/trace.R:0
msgid "cannot find an environment corresponding to package name '%s\""
msgstr "kann keine Umgebung finden, die mit dem Paketnamen '%s' korrespondiert"

#. R/BasicClasses.R: stop("cannot have more than one unnamed argument as environment")
#: R/BasicClasses.R:0
msgid "cannot have more than one unnamed argument as environment"
msgstr "man kann nicht mehr als ein namenloses Argument als Umbgebung haben"

#. R/trace.R: gettextf("cannot insert methods for these functions (methods table not found in source): %s",     paste0("\"", methods[notThere], "\"", collapse = ", "))
#: R/trace.R:0
msgid "cannot insert methods for these functions (methods table not found in source): %s"
msgstr "kann keine Methoden für diese Funktionen einfügen (Methodentabelle nicht im Quelltext): %s"

#. R/trace.R: gettextf("cannot insert these (not found in source): %s", paste0("\"",     functions[notThere], "\"", collapse = ", "))
#: R/trace.R:0
msgid "cannot insert these (not found in source): %s"
msgstr "kann Folgende nicht einfügen (nicht in den Sourcen gefunden): %s"

#. R/Methods.R: gettextf("cannot remove methods for %s in locked environment/package %s",     sQuote(f), sQuote(getPackageName(db)))
#: R/Methods.R:0
msgid "cannot remove methods for %s in locked environment/package %s"
msgstr "kann Methoden von %s aus gesicherter/m Umgebung/Paket %s nicht entfernen"

#. R/BasicClasses.R: stop("cannot specify array() arguments when specifying '.Data'")
#: R/BasicClasses.R:0
msgid "cannot specify array() arguments when specifying '.Data'"
msgstr "kann array() Argumente nicht spezifizieren, wenn '.Data' spezifiziert wird"

#. R/BasicClasses.R: stop("cannot specify matrix() arguments when specifying '.Data'")
#: R/BasicClasses.R:0
msgid "cannot specify matrix() arguments when specifying '.Data'"
msgstr "kann matrix() Argumente nicht spezifizieren, wenn '.Data' spezifiert wird"

#. R/trace.R: gettextf("cannot untrace method for %s; no method defined for this signature: %s",     sQuote(what), paste(signature, collapse = ", "))
#: R/trace.R:0
msgid "cannot untrace method for %s; no method defined for this signature: %s"
msgstr "kann die Verfolgung von %s nicht aufheben; keine Methodendefinition für diese Signatur: %s"

#. R/trace.R: stop("cannot use 'at' argument unless the function body has the form '{ ... }'")
#: R/trace.R:0
msgid "cannot use 'at' argument unless the function body has the form '{ ... }'"
msgstr "kann das 'at' Argument nur nutzen, wenn der Funktionskörper die Form '{ ... }' besitzt"

#. R/trace.R: stop("cannot use 'at' argument without a trace expression")
#: R/trace.R:0
msgid "cannot use 'at' argument without a trace expression"
msgstr "kann das 'at' Argument nicht ohne Traceexpression nutzen"

#. R/SClasses.R: gettextf("cannot use object of class %s in new():  class %s does not extend that class",     dQuote(Classi), dQuote(Class))
#: R/SClasses.R:0
msgid "cannot use object of class %s in new():  class %s does not extend that class"
msgstr "kann Objekt der Klasse %s nicht in new() benutzen; Klasse %s erweitert diese nicht"

#. R/is.R: gettextf("class %s cannot extend class %s", dQuote(class1), dQuote(class2))
#: R/is.R:0
msgid "class %s cannot extend class %s"
msgstr "Klasse %s kann nicht Klasse %s erweitern"

#. R/RClassUtils.R: gettextf("class %s does not have a data part (a .Data slot) defined",     dQuote(class(object)))
#: R/RClassUtils.R:0
msgid "class %s does not have a data part (a .Data slot) defined"
msgstr "Klasse %s hat keinen Datenteil (einen .Data Slot) definiert"

#. R/BasicClasses.R: gettextf("class %s does not have an S3 data part, and so is of type \"S4\"; no S3 equivalent",     dQuote(class(from)))
#: R/BasicClasses.R:0
msgid "class %s does not have an S3 data part, and so is of type \"S4\"; no S3 equivalent"
msgstr "Klasse %s hat keinen S3 Datenteil und ist deshalb vom Typ \"S4\"; kein S3 Äquivalent"

#. R/RClassUtils.R: gettextf("class %s extends an undefined class (%s)", dQuote(name),     dQuote(cl))
#: R/RClassUtils.R:0
msgid "class %s extends an undefined class (%s)"
msgstr "Klasse %s erweitert eine nicht definierte Klasse (%s)"

#. R/RClassUtils.R: gettextf("class %s extends an undefined class, %s", dQuote(ClassDef@className),     dQuote(what))
#: R/RClassUtils.R:0
msgid "class %s extends an undefined class, %s"
msgstr "Klasse %s erweitert eine nicht definierte Klasse %s"

#. R/refClass.R: gettextf("class %s for field %s is not defined", dQuote(thisField),     sQuote(thisName))
#: R/refClass.R:0
msgid "class %s for field %s is not defined"
msgstr "Klasse %s für Feld %s nicht definiert"

#. R/RClassUtils.R: gettextf("class %s has a locked definition in package %s", dQuote(Class),     sQuote(getPackageName(where)))
#: R/RClassUtils.R:0
msgid "class %s has a locked definition in package %s"
msgstr "Klasse %s besitzt eine gesicherte Definition in Paket %s"

#. R/SClasses.R: gettextf("class %s has multiple definitions visible; only the first removed",     dQuote(Class))
#: R/SClasses.R:0
msgid "class %s has multiple definitions visible; only the first removed"
msgstr "Klasse %s hat mehrere sichtbare Definitionen; nur die erste entfernt"

#. R/is.R: gettextf("class %s has no visible definition from package or environment %s",     dQuote(class2), sQuote(getPackageName(where)))
#: R/is.R:0
msgid "class %s has no visible definition from package or environment %s"
msgstr "Klasse %s hat keine sichtbare Definition aus Paket oder Umgebung %s"

#. R/BasicClasses.R: gettextf("class %s is VIRTUAL; not meaningful to create an S4 object from this class",     dQuote(cl))
#: R/BasicClasses.R:0
msgid "class %s is VIRTUAL; not meaningful to create an S4 object from this class"
msgstr "Klasse %s ist VIRTUELL; nicht sinnvoll ein S4 Objekt daraus zu erzeugen"

#. R/as.R: gettextf("class %s is a class union: 'coerce' relations to a class union are not meaningful",     dQuote(to))
#: R/as.R:0
msgid "class %s is a class union: 'coerce' relations to a class union are not meaningful"
msgstr "Klasse %s ist eine Klassenvereinigung; 'coerce' Relationen in eine Klassenvereinigung ergeben keinen Sinn"

#. R/is.R: gettextf("class %s is defined (with package slot %s) but no metadata object found to revise %s information---not imported?  Making a copy in package %s",     .dQ(class), sQuote(classDef@package), purpose, sQuote(getPackageName(where,         FALSE)))
#: R/is.R:0
msgid "class %s is defined (with package slot %s) but no metadata object found to revise %s information---not imported?  Making a copy in package %s"
msgstr "Klasse %s ist definiert (mit Paketslot %s) aber kein Metadatenobjekt gefunden, um %s Information zu überprüfen -- nicht importiert? Erzeuge Kopie in Paket %s"

#. R/refClass.R: gettextf("class %s is defined but is not a reference class",     dQuote(Class))
#: R/refClass.R:0
msgid "class %s is defined but is not a reference class"
msgstr "Klasse %s ist definiert, aber keine Referenzklasse"

#. R/SClasses.R: gettextf("class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)",     dQuote(Class), sQuote(classDef@package))
#: R/SClasses.R:0
msgid "class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)"
msgstr "Klasse %s ist definiert, mit Paket %s, aber kein korrespondierendes Metadatenobjekt gefunden (nicht exportiert?)"

#. R/RClassUtils.R: gettextf("class %s is inheriting an inconsistent superclass structure from class %s, inconsistent with %s",     .dQ(className), .dQ(by), paste(.dQ(coni), collapse = ", "))
#: R/RClassUtils.R:0
msgid "class %s is inheriting an inconsistent superclass structure from class %s, inconsistent with %s"
msgstr "Klasse %s erbt eine inkonsistente Superklassenstruktur von Klasse %s, inkonsistent mit %s"

#. R/as.R: gettextf("class %s is not defined in this environment", dQuote(to))
#: R/as.R:0
msgid "class %s is not defined in this environment"
msgstr "Klasse %s ist in dieser Umgebung nicht definiert"

#. R/SClasses.R: gettextf("class %s is sealed; 'resetClass' will have no effect",     dQuote(Class))
#: R/SClasses.R:0
msgid "class %s is sealed; 'resetClass' will have no effect"
msgstr "Klasse %s ist versiegelt; 'resetClass' hat keinen Effekt"

#. R/is.R: gettextf("class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'",     dQuote(class1))
#: R/is.R:0
msgid "class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'"
msgstr "Klasse %s ist versiegelt; neue Superklassen können nur mit 'setClassUnion' erzeugt werden"

#. R/SClasses.R: gettextf("class %s not found on %s; 'resetClass' will have no effect",     dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "class %s not found on %s; 'resetClass' will have no effect"
msgstr "Klasse %s nicht in %s gefunden; 'resetClass' hat keinen Effekt"

#. R/RClassUtils.R: stop("class cannot have both an ordinary and hidden data type")
#: R/RClassUtils.R:0
msgid "class cannot have both an ordinary and hidden data type"
msgstr "Eine Klasse kann nicht sowohl einen gewöhnlichen und einen versteckten Datentyp haben"

#. R/SClasses.R: gettextf("class definition cannot extend more than one of these data types: %s",     paste0("\"", type, "\"", collapse = ", "))
#: R/SClasses.R:0
msgid "class definition cannot extend more than one of these data types: %s"
msgstr "Klassendefinitionen können nicht mehr als einen dieser Datentypen erweitern: %s"

#. R/SClasses.R: gettextf("class definition for %s not found (no action taken)",     dQuote(Class))
#: R/SClasses.R:0
msgid "class definition for %s not found (no action taken)"
msgstr "Klassendefinition für %s nicht gefunden (keine Aktion ausgeführt)"

#. R/MethodsListClass.R: gettextf("class generator function for class %s from package %s\n",     dQuote(object@className), sQuote(object@package))
#: R/MethodsListClass.R:0
msgid "class generator function for class %s from package %s"
msgstr "Klassenerzeuger Funktion für Klasse %s aus Paket %s"

#. R/refClass.R: gettextf("class must be a reference class representation or a character string; got an object of class %s",     dQuote(class(Class)))
#: R/refClass.R:0
msgid "class must be a reference class representation or a character string; got an object of class %s"
msgstr "Klass muss eine Referenzklasse oder eine Zeichenkette sein; bekam ein Objekt aus Klasse %s"

#. R/refClass.R: gettextf("code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)",     dQuote(Class), sQuote("codetools"))
#: R/refClass.R:0
msgid "code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)"
msgstr "Kode für die Methoden in der Klasse %s wurde nicht auf verdächtige Feldzuweisungen überprüft (empfohlenes Paket %s nicht verfügbar?)"

#. R/RClassUtils.R: gettextf("conflicting definition of data part: .Data = %s, superclass implies %s",     dQuote(elNamed(properties, ".Data")), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "conflicting definition of data part: .Data = %s, superclass implies %s"
msgstr "Widerspruch in der Definition des Datenteils: .Data=%s, Superklasse verlangt %s"

#. R/MethodsList.R: gettextf("default method must be a method definition, a primitive or NULL: got an object of class %s",     dQuote(class(method)))
#: R/MethodsList.R:0
msgid "default method must be a method definition, a primitive or NULL: got an object of class %s"
msgstr "die Standardmethode muss eine Methodendefinition, eine Primitive oder NULL sein: Bekam Objekt der Klasse %s"

#. R/refClass.R: stop("direct calls to callSuper() are invalid:  should only be called from another method")
#: R/refClass.R:0
msgid "direct calls to callSuper() are invalid:  should only be called from another method"
msgstr "direkte Aufrufe von callSuper() sind unzulässig: sollte nur von einer anderen Methode aufgerufen werden"

#. R/trace.R: gettextf("does not seem to be a method table for generic %s in tracing environment",     sQuote(what))
#: R/trace.R:0
msgid "does not seem to be a method table for generic %s in tracing environment"
msgstr "scheint keine Methodentabelle für die Generische %s in der Verfolgungsumgebung zu sein"

#. R/SClasses.R: gettextf("duplicate class names among superclasses: %s", paste(.dQ(includes[duplicated(includes)]),     collapse = ", "))
#: R/SClasses.R:0
msgid "duplicate class names among superclasses: %s"
msgstr "doppelte Klassennamen unter den Superklassen: %s"

#. R/MethodsList.R: gettextf("duplicate element names in 'MethodsList' at level %d: %s",     level, paste("\"", unique(mnames[duplicated(mnames)]), "\"",         collapse = ", "))
#: R/MethodsList.R:0
msgid "duplicate element names in 'MethodsList' at level %d: %s"
msgstr "doppelte Elementnamen in 'MethodsList' auf Stufe %d: %s"

#. R/SClasses.R: gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]),     collapse = ", "))
#: R/SClasses.R:0
msgid "duplicated slot names: %s"
msgstr "doppelte Slotnamen: %s"

#. R/MethodsList.R: gettextf("element %d at level %d (class %s) cannot be interpreted as a function or named list",     i, level, dQuote(class(eli)))
#: R/MethodsList.R:0
msgid "element %d at level %d (class %s) cannot be interpreted as a function or named list"
msgstr "Element %d auf Stufe %d (Klasse %s) kann nicht als Funktion oder benannte Liste interpretiert werden"

#. R/SClasses.R: gettextf("element %d of the representation was not a single character string",     i)
#: R/SClasses.R:0
msgid "element %d of the representation was not a single character string"
msgstr "Element %d der Representation war keine einzelne Zeichenkette"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s and unable to remove definition from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s and unable to remove definition from %s"
msgstr "Fehler in den enthaltenen Klassen (%s) für Klasse %s und kann die Definition nicht aus %s entfernen"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s and unable to restore previous definition from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s and unable to restore previous definition from %s"
msgstr "Fehler in den enthaltenen Klassen (%s) für Klasse %s und kann die frühere Definition nicht aus %s wiederherstellen"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s; class definition removed from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s; class definition removed from %s"
msgstr "Fehler in den enthaltenen Klassen (%s) für Klasse %s; Definition aus %s entfernt"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s; previous definition restored to %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s; previous definition restored to %s"
msgstr "Fehler in den enthaltenen Klassen (%s) für Klasse %s; frühere Definition als %s wiederhergestellt"

#. R/RMethodUtils.R: gettextf("error in load action %s for package %s: %s: %s", aname,     getPackageName(where), callString, value$message)
#: R/RMethodUtils.R:0
msgid "error in load action %s for package %s: %s: %s"
msgstr "Fehler in der Ladeaktion %s für Paket %s: %s: %s"

#. R/Methods.R: gettextf("error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)",     sQuote(f), dQuote(class(fdef)))
#: R/Methods.R:0
msgid "error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)"
msgstr "Fehler beim Aktualisieren der generischen S4 Funktion %s; Funktionsdefinition ist keine generische S4 Funktion (Klasse %s)"

#. R/RMethodUtils.R: gettextf("expanding the signature to include omitted arguments in definition: %s",     paste(sigNames[omittedSig], "= \"missing\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "expanding the signature to include omitted arguments in definition: %s"
msgstr "erweitere Signatur um ausgelassene Argumente in Definition: %s"

#. R/addedFunctions.R: gettextf("expected a non-empty character string for argument 'name'")
#: R/addedFunctions.R:0
#, fuzzy
msgid "expected a non-empty character string for argument 'name'"
msgstr "erwarte nicht-leere Zeichenkette als Argumentnamen"

#. R/Methods.R: gettextf("expected a non-empty character string for argument name")
#: R/Methods.R:0
msgid "expected a non-empty character string for argument name"
msgstr "erwarte nicht-leere Zeichenkette als Argumentnamen"

#. R/oldClass.R: gettextf("explicit coercion of old-style class (%s) is not defined",     paste(class(from), collapse = ", "))
#: R/oldClass.R:0
msgid "explicit coercion of old-style class (%s) is not defined"
msgstr "expizite Umwandlung der Klasse (%s) im alten Stil ist nicht defineirt"

#. R/oldClass.R: gettextf("explicit replacement not defined for as(x, \"%s\") <- value for old-style class %s",     to, dQuote(class(from)[1L]))
#: R/oldClass.R:0
msgid "explicit replacement not defined for as(x, \"%s\") <- value for old-style class %s"
msgstr "explizite Ersetzung ist für as(x , \"%s\") <- value für eine Klasse %s alten Stils nicht definiert"

#. R/methodsTable.R: stop("failed to find expected group generic function: ", what)
#: R/methodsTable.R:0
msgid "failed to find expected group generic function:"
msgstr "konnte die erwartete gruppengenerische Funktion nicht finden"

#. R/Methods.R: gettextf("fdef appears to be a generic function, but with generic name %s instead of %s",     sQuote(gen), sQuote(f))
#: R/Methods.R:0
#, fuzzy
msgid "fdef appears to be a generic function, but with generic name %s instead of %s"
msgstr "Funktion %s scheint eine generische Funktion zu sein, aber mit dem generischen Namen %s"

#. R/refClass.R: gettextf("field %s is already locked", sQuote(what))
#: R/refClass.R:0
msgid "field %s is already locked"
msgstr "Feld %s ist bereits gesichert"

#. R/refClass.R: gettextf("field %s of class %s has a non-default binding and cannot be locked",     sQuote(what), dQuote(className))
#: R/refClass.R:0
msgid "field %s of class %s has a non-default binding and cannot be locked"
msgstr "Feld %s der Klasse %s hat eine nicht-standard Bindung und kann nicht gesichert werden."

#. R/refClass.R: gettextf("field %s was supplied as an object of class %s; must be a class name or a binding function",     sQuote(thisName), dQuote(class(thisField)))
#: R/refClass.R:0
msgid "field %s was supplied as an object of class %s; must be a class name or a binding function"
msgstr "Feld %s wurde angegeben als Objekt der Klasse %s; muss ein Klassenname sein oder eine Bindungsfunktion"

#. R/Methods.R: gettextf("first argument should be the names of one of more generic functions (got object of class %s)",     dQuote(class(f)))
#: R/Methods.R:0
msgid "first argument should be the names of one of more generic functions (got object of class %s)"
msgstr "erstes Argument sollte(n) Name(n) generischer Funktion(en) sein (bekam Objekt der Klasse %s"

#. R/RMethodUtils.R: gettextf("formal arguments (%s) omitted in the method definition cannot be in the signature",     bad2)
#: R/RMethodUtils.R:0
msgid "formal arguments (%s) omitted in the method definition cannot be in the signature"
msgstr "formale Argumente (%s), die in der Methodendefinition ausgelassen wurden, können nicht in der Signatur sein"

#. R/Methods.R: gettext("formal arguments differ (in default values?)")
#: R/Methods.R:0
msgid "formal arguments differ (in default values?)"
msgstr "formale Argumente unterscheiden sich (in den Standardwerten?)"

#. R/Methods.R: gettextf("formal arguments differ: (%s), (%s)", paste(a1, collapse = ", "),     paste(a2, collapse = ", "))
#: R/Methods.R:0
msgid "formal arguments differ: (%s), (%s)"
msgstr "formale Argumente unterscheiden sich: (%s), (%s)"

#. R/RMethodUtils.R: stop(.renderSignature(f, signature), "formal arguments in method and generic do not appear in the same order",     call. = FALSE)
#. R/RMethodUtils.R: stop(.renderSignature(generic@generic, signature), "formal arguments in method and generic do not appear in the same order",     call. = FALSE)
#: R/RMethodUtils.R:0
msgid "formal arguments in method and generic do not appear in the same order"
msgstr "formale Argumente in Methode und der Generischen erscheinen nicht in der gleichen Reihenfolge"

#. R/Methods.R: stop("function supplied as argument 'f' must be a generic")
#: R/Methods.R:0
msgid "function supplied as argument 'f' must be a generic"
msgstr "Die Funktion, die als Argument 'f' angegeben wird, muss generisch sein"

#. R/Methods.R: gettextf("generic function %s not found for removal", sQuote(f))
#: R/Methods.R:0
msgid "generic function %s not found for removal"
msgstr "generische Funktion %s nicht gefunden, um sie zu entfernen"

#. R/Methods.R: gettextf("generic function supplied was not created for %s",     sQuote(name))
#: R/Methods.R:0
msgid "generic function supplied was not created for %s"
msgstr "angegebene generische Funktion nicht für \"%s\" erzeugt"

#. R/Methods.R: gettextf("generic names differ: %s, %s", .dQ(f1@generic), .dQ(f2@generic))
#: R/Methods.R:0
msgid "generic names differ: %s, %s"
msgstr "Generische Namen unterscheiden sich: %s, %s"

#. R/RMethodUtils.R: stop("got a negative maximum number of frames to look at")
#: R/RMethodUtils.R:0
msgid "got a negative maximum number of frames to look at"
msgstr "bekam eine negative maximale Zahl von zu beachtenden Frames"

#. R/Methods.R: gettextf("groups differ: %s, %s", .dQ(gpString(f1@group)), .dQ(gpString(f2@group)))
#: R/Methods.R:0
msgid "groups differ: %s, %s"
msgstr "Gruppen unterscheiden sich: %s, %s"

#. R/Methods.R: gettextf("if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default",     name)
#: R/Methods.R:0
msgid "if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default"
msgstr "wenn das 'def' Argument angegeben wird, muss es eine Funktion sein, die standardGeneric(\"%s\") aufruft oder der default ist"

#. R/RMethodUtils.R: gettextf("in changing formal arguments in %s, some of the old names are not in fact arguments: %s",     msg, paste0("\"", old[is.na(match(old, names(dlist)))], "\"",         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "in changing formal arguments in %s, some of the old names are not in fact arguments: %s"
msgstr "beim Ändern der formalen Argumente in %s; einige der alten Namen sind keine Argumente: %s"

#. R/RClassUtils.R: gettextf("in constructing the prototype for class %s, slots in prototype and not in class: %s",     dQuote(className), paste(extra, collapse = ", "))
#: R/RClassUtils.R:0
msgid "in constructing the prototype for class %s, slots in prototype and not in class: %s"
msgstr "während der Konstruktion des Prototypen für Klasse %s: Slots im Prototypen aber nicht in Klasse %s"

#. R/RClassUtils.R: gettextf("in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s",     dQuote(className), dQuote(.class1(prototype)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s"
msgstr "während der Konstruktion des Prototypen für Klasse %s: Prototyp ist aus Klasse %s, aber der Datenteil spezifiziert Klasse %s"

#. R/RClassUtils.R: gettextf("in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)",     dQuote(name), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)"
msgstr "in der definierenden Klasse %s, der angegebenen Datenteilklasse, ist %s nicht zulässig (muss entweder eine Grundklasse oder eine virtuelle Klasse, die Grundklasssen kombiniert, sein)"

#. R/RClassUtils.R: gettextf("in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")",     dQuote(ClassDef@className), dQuote(what), dQuote(class(exti)))
#: R/RClassUtils.R:0
msgid "in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")"
msgstr "in der Definition der Klasse %s: Information über Superklasse %s ist aus Klasse %s (erwartet \"SClassExtension\")"

#. R/RClassUtils.R: gettextf("in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s",     dQuote(className), paste(pnames[check], "(class", .dQ(slotDefs[match(pnames[check],         slotNames)]), ")", collapse = ", "))
#: R/RClassUtils.R:0
msgid "in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s"
msgstr "während der Konstruktion des Prototypen für Klasse %s können Elemente des Prototypen nicht der korrespondierenden Slotklasse %s zugeordnet werden"

#. R/RMethodUtils.R: gettextf("in method for %s with signature %s: ", sQuote(f), sQuote(msig))
#: R/RMethodUtils.R:0
msgid "in method for %s with signature %s:"
msgstr "in Methode %s für Signatur %s:"

#. R/oldClass.R: gettextf("inconsistent old-style class information for %s (maybe mixing old and new classes?)",     dQuote(cl))
#: R/oldClass.R:0
msgid "inconsistent old-style class information for %s (maybe mixing old and new classes?)"
msgstr "inkonsistente Klasseninformation für %s im alten Stil (werden evtl. alte und neue Klassen vermischt?)"

#. R/oldClass.R: gettextf("inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part",     dQuote(cl), dQuote(prevClass))
#: R/oldClass.R:0
msgid "inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part"
msgstr "inkonsistente Klasseninformation für %s im alten Stil; die Klasse ist definiert, erweitert aber nicht %s und ist als Datenteil unzulässig"

#. R/RClassUtils.R: gettextf("initializing objects from class %s with these arguments is not supported",     dQuote(Class))
#: R/RClassUtils.R:0
msgid "initializing objects from class %s with these arguments is not supported"
msgstr "Objekte der Klasse %s mit diesen Argumenten zu initialisieren wird nicht unterstützt"

#. R/MethodsList.R: stop("inserting method corresponding to empty signature")
#: R/MethodsList.R:0
msgid "inserting method corresponding to empty signature"
msgstr "Einfügen der Methode, die zur leeren Signatur korrespondiert"

#. R/MethodsList.R: gettextf("inserting method into non-methods-list object (class %s)",     dQuote(.class1(mlist)))
#: R/MethodsList.R:0
msgid "inserting method into non-methods-list object (class %s)"
msgstr "Einfügen einer Methode in ein Objekt (Klasse %s), das keine Methodenliste ist"

#. R/MethodsList.R: gettextf("inserting method with invalid signature matching argument '...' to class %s",     dQuote(signature[[1L]]))
#: R/MethodsList.R:0
msgid "inserting method with invalid signature matching argument '...' to class %s"
msgstr "Einfügen einer Methode mit ungültigem Argument '...' für Signaturmatching für Klasse %s"

#. R/refClass.R: stop("invalid 'Class' argument:  should be a single string")
#: R/refClass.R:0
msgid "invalid 'Class' argument:  should be a single string"
msgstr "Ungültiges 'Class'-Argument: sollte eine Zeichenkette sein"

#. R/show.R: gettextf("invalid 'ignore' argument; should be a class definition or a character vector, got an object of class %s",     dQuote(class(ignore)))
#: R/show.R:0
msgid "invalid 'ignore' argument; should be a class definition or a character vector, got an object of class %s"
msgstr "Unzulässiges 'ignore' Argument; sollte eine Klassendefinition oder eine Zeichenkette sein; bekam ein Objekt aus Klasse \"%s\""

#. R/MethodsList.R: stop("invalid 'package' slot or attribute, wrong length")
#: R/MethodsList.R:0
msgid "invalid 'package' slot or attribute, wrong length"
msgstr "unzulässiges 'package' Element oder Attribut, falsche Länge"

#. R/trace.R: gettextf("invalid 'source' argument: expected file names or a connection but got an object of class %s",     dQuote(class(source)[[1L]]))
#: R/trace.R:0
msgid "invalid 'source' argument: expected file names or a connection but got an object of class %s"
msgstr "ungültiges 'source' Argument: Dateiname(n) oder eine Connection erwartet, Objekt der Klasse %s bekommen"

#. R/oldClass.R: gettextf("invalid S4 class corresponding to S3 class: slots in  S4 version must extend corresponding slots in S3 version: fails for %s",     paste0("\"", bad, "\"", collapse = ", "))
#: R/oldClass.R:0
msgid "invalid S4 class corresponding to S3 class: slots in  S4 version must extend corresponding slots in S3 version: fails for %s"
msgstr "Unzulässige S4 Klasse korrespondiert mit S3 Klasse: Slots in der S4 Version müssen entsprechende Slots in der S3 Version erweitern; schlägt fehl für %s"

#. R/Methods.R: gettextf("invalid argument 'name': %s", .isSingleName(name))
#: R/Methods.R:0
msgid "invalid argument 'name': %s"
msgstr "unzulässiges Argument 'name': %s"

#. R/refClass.R: gettextf("invalid assignment for reference class field %s, should be from class %s or a subclass (was class %s)",     sQuote(fieldName), dQuote(fieldClass), dQuote(class(value)))
#: R/refClass.R:0
msgid "invalid assignment for reference class field %s, should be from class %s or a subclass (was class %s)"
msgstr "unzulässige Zuweiwsung für Referenzklassenfeld %s, sollte aus Klasse %s oder eine Subklasse sein (war Klasse %s)"

#. R/show.R: gettextf("invalid call to 'classLabel': expected a name or a class definition, got an object of class %s",     classLabel(class(Class)))
#: R/show.R:0
msgid "invalid call to 'classLabel': expected a name or a class definition, got an object of class %s"
msgstr "ungültiger Aufruf von 'classLabel': erwartete einen Namen oder eine Klassendefiniton, bekam ein Objekt der Klasse %s"

#. R/SClasses.R: gettextf("invalid class %s object", dQuote(Class))
#: R/SClasses.R:0
msgid "invalid class %s object"
msgstr "ungültiges Objekt der Klasse %s"

#. R/MethodsList.R: gettextf("invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name",     i)
#: R/MethodsList.R:0
msgid "invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name"
msgstr "unzlässiges Element in einer Liste für das \"signature\" Argument; Element %d ist weder eine Klassendefinition noch ein Klassenname"

#. R/RMethodUtils.R: gettextf("invalid element in the \"groupMembers\" slot (class %s)",     dQuote(class(x)))
#: R/RMethodUtils.R:0
msgid "invalid element in the \"groupMembers\" slot (class %s)"
msgstr "unzulässiges Element im \"groupMembers\" Slot (Klasse %s)"

#. R/MethodsList.R: stop("invalid first argument: should be the name of the first argument in the dispatch")
#: R/MethodsList.R:0
msgid "invalid first argument: should be the name of the first argument in the dispatch"
msgstr "unzulässiges erstes Argument: sollte der Name des ersten Arguments im Dispatch sein"

#. R/methodsTable.R: gettextf("invalid group generic function in search for inherited method (class %s)",     dQuote(class(gen)))
#: R/methodsTable.R:0
msgid "invalid group generic function in search for inherited method (class %s)"
msgstr "ungültige gruppengenerische Funktion bei der Suche nach der vererbten Methode (Klasse %s)"

#. R/languageEl.R: stop("invalid index for function argument")
#: R/languageEl.R:0
msgid "invalid index for function argument"
msgstr "unzulässiger Index für Funktionsargument"

#. R/Methods.R: gettextf("invalid method definition: expected a function, got an object of class %s",     dQuote(class(definition)))
#: R/Methods.R:0
msgid "invalid method definition: expected a function, got an object of class %s"
msgstr "ungültie Methodendefinition; Funktion erwartet, Objekt der Klasse %s bekommen"

#. R/methodsTable.R: gettextf("invalid method element for signature %s at level %d (should be MethodDefinition or .Primitive, had class %s)",     sQuote(classes[[j]]), i, dQuote(class(el)))
#: R/methodsTable.R:0
#, fuzzy
msgid "invalid method element for signature %s at level %d (should be MethodDefinition or .Primitive, had class %s)"
msgstr "ungültiges mlist Element für die Signatur %s auf Stufe %d (sollte MethodDefinition oder .Primitive sein, hat Klasse %s)"

#. R/methodsTable.R: stop("invalid methods table request")
#: R/methodsTable.R:0
msgid "invalid methods table request"
msgstr "unzulässige Methodentabellenanfrage"

#. R/MethodsListClass.R: gettextf("invalid object for formal method definition: type %s",     dQuote(typeof(def)))
#: R/MethodsListClass.R:0
msgid "invalid object for formal method definition: type %s"
msgstr "unzulässiges Objekt für die formale Methodendefinition: Typ %s"

#. R/methodsTable.R: gettextf("invalid object in meta table of methods for %s, label %s, had class %s",     sQuote(generic@generic), sQuote(what), dQuote(class(obj)))
#: R/methodsTable.R:0
msgid "invalid object in meta table of methods for %s, label %s, had class %s"
msgstr "ungültiges Objekt im Metatable der Methoden für %s, Label %s, hatte Klasse %s"

#. R/methodsTable.R: gettextf("invalid object in methods table (%s), expected a method, got an object of class %s",     sQuote(what), dQuote(class(method)))
#: R/methodsTable.R:0
msgid "invalid object in methods table (%s), expected a method, got an object of class %s"
msgstr "ungültiges Objekt in der Methodentabelle (%s), Methode war erwartet, bekam Objekt der Klasse %s"

#. R/methodsTable.R: gettextf("invalid or unset methods table in generic function %s",     sQuote(fdef@generic))
#: R/methodsTable.R:0
msgid "invalid or unset methods table in generic function %s"
msgstr "ungültige oder zurückgesetzte Methodentabelle in generischer Funktion %s"

#. R/refClass.R: gettextf("invalid replacement: reference class field %s is read-only",     sQuote(fieldName))
#: R/refClass.R:0
msgid "invalid replacement: reference class field %s is read-only"
msgstr "ungültige Ersetzung: Referenzklassenfeld %s ist nur lesbar"

#. R/RMethodUtils.R: gettextf("invalid value from generic function %s, class %s, expected %s",     sQuote(fname), dQuote(class(object)), paste(dQuote(classes),         collapse = " or "))
#: R/RMethodUtils.R:0
msgid "invalid value from generic function %s, class %s, expected %s"
msgstr "unzulässiger Wert aus der generischen Funktion %s, Klasse %s, erwartet war %s"

#. R/refClass.R: gettextf("local assignment to field name will not change the field:\n    %s\n Did you mean to use \"<<-\"? ( in method %s for class %s)",     paste(unlist(assigned$locals)[localsAreFields], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"local assignment to field name will not change the field:\n"
"    %s\n"
" Did you mean to use \"<<-\"? ( in method %s for class %s)"
msgstr ""
"lokale Zuweisung zu einem Feldnamen ändert nicht das Feld:\n"
"    %s\n"
"War eigentlich \"<<-\" gemeint? (in Methode %s für Klasse %s)"

#. R/RMethodUtils.R: gettextf("making a generic for special function %s", sQuote(f))
#: R/RMethodUtils.R:0
msgid "making a generic for special function %s"
msgstr "erzeuge eine Generische für die spezielle Funktion %s"

#. R/trace.R: warning("making a traced version of a special; arguments may be altered")
#: R/trace.R:0
msgid "making a traced version of a special; arguments may be altered"
msgstr "erzeuge verfolgte Version einer Speziellen; Argumente werden evtl. verändert"

#. R/debug.R: warning("method is not being debugged")
#: R/debug.R:0
msgid "method is not being debugged"
msgstr "Methode wird nicht ge-debugged"

#. R/RMethodUtils.R: gettextf("methods can add arguments to the generic %s only if '...' is an argument to the generic",     sQuote(generic@generic))
#: R/RMethodUtils.R:0
msgid "methods can add arguments to the generic %s only if '...' is an argument to the generic"
msgstr "Methoden können nur Argumente zur generischen %s hinzufügen, wenn '...' ein Argument ebendieser ist"

#. R/as.R: gettextf("methods currently exist for coercing from %s to %s; they will be replaced.",     dQuote(from), dQuote(to))
#: R/as.R:0
msgid "methods currently exist for coercing from %s to %s; they will be replaced."
msgstr "momentan existieren Methoden zur Umwandlung von %s nach %s; diese werden ersetzt"

#. R/refClass.R: gettextf("methods declared in usingMethods() but not found: %s",     paste0(declared[!declared %in% allMethods], collapse = ", "))
#: R/refClass.R:0
msgid "methods declared in usingMethods() but not found: %s"
msgstr "Methoden deklariert in usingMethods() aber nicht gefunden: %s"

#. R/BasicFunsList.R: gettextf("methods may not be defined for primitive function %s in this version of R",     sQuote(f))
#: R/BasicFunsList.R:0
msgid "methods may not be defined for primitive function %s in this version of R"
msgstr "in dieser Version von R dürfen keine Methoden für die primitive Funktion %s definiert werden"

#. R/Defunct.R: stop("methods:::bind_activation() is defunct;\n rather provide methods for cbind2() / rbind2()")
#: R/Defunct.R:0
msgid ""
"methods:::bind_activation() is defunct;\n"
" rather provide methods for cbind2() / rbind2()"
msgstr ""
"methods:::bind_activation() funktioniert nicht mehr;\n"
" besser Methoden für cbind2()/rbind2() bereit stellen"

#. R/RMethodUtils.R: gettextf("missing function for load action: %s", what)
#: R/RMethodUtils.R:0
msgid "missing function for load action: %s"
msgstr "fehlende Funktion für Ladeaktion: %s"

#. R/MethodsListClass.R: gettextf("missing package slot (%s) in object of class %s (package info added)",     packageSlot(co), dQuote(class(.Object)))
#: R/MethodsListClass.R:0
msgid "missing package slot (%s) in object of class %s (package info added)"
msgstr "fehlender Paketslot (%s) in Objekt der Klasse %s (Paketinformation hinzugefügt)"

#. R/MethodsList.R: gettextf("more elements in the method signature (%d) than in the generic signature (%d) for function %s",     length(signature), length(anames), sQuote(fun@generic))
#: R/MethodsList.R:0
msgid "more elements in the method signature (%d) than in the generic signature (%d) for function %s"
msgstr "mehr Elemente in der Methodensignatur (%d) als in der generischen Signatur (%d) für Funktion %s"

#. R/RClassUtils.R: gettextf("more than one possible class for the data part: using %s rather than %s",     .dQ(prevDataPartClass), .dQ(value))
#: R/RClassUtils.R:0
msgid "more than one possible class for the data part: using %s rather than %s"
msgstr "mehr als eine mögliche Klasse für den Datenteil: nutze %s statt %s"

#. R/zzz.R: warning("apparently bad method or class metadata in saved environment;\n",     "move the file or remove the class/method")
#: R/zzz.R:0
msgid "move the file or remove the class/method"
msgstr "verschiebe die Datei oder entferne die Klasse/Methode"

#. R/SClasses.R: gettextf("multiple class definitions for %s from packages: %s; picking the first",     dQuote(className), paste(sQuote(pkgs), collapse = ", "))
#: R/SClasses.R:0
msgid "multiple class definitions for %s from packages: %s; picking the first"
msgstr "mehrere Klassendefinitionen für %s aus den Paketen: %s; nehme die erste"

#. R/RMethodUtils.R: gettextf("multiple definitions exist for class %s, but the supplied package (%s) is not one of them (%s)",     dQuote(classi), sQuote(pkgi), paste(dQuote(get(classi, envir = .classTable)),         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "multiple definitions exist for class %s, but the supplied package (%s) is not one of them (%s)"
msgstr "Mehrfache Definitionen existieren für Klasse %s, aber das angegebene Paket (%s) ist keins davon (%s)"

#. R/RMethodUtils.R: gettextf("multiple definitions exist for class %s; should specify one of them (%s), e.g. by className()",     dQuote(classi), paste(dQuote(get(classi, envir = .classTable)),         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "multiple definitions exist for class %s; should specify one of them (%s), e.g. by className()"
msgstr "es existieren mehrere Definitionen für die Klasse %s; z.B. durch className() sollte eine von diesen (%s) spezifiziert werden"

#. R/promptClass.R: gettextf("multiple definitions of %s found; using the one on %s",     dQuote(clName), whereClass)
#: R/promptClass.R:0
msgid "multiple definitions of %s found; using the one on %s"
msgstr "mehrfache Definitionen von %s gefunden; benutze die auf %s"

#. R/RMethodUtils.R: gettextf("multiple direct matches: %s; using the first of these",     .pasteC(classes))
#: R/RMethodUtils.R:0
msgid "multiple direct matches: %s; using the first of these"
msgstr "mehrfache direkte Übereinstimmungen: %s; nutze die erste von diesen"

#. R/RMethodUtils.R: gettextf("multiple equivalent inherited matches: %s; using the first of these",     .pasteC(classes))
#: R/RMethodUtils.R:0
msgid "multiple equivalent inherited matches: %s; using the first of these"
msgstr "mehrfache äquivalente, vererbte Übereinstimmungen: %s; nutze die erste von diesen"

#. R/trace.R: gettextf("multiple generics match pattern, using table %s", table)
#: R/trace.R:0
msgid "multiple generics match pattern, using table %s"
msgstr "mehrere Generische passen zum Muster, nutze Tabelle %s"

#. R/Methods.R: gettextf("must provide an environment table; got class %s", dQuote(class(what)))
#: R/Methods.R:0
msgid "must provide an environment table; got class %s"
msgstr "es muss eine Umgebungstabelle angegeben werden; bekam Klasse %s"

#. R/Methods.R: stop("must supply 'generic.function' or 'class'")
#: R/Methods.R:0
msgid "must supply 'generic.function' or 'class'"
msgstr "entweder eine 'generic.function' oder eine 'class' muss angegeben werden"

#. R/Methods.R: gettextf("must supply a function skeleton for %s, explicitly or via an existing function",     sQuote(name))
#: R/Methods.R:0
msgid "must supply a function skeleton for %s, explicitly or via an existing function"
msgstr "es muss ein Funktionsskelett für %s angegeben werden, entweder explizit oder über eine existierende Funktion"

#. R/RMethodUtils.R: gettextf("must supply either a generic function or a function as default for %s",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "must supply either a generic function or a function as default for %s"
msgstr "Enweder eine generische Funktion oder eine Standardfunktion muss für %s angegeben werden"

#. R/method.skeleton.R: stop("need a definition for the method here")
#: R/method.skeleton.R:0
msgid "need a definition for the method here"
msgstr "benötige hier eine Definition für die Methode"

#. R/RClassUtils.R: gettextf("needed the supplied labels vector of length %d, got %d",     length(nodes), length(short))
#: R/RClassUtils.R:0
msgid "needed the supplied labels vector of length %d, got %d"
msgstr "benötige einen Label-Vektor der Länge %d, bekam %d"

#. R/RClassUtils.R: gettextf("no '.Data' slot defined for class %s", dQuote(class(object)))
#: R/RClassUtils.R:0
msgid "no '.Data' slot defined for class %s"
msgstr "kein '.Data'-Slot für Klasse %s definiert"

#. R/ClassExtensions.R: gettextf("no 'replace' method was defined for 'as(x, \"%s\") <- value' for class %s",     to, dQuote(class(from)))
#: R/ClassExtensions.R:0
msgid "no 'replace' method was defined for 'as(x, \"%s\") <- value' for class %s"
msgstr "keine 'replace' Methode definiert für 'as(x, \"%s\") <- value' für Klasse %s"

#. R/trace.R: gettextf("no definition for object %s found in tracing environment",     sQuote(what))
#: R/trace.R:0
msgid "no definition for object %s found in tracing environment"
msgstr "keine Definition für das Objekt %s in der Verfolgungsumgebung gefunden"

#. R/fixPrevious.R: gettextf("no definition for the class of %s (class %s) found",     sQuote(what), dQuote(class))
#: R/fixPrevious.R:0
msgid "no definition for the class of %s (class %s) found"
msgstr "keine Definition für die Klasse von %s (Klasse %s) gefunden"

#. R/RMethodUtils.R: gettextf("no definition found for class %s", dQuote(classi))
#: R/RMethodUtils.R:0
msgid "no definition found for class %s"
msgstr "keine Definition der Klasse %s gefunden"

#. R/refClass.R: gettextf("no definition found for inherited class: %s", paste0("\"",     contains[missingDefs], "\"", collapse = ", "))
#: R/refClass.R:0
msgid "no definition found for inherited class: %s"
msgstr "keine Definition der geerbten Klasse %s gefunden"

#. R/SClasses.R: gettextf("no definition of %s to use for %s", dQuote(Class),     unique)
#: R/SClasses.R:0
msgid "no definition of %s to use for %s"
msgstr "keine Definition von %s, die für %s genutzt werden kann"

#. R/promptClass.R: gettextf("no definition of class %s found", dQuote(clName))
#: R/promptClass.R:0
msgid "no definition of class %s found"
msgstr "keine Definition der Klasse %s gefunden"

#. R/RClassUtils.R: gettextf("no definition of inheritance from %s to %s, though the relation was implied by the setIs() from %s",     .dQ(what), .dQ(def2@className), .dQ(class))
#: R/RClassUtils.R:0
msgid "no definition of inheritance from %s to %s, though the relation was implied by the setIs() from %s"
msgstr "Keine Definition der Vererbung von %s nach %s; aber die Relation wurde von setIs() aus \"%s\" impliziert"

#. R/RClassUtils.R: gettextf("no definition was found for superclass %s in the specification of class %s",     dQuote(cl), dQuote(name))
#: R/RClassUtils.R:0
msgid "no definition was found for superclass %s in the specification of class %s"
msgstr "keine Definition für Superklasse %s in der Spezifikation der Klasse %s gefunden"

#. R/Methods.R: gettextf("no environment or package corresponding to argument where=%s",     deparse(where))
#: R/Methods.R:0
msgid "no environment or package corresponding to argument where=%s"
msgstr "keine Umgebung und kein Paket korrespondieren zum Argument where=%s"

#. R/Methods.R: gettextf("no existing definition for function %s", sQuote(f))
#: R/Methods.R:0
msgid "no existing definition for function %s"
msgstr "keine exisitierende Definition für Funktion %s"

#. R/addedFunctions.R: gettextf("no function %s found", sQuote(name))
#: R/addedFunctions.R:0
msgid "no function %s found"
msgstr "keine Funktion %s gefunden"

#. R/trace.R: gettextf("no function definition for %s found", sQuote(what))
#: R/trace.R:0
msgid "no function definition for %s found"
msgstr "keine Funktionsdefinition für %s gefunden"

#. R/method.skeleton.R: gettextf("no function definition found for %s", sQuote(generic))
#: R/method.skeleton.R:0
msgid "no function definition found for %s"
msgstr "keine Funktionsdefinition für %s gefunden"

#. R/Methods.R: gettextf("no generic function %s found", sQuote(f))
#. R/Methods.R: gettextf("no generic function %s found", sQuote(f))
#. R/Methods.R: gettextf("no generic function %s found", sQuote(f))
#: R/Methods.R:0
msgid "no generic function %s found"
msgstr "keine generische Funktion %s gefunden"

#. R/MethodsList.R: gettextf("no generic function found corresponding to %s", sQuote(f))
#: R/MethodsList.R:0
msgid "no generic function found corresponding to %s"
msgstr "keine generische Funktion korrespondierend mit %s gefunden"

#. R/RMethodUtils.R: gettextf("no generic function found for %s", sQuote(f))
#: R/RMethodUtils.R:0
msgid "no generic function found for %s"
msgstr "keine generische Funktion für %s gefunden"

#. R/Methods.R: gettextf("no generic function found for '%s'", f)
#: R/Methods.R:0
msgid "no generic function found for '%s'"
msgstr "keine generische Funktion für '%s' gefunden"

#. R/Methods.R: gettextf("no generic version of %s on package %s is allowed;\n   a new generic will be assigned for %s",     sQuote(name), sQuote(package), thisPName)
#: R/Methods.R:0
msgid ""
"no generic version of %s on package %s is allowed;\n"
"   a new generic will be assigned for %s"
msgstr ""
"generische Version von %s für Paket %s ist nicht erlaubt; \n"
"  eine neue Generische wird für %s zugewiesen"

#. R/Methods.R: gettextf("no method for %s matches class %s", sQuote("..."),     dQuote(signature))
#: R/Methods.R:0
msgid "no method for %s matches class %s"
msgstr "keine Methode für %s passt auf Klasse %s"

#. R/Methods.R: gettextf("no method found for function %s and signature %s",     sQuote(fdef@generic), paste(.dQ(signature), collapse = ", "))
#: R/Methods.R:0
msgid "no method found for function %s and signature %s"
msgstr "keine Methode für Funktion %s und Signatur %s gefunden"

#. R/Methods.R: gettextf("no method found for function '%s' and signature %s",     f, paste(signature, collapse = ", "))
#: R/Methods.R:0
msgid "no method found for function '%s' and signature %s"
msgstr "Keine Methode für Funktion '%s' und Signatur %s gefunden"

#. R/Methods.R: gettextf("no method found for signature %s", paste(signature,     collapse = ", "))
#: R/Methods.R:0
msgid "no method found for signature %s"
msgstr "keine Methode für Signatur %s gefunden"

#. R/trace.R: gettextf("no method in methods table for %s for signature %s",     sQuote(what), sQuote(signature))
#: R/trace.R:0
msgid "no method in methods table for %s for signature %s"
msgstr "keine Methode in der Methodentabelle für %s für Signatur %s"

#. R/as.R: gettextf("no method or default for as() replacement of %s with Class=\"%s\"",     dQuote(thisClass), Class)
#: R/as.R:0
msgid "no method or default for as() replacement of %s with Class=\"%s\""
msgstr "keine Methode und kein Standard für einen Ersatz mit as() von %s mit Class=\"%s\""

#. R/as.R: gettextf("no method or default for coercing %s to %s", dQuote(thisClass),     dQuote(Class))
#: R/as.R:0
msgid "no method or default for coercing %s to %s"
msgstr "keine Methode und kein Standard um %s in %s umzuwandeln"

#. R/RMethodUtils.R: gettextf("no method or default matching the \"...\" arguments in %s",     deparse(sys.call(sys.parent()), nlines = 1))
#: R/RMethodUtils.R:0
msgid "no method or default matching the \"...\" arguments in %s"
msgstr "keine Methode und kein Standard passen auf  \"...\" in %s"

#. R/RMethodUtils.R: gettextf("no methods found for %s; cacheGenericsMetaData() will have no effect",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "no methods found for %s; cacheGenericsMetaData() will have no effect"
msgstr "keine Methoden für %s gefunden; cacheGenericMetaData() wird keinen Effekt haben"

#. R/methodsTable.R: gettextf("no methods table for generic %s from package %s in package %s",     sQuote(generic@generic), sQuote(generic@package), sQuote(getPackageName(where)))
#: R/methodsTable.R:0
msgid "no methods table for generic %s from package %s in package %s"
msgstr "keine Methodentabelle für generische %s aus Paket %s in Paket %s"

#. R/addedFunctions.R: gettextf("no non-generic function %s found", sQuote(name))
#: R/addedFunctions.R:0
msgid "no non-generic function %s found"
msgstr "keine nicht-generische Funktion %s gefunden"

#. R/SClasses.R: gettextf("no package name supplied and no class definition found for %s",     dQuote(className))
#: R/SClasses.R:0
msgid "no package name supplied and no class definition found for %s"
msgstr "kein Name angegeben und keine Klassendefinition für %s gefunden"

#. R/RMethodUtils.R: stop("no suitable arguments to dispatch methods in this function")
#. R/RMethodUtils.R: stop("no suitable arguments to dispatch methods in this function")
#: R/RMethodUtils.R:0
msgid "no suitable arguments to dispatch methods in this function"
msgstr "keine passenden Argumende für Methodendispatch in dieser Funktion"

#. R/RMethodUtils.R: gettext("non-empty string; got \"\"")
#: R/RMethodUtils.R:0
msgid "non-empty string; got \"\""
msgstr ""

#. R/RMethodUtils.R: gettextf("non-function action: %s", sQuote(fname))
#: R/RMethodUtils.R:0
msgid "non-function action: %s"
msgstr "nicht-funktions Aktion: %s"

#. R/Methods.R: gettextf("non-generic function '%s' given to findMethods()",     f)
#: R/Methods.R:0
msgid "non-generic function '%s' given to findMethods()"
msgstr "nicht-generische Funktion '%s' an findMethods() übergeben"

#. R/refClass.R: gettextf("non-local assignment to method names is not allowed\n    %s\n( in method %s for class %s)",     paste(unlist(assigned$globals)[globalsInMethods], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"non-local assignment to method names is not allowed\n"
"    %s\n"
"( in method %s for class %s)"
msgstr ""
"nicht-lokale Zuweisung an Methodennamen nicht zulässig\n"
"    %s\n"
"(in Methode %s für Klasse %s)"

#. R/refClass.R: gettextf("non-local assignment to non-field names (possibly misspelled?)\n    %s\n( in method %s for class %s)",     paste(unlist(assigned$globals)[globalsNotFields], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"non-local assignment to non-field names (possibly misspelled?)\n"
"    %s\n"
"( in method %s for class %s)"
msgstr ""
"nicht-lokale Zuweisung zu einem nicht-Feldnamen (evtl. vertippt?)\n"
"    %s\n"
"(in Methode %s für Klasse %s)"

#. R/trace.R: stop("none of the objects in the source code could be found:  need to attach or specify the package")
#: R/trace.R:0
msgid "none of the objects in the source code could be found:  need to attach or specify the package"
msgstr "keines der Objekte aus dem Quelltext konnte gefunden werden; entweder muss das Paket attached oder zumindest spezifiziert werden"

#. R/refClass.R: gettextf("not a reference class: %s", ClassDef@name)
#. R/refClass.R: gettextf("not a reference class: %s", ClassDef@name)
#: R/refClass.R:0
msgid "not a reference class: %s"
msgstr "keine Referenzklasse: %s"

#. R/oldClass.R: stop("not allowed to have test==TRUE and an S4Class definition")
#: R/oldClass.R:0
msgid "not allowed to have test==TRUE and an S4Class definition"
msgstr "test == TRUE und S4Class Definition nicht gleichzeitig zulässig"

#. R/Methods.R: gettext("not both functions!")
#: R/Methods.R:0
msgid "not both functions!"
msgstr "nicht beide Funktionen!"

#. R/fixPrevious.R: gettextf("object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)",     sQuote(what))
#: R/fixPrevious.R:0
msgid "object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)"
msgstr "Objekt %s nicht verändert (scheint nicht aus einer R Version vor 1.8.0 zu stammen)"

#. R/fixPrevious.R: gettextf("object %s not changed (it is not consistent with the current definition of class %s from %s)",     sQuote(what), dQuote(Class), sQuote(ClassDef@package))
#: R/fixPrevious.R:0
msgid "object %s not changed (it is not consistent with the current definition of class %s from %s)"
msgstr "Objekt %s nicht verändert (nicht konsistent mit der aktuellen Definition von Klasse %s aus %s)"

#. R/fixPrevious.R: gettextf("object %s not found", sQuote(what))
#: R/fixPrevious.R:0
msgid "object %s not found"
msgstr "Objekt %s nicht gefunden"

#. R/BasicClasses.R: gettextf("object must be a valid data part for class %s; not true of type %s",     dQuote(cl), dQuote(class(data)))
#: R/BasicClasses.R:0
msgid "object must be a valid data part for class %s; not true of type %s"
msgstr "Objekt muss ein gültiger Datenteil der Klasse %s sein; gilt nicht für den Typ %s"

#. R/MethodsList.R: gettextf("object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object",     sQuote(fun@generic), length(sigClasses), length(signature))
#: R/MethodsList.R:0
msgid "object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object"
msgstr "Objekt, welches als Methodensignatur für Funktion %s genutzt werden soll, sieht nicht wie eine zulässige Signatur (Vektor von einzelnen Klassennamen) aus; es gab %d Klassennamen, aber %d Elemente im Signaturobjekt"

#. R/trace.R: gettextf("objects found in multiple packages: using %s and ignoring %s",     sQuote(names(possible[[1L]])), paste(sQuote(names(possible[-1L])),         collapse = ", "))
#: R/trace.R:0
msgid "objects found in multiple packages: using %s and ignoring %s"
msgstr "Objekte in mehreren Paketen gefunden: nutze %s, ignoriere %s"

#. R/Methods.R: gettextf("only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)",     inherited)
#: R/Methods.R:0
msgid "only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)"
msgstr "nur FALSE sinnvoll für 'inherited', wenn 'where' angegeben wurde (bekam %s)"

#. R/SClasses.R: stop("only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object")
#: R/SClasses.R:0
msgid "only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object"
msgstr "nur die Argumente 'Class' und 'where' können angegeben werden, wenn das Argument 'representation' vom Typ 'classRepresentation' ist"

#. R/SClasses.R: stop("only one data object (unnamed argument to prototype) allowed")
#: R/SClasses.R:0
msgid "only one data object (unnamed argument to prototype) allowed"
msgstr "nur ein Datenobjekt (namenloses Argument für Prototypen) erlaubt"

#. R/Methods.R: gettext("original function is prohibited as a generic function")
#: R/Methods.R:0
msgid "original function is prohibited as a generic function"
msgstr "Originalfunktion ist als generische Funktion verboten"

#. R/trace.R: gettextf("package %s is not attached and no namespace found for it",     sQuote(package))
#: R/trace.R:0
msgid "package %s is not attached and no namespace found for it"
msgstr "Paket %s ist nicht attached und kein Namensraum für das Paket gefunden"

#. R/Methods.R: gettextf("package slots  differ: %s, %s", .dQ(gpString(f1@package)),     .dQ(gpString(f2@package)))
#: R/Methods.R:0
msgid "package slots  differ: %s, %s"
msgstr "Paket-Slots unterscheiden sich: %s, %s"

#. R/RClassUtils.R: gettextf("potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)",     dQuote(Class), paste(bad, collapse = ", "))
#: R/RClassUtils.R:0
msgid "potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)"
msgstr "potenzieller Zyklus bei der Klassenvererbung: %s hat Duplikate in Super- und Subklassen (%s)"

#. R/Methods.R: stop("primitive functions cannot be methods; they must be enclosed in a regular function")
#: R/Methods.R:0
msgid "primitive functions cannot be methods; they must be enclosed in a regular function"
msgstr "primitive Funktionen können keine Methoden sein; sie müssen in reguläre Funktionen eingeschlossen sein"

#. R/RClassUtils.R: warning("prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble.")
#: R/RClassUtils.R:0
msgid "prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble."
msgstr "Prototyp ist eine Liste mit benannten Elementen (könnte zweideutig sein): sicherheitshalber lieber die Funktion prototype() nutzen"

#. R/ClassExtensions.R: gettextf("replacement value must be of class %s, got one of class %s",     dQuote(CLASS), dQuote(class(value)[[1L]]))
#: R/ClassExtensions.R:0
msgid "replacement value must be of class %s, got one of class %s"
msgstr "Ersetzung muss aus Klasse %s sein, bekam eine aus Klasse %s"

#. R/ClassExtensions.R: gettextf("replacement value must extend class %s, got %s", dQuote(needClass),     dQuote(S3Class[[1L]]))
#: R/ClassExtensions.R:0
msgid "replacement value must extend class %s, got %s"
msgstr "Ersetzung muss die Klasse %s erweitern, bekam %s"

#. R/oldClass.R: gettextf("restoring definition of class %s", dQuote(cl))
#: R/oldClass.R:0
msgid "restoring definition of class %s"
msgstr "Wiederherstellung der Definition der Klasse %s"

#. R/trace.R: gettextf("setting a method over the binding of symbol %s in environment/package %s",     sQuote(what), sQuote(getPackageName(where)))
#: R/trace.R:0
msgid "setting a method over the binding of symbol %s in environment/package %s"
msgstr "Setzen einer Methode über die Bindung des Symbols %s in der Umgebung / im Paket %s"

#. R/Methods.R: gettextf("signatures differ:  (%s), (%s)", paste(f1@signature,     collapse = ", "), paste(f2@signature, collapse = ", "))
#: R/Methods.R:0
msgid "signatures differ:  (%s), (%s)"
msgstr "Signaturen unterscheiden sich: (%s), (%s)"

#. R/RMethodUtils.R: gettextf("single string; got a character vector of length %s",     length(what))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "single string; got a character vector of length %s"
msgstr "einzelne Zeichenkette; bekam Objekt der Klasse %s"

#. R/RMethodUtils.R: gettextf("single string; got an object of class %s", dQuote(class(what)[[1L]]))
#: R/RMethodUtils.R:0
msgid "single string; got an object of class %s"
msgstr "einzelne Zeichenkette; bekam Objekt der Klasse %s"

#. R/oldClass.R: gettextf("slot %s: class %s should extend class %s", sQuote(what),     dQuote(slots1[[what]]), dQuote(slots2[[what]]))
#: R/oldClass.R:0
msgid "slot %s: class %s should extend class %s"
msgstr "Slot %s: Klasse %s sollte Klasse %s erweitern"

#. R/RMethodUtils.R: gettextf("some actions are missing: %s", paste(actions[!allExists],     collapse = ", "))
#: R/RMethodUtils.R:0
msgid "some actions are missing: %s"
msgstr "einige Aktionen fehlen: %s"

#. R/trace.R: gettextf("supplied package, %s, differs from package inferred from source, %s",     sQuote(package), sQuote(envPackage))
#: R/trace.R:0
msgid "supplied package, %s, differs from package inferred from source, %s"
msgstr "das angegebene Paket, %s, unterscheidet sich vom Paket aus den Sourcen, %s"

#. R/methodsTable.R: gettextf("the \"ambiguousMethodSelection\" option should be a function to be called as the condition action; got an object of class %s",     dQuote(class(condAction)))
#: R/methodsTable.R:0
msgid "the \"ambiguousMethodSelection\" option should be a function to be called as the condition action; got an object of class %s"
msgstr "die Option \"ambiguousMethodSelection\" sollte eine Funktion sein, die bei Bedarf aufgerufen wird; bekam Objekt der Klasse %s"

#. R/RMethodUtils.R: gettextf("the %s argument must be NULL or a generic function object; got an object of class %s",     sQuote("genericFunction"), dQuote(class(genericFunction)))
#: R/RMethodUtils.R:0
msgid "the %s argument must be NULL or a generic function object; got an object of class %s"
msgstr "das Argument %s muss NULL oder ein generisches Funktionsobjekt sein; bekam Objekt der Klasse %s"

#. R/RClassUtils.R: gettextf("the '%s' list for class %s, includes an undefined class %s",     if (superClassCase) "superClass" else "subClass", dQuote(className),     dQuote(.className(by)))
#: R/RClassUtils.R:0
msgid "the '%s' list for class %s, includes an undefined class %s"
msgstr "die '%s' Liste für Klasse %s enhält eine undefinierte Klasse %s"

#. R/ClassExtensions.R: gettextf("the 'S3Class' argument must be a superclass of %s:  not true of class %s",     dQuote(class(object)), dQuote(S3Class))
#: R/ClassExtensions.R:0
msgid "the 'S3Class' argument must be a superclass of %s:  not true of class %s"
msgstr "das 'S3Class' Argument muss eine Superklasse von %s sein: gilt nicht für Klasse %s"

#. R/ClassExtensions.R: gettextf("the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s",     dQuote(class(coerce)))
#: R/ClassExtensions.R:0
msgid "the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s"
msgstr "das 'coerce' Argument für 'setIs' sollte Funktion eines Argumentes sein, bekam Objekt der Klasse %s"

#. R/refClass.R: gettextf("the 'contains' argument should be the names of superclasses:  got an element of class %s",     dQuote(class(what)))
#: R/refClass.R:0
msgid "the 'contains' argument should be the names of superclasses:  got an element of class %s"
msgstr "Das 'contains' Argument sollten Namen von Superklassen sein: bekam Element der Klasse %s"

#. R/ClassExtensions.R: gettextf("the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s",     dQuote(class(replace)))
#: R/ClassExtensions.R:0
msgid "the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s"
msgstr "das 'replace' Argument für setIs() sollte Funktion von 2 oder 3 Argumenten sein, bekam ein Objekt der Klasse %s"

#. R/Methods.R: gettextf("the 'where' environment (%s) is a locked namespace; cannot assign methods there",     getPackageName(where))
#: R/Methods.R:0
msgid "the 'where' environment (%s) is a locked namespace; cannot assign methods there"
msgstr "die 'where' Umgebung (%s) ist ein gesicherter Namensraum; kann dort keine Methoden zuweisen"

#. R/oldClass.R: gettextf("the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")",     .class1(prototype), mainClass)
#: R/oldClass.R:0
msgid "the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")"
msgstr "S3 Klasse des Prototyps \"%s\" ist undefiniert; nur zulässig, wenn diese S3 Klasse registriert wird (\"%s\")"

#. R/RMethodUtils.R: gettextf("the body of the generic function for %s calls 'standardGeneric' to dispatch on a different name (\"%s\")!",     sQuote(fname), paste(as.character(x[[2L]]), collapse = "\n"))
#: R/RMethodUtils.R:0
msgid "the body of the generic function for %s calls 'standardGeneric' to dispatch on a different name (\"%s\")!"
msgstr "Der Funktionsbody der generischen Funktion für %s ruft 'standardGeneric' auf, um in einen anderen Namen (\"%s\") zu dispatchen!"

#. R/refClass.R: gettextf("the class of field %s in the object is not compatible with the desired class %s in the target",     sQuote(field), dQuote(fieldClasses[[field]]))
#. R/refClass.R: gettextf("the class of field %s in the object is not compatible with the desired class %s in the target",     sQuote(field), dQuote(fieldClasses[[field]]))
#: R/refClass.R:0
msgid "the class of field %s in the object is not compatible with the desired class %s in the target"
msgstr "Klasse des Feldes %s im Objekt ist nicht kompatibel mit der gewünschten Klasse %s im Ziel"

#. R/ClassExtensions.R: gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n",     TO, dQuote(FROM), TO, dQuote(class(value)))
#: R/ClassExtensions.R:0
msgid "the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)"
msgstr "Die Berechnung: 'as(object,\"%s\") <- value' ist nur zulässig für ein Objekt aus der Klasse %s, wenn 'is(value, \"%s\")' TRUE ergibt ('class(value)' war %s)"

#. R/refClass.R: gettextf("the definition of class %s in package %s is locked so fields may not be modified",     dQuote(def@className), sQuote(def@package))
#. R/refClass.R: gettextf("the definition of class %s in package %s is locked so fields may not be modified",     dQuote(def@className), sQuote(def@package))
#: R/refClass.R:0
msgid "the definition of class %s in package %s is locked so fields may not be modified"
msgstr "Definition von Klasse %s in Paket %s ist abgeschlossen, Felder dürfen nicht modifiziert werden"

#. R/refClass.R: gettextf("the definition of class %s in package %s is locked, methods may not be redefined",     dQuote(def@className), sQuote(def@package))
#: R/refClass.R:0
msgid "the definition of class %s in package %s is locked, methods may not be redefined"
msgstr "Definition der Klasse %s in Paket %s ist abgeschlossen, Methoden dürfen nicht umdefiniert werden"

#. R/trace.R: stop("the editing in trace() can only change the body of the function, not the arguments or defaults")
#: R/trace.R:0
msgid "the editing in trace() can only change the body of the function, not the arguments or defaults"
msgstr "Editieren in trace() kann nur den Funktionskörper ändern; nicht die Argumente odr Standardargumente"

#. R/trace.R: gettextf("the editing in trace() can only change the body of the function; got an object of class %s",     dQuote(class(def2)))
#: R/trace.R:0
msgid "the editing in trace() can only change the body of the function; got an object of class %s"
msgstr "Editieren in trace() kann nur den Funktionskörper ändern; bekam Objekt der Klasse %s"

#. R/Methods.R: gettextf("the environment %s is locked; cannot assign methods for function %s",     sQuote(getPackageName(where)), sQuote(f))
#: R/Methods.R:0
msgid "the environment %s is locked; cannot assign methods for function %s"
msgstr "die Umgebung %s ist gesichert; kann keine Methoden für Funktion %s zuweisen"

#. R/RMethodUtils.R: gettextf("the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed",     what, sQuote(f))
#: R/RMethodUtils.R:0
msgid "the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed"
msgstr "die als %s zur Erzeugung einer generischen Funktion %s genutzte Funktion wird momentan verfolgt; die aktuell genutzte Funktion wird die Verfolgung entfernen"

#. R/ClassUnion.R: gettextf("the member classes must be defined: not true of %s",     paste(.dQ(as(members[!membersDefined], "character")), collapse = ", "))
#: R/ClassUnion.R:0
msgid "the member classes must be defined: not true of %s"
msgstr "die Zugehörigkeitsklassen müssen definiert werden: nicht wahr für %s"

#. R/trace.R: gettextf("the method for %s for this signature was not being traced",     sQuote(what))
#: R/trace.R:0
msgid "the method for %s for this signature was not being traced"
msgstr "die Methode für %s für diese Signatur wurde nicht verfolgt"

#. R/Methods.R: gettextf("the method for function %s and signature %s is sealed and cannot be re-defined",     sQuote(f), .signatureString(fdef, signature))
#: R/Methods.R:0
msgid "the method for function %s and signature %s is sealed and cannot be re-defined"
msgstr "die Methode für Funktion %s und Signatur %s ist versiegelt und kann nicht re-definiert werden"

#. R/MethodsListClass.R: gettext("the names in signature for method (%s) do not match %s's arguments (%s)",     domain = "R-methods")
#: R/MethodsListClass.R:0
msgid "the names in signature for method (%s) do not match %s's arguments (%s)"
msgstr "die Namen in der Signatur für die Methode (%s) passen nicht zu den Argumenten von %s (%s)"

#. R/MethodsListClass.R: gettext("the names in signature for method (%s) do not match function's arguments (%s)",     domain = "R-methods")
#: R/MethodsListClass.R:0
msgid "the names in signature for method (%s) do not match function's arguments (%s)"
msgstr ""
"die Namen in der Signatur für die Methode (%s) passen nicht zu den\n"
"Argumenten der Funktion (%s)"

#. R/refClass.R: gettextf("the overriding class (\"%s\") of field %s is not a subclass of the existing field definition (\"%s\")",     value[[field]], sQuote(field), fieldList[[field]])
#: R/refClass.R:0
msgid "the overriding class (\"%s\") of field %s is not a subclass of the existing field definition (\"%s\")"
msgstr ""
"die überschreibende Klasse (\"%s\") des Feldes %s ist keine Subklasse\n"
"der existierenden Felddefinition (\"%s\")"

#. R/ClassExtensions.R: gettextf("there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error",     to, dQuote(Class))
#: R/ClassExtensions.R:0
msgid "there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error"
msgstr ""
"es gibt keine automatische Definition für 'as(object, \"%s\") <- value', \n"
"wenn das Objekt aus der Klasse %s ist und kein 'replace' Argument angegeben wird; Ersetzen wird einen Fehler erzeugen"

#. R/refClass.R: gettextf("topic %s is not a method name in class %s\nThe class definition follows\n",     sQuote(topic), dQuote(className))
#: R/refClass.R:0
msgid ""
"topic %s is not a method name in class %s\n"
"The class definition follows"
msgstr ""
"Punkt %s ist kein Methodenname in der Klasse %s.\n"
"Die Klassendefinition folgt."

#. R/trace.R: gettextf("tracing the internal function %s is not allowed", sQuote(what))
#: R/trace.R:0
msgid "tracing the internal function %s is not allowed"
msgstr "Verfolgen der internen Funktion %s nicht erlaubt"

#. R/RClassUtils.R: gettextf("trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object",     dQuote(class(def)), dQuote(Class))
#: R/RClassUtils.R:0
msgid "trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object"
msgstr "Versuch ein Objekt der Klasse %s als Definition der Klasse %s zuzuweisen: es muss ein \"classRepresentation\"-Objekt angegeben werden"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s in an object of class %s; expected a function definition",     msg, dQuote(class(def)))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s in an object of class %s; expected a function definition"
msgstr "Versuch die formalen Argumente in %s in einem Objekt der Klasse %s zu ändern; erwartet war eine Funktionsdefinition"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but getting the new formals from an object of class %s; expected a function definition",     msg, dQuote(class(def)))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but getting the new formals from an object of class %s; expected a function definition"
msgstr "Versuch die formalen Argumente in %s zu ändern, bekomme aber die neuen Formalen von einem Objekt der Klasse %s; erwartet war eine Funktionsdefinition"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but the number of existing arguments is greater than the number of new arguments (the extra arguments won't be used): (%s) vs (%s)",     msg, paste0("\"", old, "\"", collapse = ", "), paste0("\"",         new, "\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but the number of existing arguments is greater than the number of new arguments (the extra arguments won't be used): (%s) vs (%s)"
msgstr "Versuch die formalen Argumente in %s zu ändern, aber die Zahl der existierenden Argumente ist kleiner als die Zahl der neuen Argumente (zusätzliche Argumente werden nicht genutzt): (%s) vs. (%s)"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but the number of existing arguments is less than the number of new arguments: (%s) vs (%s)",     msg, paste0("\"", old, "\"", collapse = ", "), paste0("\"",         new, "\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but the number of existing arguments is less than the number of new arguments: (%s) vs (%s)"
msgstr "Versuch die formalen Argumente in %s zu ändern, aber die Zahl der existierenden Argumente ist kleiner als die Zahl der neuen Argumente: (%s) vs. (%s)"

#. R/methodsTable.R: gettextf("trying to check signature length of generic '%s', but it is not a generic function: i = %d, funs = %s, gnames = %s",     what, i, paste(unlist(funs), collapse = ", "), paste(as.character(gnames),         collapse = ", "))
#: R/methodsTable.R:0
msgid "trying to check signature length of generic '%s', but it is not a generic function: i = %d, funs = %s, gnames = %s"
msgstr "Versuch der Überprüfung der Signaturlänge der Generischen '%s', ist aber gar keine Generische: i = %d, funs = %s, gnames = %s"

#. R/methodsTable.R: gettextf("trying to check signature length of group generic '%s', but it is not a group generic",     what)
#: R/methodsTable.R:0
msgid "trying to check signature length of group generic '%s', but it is not a group generic"
msgstr "Versuch der Überprüfung der Signaturlänge der Gruppengenerischen '%s', ist aber gar keine Gruppengenerische"

#. R/methodsTable.R: stop("trying to find a methods table in a non-generic function")
#: R/methodsTable.R:0
msgid "trying to find a methods table in a non-generic function"
msgstr "Versuch eine Methodentabelle in einer nicht-generischen Funktion zu finden"

#. R/MethodsList.R: gettextf("trying to match a method signature of class %s; expects a list or a character vector",     dQuote(class(signature)))
#: R/MethodsList.R:0
msgid "trying to match a method signature of class %s; expects a list or a character vector"
msgstr "Versuche eine Methodensignatur mit Klasse %s zu matchen; erwartet eine Liste oder einen Zeichenkettenvektor"

#. R/MethodsList.R: gettextf("trying to match a method signature to an object (of class %s) that is not a generic function",     dQuote(class(fun)))
#: R/MethodsList.R:0
msgid "trying to match a method signature to an object (of class %s) that is not a generic function"
msgstr "Versuch eine Methodensignatur auf ein Objekt (der Klasse %s) zu matchen, das keine generische Funktion ist"

#. R/as.R: gettextf("trying to set an 'as' relation from %s to itself",     dQuote(.class1(from)))
#: R/as.R:0
msgid "trying to set an 'as' relation from %s to itself"
msgstr "Versuch eine 'as' Relation von %s auf sich selbst zu setzen"

#. R/ClassUnion.R: gettextf("unable to create union class:  could not set members %s",     paste(.dQ(failed), collapse = ", "))
#: R/ClassUnion.R:0
msgid "unable to create union class:  could not set members %s"
msgstr "kann Vereinigungsklasse nicht erzeugen: konnte Mitglieder %s nicht setzen"

#. R/RClassUtils.R: gettextf("unable to find a consistent ordering of superclasses for class %s: order chosen is inconsistent with the superclasses of %s",     .dQ(className), paste(.dQ(setdiff(newconflicts, conflicts)),         collapse = ", "))
#: R/RClassUtils.R:0
msgid "unable to find a consistent ordering of superclasses for class %s: order chosen is inconsistent with the superclasses of %s"
msgstr "kann keine konsistente Anordnung der Superklassen der Klasse %s finden: die gewählte Ordnung ist inkonsistent mit den Superklassen von %s"

#. R/RClassUtils.R: gettextf("unable to find an environment containing class %s",     dQuote(Class))
#: R/RClassUtils.R:0
msgid "unable to find an environment containing class %s"
msgstr "kann keine Umgebung mit einer Klasse %s finden"

#. R/methodsTable.R: gettextf("unable to find an inherited method for function %s for signature %s",     sQuote(fdef@generic), sQuote(cnames))
#: R/methodsTable.R:0
msgid "unable to find an inherited method for function %s for signature %s"
msgstr "kann keine vererbte Methode finden für Funktion %s für Signatur %s"

#. R/RClassUtils.R: gettextf("unable to load required package %s", sQuote(package))
#: R/RClassUtils.R:0
#, fuzzy
msgid "unable to load required package %s"
msgstr "kann benötigtes Paket %s nicht finden"

#. R/as.R: stop("undefined 'coerce' method")
#: R/as.R:0
msgid "undefined 'coerce' method"
msgstr "nicht definierte 'coerce'-Methode"

#. R/methodsTable.R: gettextf("undefined classes (%s) will be ignored for argument '%s'",     paste0("\"", unique(.undefClasses), "\"", collapse = ", "),     colnames(sigs)[[j]])
#: R/methodsTable.R:0
msgid "undefined classes (%s) will be ignored for argument '%s'"
msgstr "nicht definierte Klassen (%s) werden für Argument '%s' ignoriert"

#. R/RClassUtils.R: gettext("undefined slot classes in definition of %s: %s", domain = "R-methods")
#: R/RClassUtils.R:0
msgid "undefined slot classes in definition of %s: %s"
msgstr "nicht definierte Slotklassen in der Definition von %s: %s"

#. R/RClassUtils.R: gettextf("undefined subclass %s of class %s; definition not updated",     .dQ(what), .dQ(def@className))
#: R/RClassUtils.R:0
msgid "undefined subclass %s of class %s; definition not updated"
msgstr "Nicht definierte Subklasse %s von Klasse %s; Definition nicht aktualisiert"

#. R/zzz.R: message("unloading 'methods' package ...")
#: R/zzz.R:0
msgid "unloading 'methods' package ..."
msgstr "entferne 'methods' Paket ..."

#. R/BasicClasses.R: gettextf("unnamed argument must extend either the S3 class or the class of the data part; not true of class %s",     dQuote(Classi))
#: R/BasicClasses.R:0
msgid "unnamed argument must extend either the S3 class or the class of the data part; not true of class %s"
msgstr "namenloses Argument muss entweder die S3 Klasse oder die Klasse des Datenteils erweitern; gilt nicht für die Klasse %s"

#. R/BasicClasses.R: gettextf("unnamed argument to initialize() for S3 class must have a class definition; %s does not",     dQuote(Classi))
#: R/BasicClasses.R:0
msgid "unnamed argument to initialize() for S3 class must have a class definition; %s does not"
msgstr "namenloses Argument für initialize() für eine S3 Klasse muss eine Klassendefinition enthalten; %s erfüllt dies nicht"

#. R/BasicClasses.R: stop("unnamed argument to new() must be an environment for the new object")
#: R/BasicClasses.R:0
msgid "unnamed argument to new() must be an environment for the new object"
msgstr "namenloses Argument für new() muss eine Umgebung des neuen Objekts sein"

#. R/refClass.R: gettextf("unnamed arguments to $new() must be objects from a reference class; got an object of class %s",     dQuote(class(super)))
#: R/refClass.R:0
msgid "unnamed arguments to $new() must be objects from a reference class; got an object of class %s"
msgstr "Unbenannte Argumente für $new() müssen Objekte einer Referenzklasse sein; bekam ein Objekt der Klasse %s"

#. R/SClasses.R: stop("validity method must be NULL or a function of one argument")
#: R/SClasses.R:0
msgid "validity method must be NULL or a function of one argument"
msgstr "eine Validitätsmethode muss NULL oder eine Funktion eines Argumentes sein"

#. R/Methods.R: gettextf("value classes differ: %s, %s", .dQ(gpString(f1@valueClass)),     .dQ(gpString(f2@valueClass)))
#: R/Methods.R:0
msgid "value classes differ: %s, %s"
msgstr "Wertklassen unterscheiden sich: %s, %s"

#. R/methodsTable.R: ngettext(length(candidates), "Choosing method %s from %d ambiguous possibility",     "Choosing method %s from %d ambiguous possibilities")
#: R/methodsTable.R:0
msgid "Choosing method %s from %d ambiguous possibility"
msgid_plural "Choosing method %s from %d ambiguous possibilities"
msgstr[0] "Wähle Methode %s unter %d nicht eindeutigen Möglichkeit"
msgstr[1] "Wähle Methode %s unter %d nicht eindeutigen Möglichkeiten"

#. R/MethodsListClass.R: ngettext(nreport, "Reported %d ambiguous selection out of %d for function %s\n",     "Reported %d ambiguous selections out of %d for function %s\n")
#: R/MethodsListClass.R:0
msgid "Reported %d ambiguous selection out of %d for function %s\n"
msgid_plural "Reported %d ambiguous selections out of %d for function %s\n"
msgstr[0] "%d zweideutige Auswahl von %d für Funktion %s berichtet\n"
msgstr[1] "%d zweideutige Auswahlen von %d für Funktion %s berichtet\n"

#. R/methodsTable.R: ngettext(which2, "Selecting %d method of minimum distance", "Selecting %d methods of minimum distance")
#: R/methodsTable.R:0
msgid "Selecting %d method of minimum distance"
msgid_plural "Selecting %d methods of minimum distance"
msgstr[0] "Wähle %d Methode mit minimaler Distanz"
msgstr[1] "Wähle %d Methoden mit minimaler Distanz"

#. R/methodsTable.R: ngettext(length(which), "Selecting %d non-group method", "Selecting %d non-group methods")
#: R/methodsTable.R:0
msgid "Selecting %d non-group method"
msgid_plural "Selecting %d non-group methods"
msgstr[0] "Wähle %d gruppenfremde Methode"
msgstr[1] "Wähle %d gruppenfremde Methoden"

#. R/methodsTable.R: ngettext(length(which), "Selecting %d partially exact-matching method",     "Selecting %d partially exact-matching methods")
#: R/methodsTable.R:0
msgid "Selecting %d partially exact-matching method"
msgid_plural "Selecting %d partially exact-matching methods"
msgstr[0] "Wähle %d teilweise exakt übereinstimmende Methode"
msgstr[1] "Wähle %d teilweise exakt übereinstimmende Methoden"

#. R/is.R: ngettext(sum(is.na(match(n2, n1))), "class %s is missing slot from class %s (%s), and no coerce method was supplied",     "class %s is missing slots from class %s (%s), and no coerce method was supplied")
#: R/is.R:0
msgid "class %s is missing slot from class %s (%s), and no coerce method was supplied"
msgid_plural "class %s is missing slots from class %s (%s), and no coerce method was supplied"
msgstr[0] "der Klasse %s fehlt Slot aus Klasse %s (%s) und keine Umwandlungsmethode angegeben"
msgstr[1] "der Klasse %s fehlen Slots aus Klasse %s (%s) und keine Umwandlungsmethode angegeben"

#. R/SClasses.R: ngettext(length(dslots), "duplicated slot name: %s", "duplicated slot names: %s")
#: R/SClasses.R:0
msgid "duplicated slot name: %s"
msgid_plural "duplicated slot names: %s"
msgstr[0] "doppelter Slotname: %s"
msgstr[1] "doppelte Slotnamen: %s"

#. R/methodsTable.R: ngettext(length(methods), "found %d equally good next method",     "found %d equally good next methods")
#: R/methodsTable.R:0
msgid "found %d equally good next method"
msgid_plural "found %d equally good next methods"
msgstr[0] "%d gleich gute nächste Methode gefunden"
msgstr[1] "%d gleich gute nächste Methoden gefunden"

#. R/MethodsList.R: ngettext(sum(is.na(which)), "in the method signature for function %s invalid argument name in the signature: %s",     "in the method signature for function %s invalid argument names in the signature: %s")
#: R/MethodsList.R:0
msgid "in the method signature for function %s invalid argument name in the signature: %s"
msgid_plural "in the method signature for function %s invalid argument names in the signature: %s"
msgstr[0] "in der Methodensignatur für Funktion %s unzulässiger Argumentname in der Signatur %s"
msgstr[1] "in der Methodensignatur für Funktion %s unzulässige Argumentnamen in der Signatur %s"

#. R/SClasses.R: ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s",     "invalid names for slots of class %s: %s")
#: R/SClasses.R:0
msgid "invalid name for slot of class %s: %s"
msgid_plural "invalid names for slots of class %s: %s"
msgstr[0] "unzulässiger Name für Slot der Klasse %s; %s"
msgstr[1] "unzulässige Namen für Slots der Klasse %s; %s"

#. R/SClasses.R: ngettext(length(pkgs), "multiple definition of class %s visible (%s); using the definition\n   in package %s for %s",     "multiple definitions of class %s visible (%s); using the definition\n   in package %s for %s")
#: R/SClasses.R:0
msgid ""
"multiple definition of class %s visible (%s); using the definition\n"
"   in package %s for %s"
msgid_plural ""
"multiple definitions of class %s visible (%s); using the definition\n"
"   in package %s for %s"
msgstr[0] "mehrfache Definition der Klasse %s sichtbar (%s); benutze die Definition aus Paket %s für %s"
msgstr[1] "mehrfache Definitionen der Klasse %s sichtbar (%s); benutze die Definition aus Paket %s für %s"

#. R/RClassUtils.R: ngettext(sum(is.na(match(pnames, slots))), "named elements of prototype do not correspond to slot name: %s",     "named elements of prototype do not correspond to slot names: %s")
#: R/RClassUtils.R:0
msgid "named elements of prototype do not correspond to slot name: %s"
msgid_plural "named elements of prototype do not correspond to slot names: %s"
msgstr[0] "benannte Elemente des Prototyps korrespondieren nicht mit dem Slotnamen %s"
msgstr[1] "benannte Elemente des Prototyps korrespondieren nicht mit den Slotnamen %s"

#. R/MethodsList.R: ngettext(length(unknown), "no definition for class %s", "no definition for classes %s")
#: R/MethodsList.R:0
msgid "no definition for class %s"
msgid_plural "no definition for classes %s"
msgstr[0] "keine Definition der Klasse %s"
msgstr[1] "keine Definition der Klassen %s"

#. R/promptClass.R: ngettext(length(whereClass), "no definition of class %s in the specified position, %s, definition on : %s",     "no definition of class %s in the specified position, %s, definitions on : %s")
#: R/promptClass.R:0
msgid "no definition of class %s in the specified position, %s, definition on : %s"
msgid_plural "no definition of class %s in the specified position, %s, definitions on : %s"
msgstr[0] "keine Definiton der Klasse %s an der angegebenen Position, %s, Definition bei: %s"
msgstr[1] "keine Definiton der Klasse %s an der angegebenen Position, %s, Definitionen bei: %s"

#. R/RMethodUtils.R: ngettext(sum(not.s.in.a), "non-argument found in the signature: %s",     "non-arguments found in the signature: %s")
#. R/RMethodUtils.R: ngettext(sum(not.s.in.a), "non-argument found in the signature: %s",     "non-arguments found in the signature: %s")
#: R/RMethodUtils.R:0
msgid "non-argument found in the signature: %s"
msgid_plural "non-arguments found in the signature: %s"
msgstr[0] "Nicht-Argument in der Signatur gefunden: %s"
msgstr[1] "Nicht-Argumente in der Signatur gefunden: %s"

#. R/is.R: ngettext(length(bad), "slot in class %s must extend corresponding slot in class %s: fails for %s",     "slots in class %s must extend corresponding slots in class %s: fails for %s")
#: R/is.R:0
msgid "slot in class %s must extend corresponding slot in class %s: fails for %s"
msgid_plural "slots in class %s must extend corresponding slots in class %s: fails for %s"
msgstr[0] "Slot in Klasse %s muss entsprechenden Slot in Klasse %s erweitern; schlägt fehl für %s"
msgstr[1] "Slots in Klasse %s müssen entsprechende Slots in Klasse %s erweitern; schlägt fehl für %s"

#. R/RMethodUtils.R: ngettext(length(fdef), "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)",     "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)")
#: R/RMethodUtils.R:0
msgid "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)"
msgid_plural "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)"
msgstr[0] "das formale Argument der generischen Funktion für \"%s\" (%s) unterscheidet sich von dem der nicht-generischen Funktion, die als Standard genutzt wird (%s)"
msgstr[1] "die formalen Argumente der generischen Funktion für \"%s\" (%s) unterscheiden sich von denen der nicht-generischen Funktion, die als Standard genutzt wird (%s)"

#~ msgid "(and methods)"
#~ msgstr "(und Methoden)"

#~ msgid "invalid method sublist"
#~ msgstr "unzulässige Methodenteilliste"

#~ msgid "%f is not a valid generic function: methods list was an object of class %s"
#~ msgstr "%f ist keine gültige generische Funktion: Methodenliste war ein Objekt der Klasse %s"

#~ msgid "%s must be TRUE, FALSE, or a named logical vector of those values; got an object of class %s"
#~ msgstr "%s muss TRUE oder FALSE sein oder ein benannter boolescher Vektor solcher Werte; bekam ein Objekt der Klasse %s"

#~ msgid "skipping methods list element %s of unexpected class %s"
#~ msgstr "überspringe Methodenlistenelement %s der unerwarteten Klasse %s"

#~ msgid "invalid call in method dispatch to '%s' (no default method)"
#~ msgstr "unzulässiger Aufruf im Methodendispatch zu '%s' (keine Standardmethode)"

#~ msgid "subclass %s of class %s is not local and cannot be updated for new inheritance information; consider setClassUnion()"
#~ msgstr "Subklasse %s der Klasse %s ist nicht lokal und kann nicht für neue Vererbungsinformation aktualisiert werden; evtl. setClassUnion() nutzen?"

#~ msgid "Note: the specification for S3 class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class."
#~ msgstr "die Spezifikation für die S3 Klasse %s in Paket %s scheint äquivalent zu einer aus Paket %s; für diese Klasse werden  die Klassendefinitionen nicht dupliziert"

#~ msgid "methods cannot be defined for the primitive function %s"
#~ msgstr "für die primitive Funktion %s können keine Methoden definiert werden"

#~ msgid "package %s seems to have out-of-date methods; need to reinstall from source"
#~ msgstr "Paket %s scheint veraltete Methoden zu beinhalten; Neuinstallation aus den Quellen erforderlich"

#~ msgid "trying to execute load actions without 'methods' package"
#~ msgstr "versuche die Ladeaktionen ohne das 'methods' Paket auszuführen"

#~ msgid "special function %s is not permitted to have methods"
#~ msgstr "spezielle Funktion %s darf keine Methoden besitzen"

#~ msgid "special function %s has no known argument list; will assume '(x, ...)'"
#~ msgstr "spezielle Funktion %s hat keine bekannte Argumentliste; unterstelle '(x, ...)'"

#~ msgid "'callGeneric' with a primitive needs explicit arguments (no formal args defined)"
#~ msgstr "'callGeneric' mit einem Primitiv benötigt explizite Argumente (keine formalen Argumente definiert)"

#~ msgid "\""
#~ msgstr "\""

#~ msgid "could not find superclass %s to clean up when removing subclass references to class %s"
#~ msgstr "Konnte Superklasse %s nicht finden um aufzuräumen, als die Unterklassenreferenzierung auf Klasse %s entfernt wurde"

#~ msgid "no class %s found as expected in removing subclass %s"
#~ msgstr "Erwartete Klasse %s nicht beim Entfernen der Unterklasse %s gefunden"

#~ msgid "replacement value is not a matrix"
#~ msgstr "neuer Wert ist keine Matrix"

#~ msgid "field %s is read-only"
#~ msgstr "Feld %s ist \"nur-lesen\""

#~ msgid "not a package name: %s"
#~ msgstr "ist kein Paketname: %s"

#, fuzzy
#~ msgid "a list argument for 'fields' must have nonempty names for all the fields"
#~ msgstr "Ein Listenargument für Felder muss nicht-leere Namen für alle Felder bereitstellen"

#, fuzzy
#~ msgid "argument 'fields' must be a list of the field classes or definitions or the names of the fields; got an object of class %s"
#~ msgstr "Argument fields muss eine Liste von Feldklassen oder Definitionen sein oder einfach die Name der Felder: bekam ein Objekt aus Klasse %s"

#~ msgid "Warning:  using defunct methods list search"
#~ msgstr "Warnung: Listensuche in methods funktioniert nicht mehr"

#~ msgid "apparent inconsistency in the methods for function %s; argument %s in the signature corresponds to %s in the methods list object"
#~ msgstr "anscheinend eine Inkonsistenz in den Methoden für Funktion %s; Argument %s in der Signatur korrespondiert mit %s im Methodenlistenobjekt"

#~ msgid "no S4 method for function %s and signature %s; consider getS3method() if you wanted the S3 method"
#~ msgstr "keine S4 Methode für Funktion %s und Signatur %s; beachten Sie getS3method(), falls S3 Methode gewünscht"

#~ msgid "no method defined in methods list object for function %s and signature %s"
#~ msgstr "keine Methode für Funktion %s und Signatur %s in der Methodenliste definiert"

#~ msgid "multiple equivalent inherited matches:"
#~ msgstr "mehrfache äquivalents vererbte Treffer:"

#~ msgid "; using the first of these"
#~ msgstr "; nutze den ersten von diesen"

#~ msgid "'traceOn' is deprecated: use the function 'trace' in the 'methods' package instead"
#~ msgstr "'traceOn' ist veraltet: bitte die Funktion 'trace' im Paket 'methods' nutzen"

#~ msgid "'traceOff' is deprecated: use the function 'untrace' in the 'methods' package instead"
#~ msgstr "'traceOn' ist veraltet: bitte die Funktion 'untrace' im Paket 'methods' nutzen"

#, fuzzy
#~ msgid "The class of field %s in the object is not compatible with the desired class %s in the target"
#~ msgstr "Die Klasse des Feldes \"%s\" im Objekt ist nicht kompatibel mit der gewünschten Klasse %s im Ziel"

#~ msgid "in .OldClassesPrototypes"
#~ msgstr "in .OldClassesPrototypes"

#~ msgid "internal error: did not get a valid generic function object for function %s"
#~ msgstr "interner Fehler: bekam kein gültiges generisches Funktionsobjekt für Funktion %s"

#~ msgid "apparent internal error: a generic function was found for \"%s\", but no corresponding object was found searching from \"%s\""
#~ msgstr "anscheinend interner Fehler: eine generische Funktion für \"%s\" wurde gefunden, aber während der Suche von \"%s\" kein zugehöriges Objekt"

#~ msgid "selectMethod(): mlist is not an environment or NULL :"
#~ msgstr "selectMethod(): mlist ist keine Umgebung oder NULL"

#~ msgid "** should no longer happen!"
#~ msgstr "** sollte nicht mehr auftreten!"

#~ msgid "Classes: %s, %s"
#~ msgstr "Klassen: %s, %s"

#~ msgid "internal error: Bad methods list object in fixing methods for primitive function %s"
#~ msgstr "interner Fehler: ungültiges Methodenlistenobjekt bei der Festlegung der Methoden für die primitive Funktion %s"

#~ msgid "botched namespace: failed to find 'base' namespace in its parents"
#~ msgstr "Namensraum Störung: 'base' Namensraum nicht unter den Eltern gefunden"

#~ msgid "multiple direct matches:"
#~ msgstr "mehrfache direkte Treffer:"

#, fuzzy
#~ msgid "Internal error: definition of class %s not properly assigned"
#~ msgstr "Interner Fehler: die Definition der Klasse \"%s\" ist nicht ordentlich zugewiesen"

#, fuzzy
#~ msgid "internal problem in as(): %s is(object, \"%s\") is TRUE, but the metadata asserts that the 'is' relation is FALSE"
#~ msgstr "internes Problem in as(): \"%s\" is(object, \"%s\") ist TRUE, aber die Metadaten garantieren, dass die 'is' Relation FALSE ergibt"

#~ msgid "connection"
#~ msgstr "eine Verbindung"

#~ msgid "Internal error in finding inherited methods; didn't return a unique method"
#~ msgstr "Interner Fehler beim Auffinden vererbter Methoden; keine eindeutige Methode zurückgegeben"

#~ msgid "\", but it is not a group generic"
#~ msgstr "\", es ist aber keine Gruppengenerische"

#~ msgid "Trying to check signature length of generic \""
#~ msgstr "Versuch der Überprüfung der Signaturlänge einer Generischen \""

#~ msgid "\", but it is not a  generic function: i ="
#~ msgstr "\", es ist aber keine Generische: i="

#~ msgid ", funs ="
#~ msgstr ", funs ="

#~ msgid ","
#~ msgstr ","

#~ msgid "; gnames ="
#~ msgstr ": gnames ="

#~ msgid "Something weird:  inconsistent number of args in methods table strings:"
#~ msgstr "Seltsam: inkonsistente Anzahl Methoden in den Methodentabellenzeichenketten:"

#~ msgid "(using the largest value)"
#~ msgstr "(nutze größten Wert)"

#~ msgid "Undefined classes ("
#~ msgstr "Nicht definierte Klassen ("

#~ msgid "Method %s from class %s was not processed into a class method until being installed.  Possible corruption of the methods in the class."
#~ msgstr ""
#~ "Methode %s aus Klasse %s wurde bis zur Installation nicht als Klassenmethode behandelt,\n"
#~ "Mögliche Beschädigung der Methoden der Klasse"

#~ msgid ".TraceWithMethods: after computing what, whereF"
#~ msgstr ".TraceWithMethods: nach der Berechnung what, whereF"

#~ msgid ".TraceWithMethods: untrace case"
#~ msgstr ".TRaceWithMethods: Fall für Verfolgung aufheben"

#~ msgid ".TraceWithMethods: about to assign or setMethod"
#~ msgstr ".TraceWithMethods: bei assign oder setMethod"

#, fuzzy
#~ msgid "Constructing traceable class %s"
#~ msgstr "Konstruktion einer verfolgbaren Klasse\""

#~ msgid "Pretend we inserted class"
#~ msgstr "Gebe vor Klasse eingefügt zu haben"

#~ msgid "= \"missing\""
#~ msgstr "= \"missing\""

#~ msgid "found"
#~ msgstr "gefunden"

#~ msgid "Invalid mlist element for signature \""
#~ msgstr "Ungültiges mlist Element für die Signatur \""

#~ msgid "\" at level"
#~ msgstr "\" auf Level"

#~ msgid "\")"
#~ msgstr "\")"

#~ msgid "Invalid object in methods table (\""
#~ msgstr "Unzulässiges Ohjekt in Methodentabelle (\""

#~ msgid "\"), expected a method, got an object of class \""
#~ msgstr "\") erwartete Methode, bekam Objekt der Klasse \""

#~ msgid "Environment of class \""
#~ msgstr "Umgebung der Klasse \""

#~ msgid "Replacement value must be of class \""
#~ msgstr "Unbedingt Ersetzungswert aus Klasse \""

#~ msgid "\", got one of class \""
#~ msgstr "\"bekam einen aus Klasse \""

#~ msgid "\", for signature"
#~ msgstr "\", für Signatur"

#~ msgid "Field \""
#~ msgstr "Feld \""

#~ msgid "the supplied generic function definition for"
#~ msgstr "die angegebene Definition der generischen Funktion für"

#~ msgid "does not seem to call 'standardGeneric'; no methods will be dispatched!"
#~ msgstr "scheint 'standardGenerich' nicht aufzurufen; kein Methodendispatch"

#~ msgid "no generic function \"'%s\" found"
#~ msgstr "keine generische Funktion \"%s\" gefunden"

#~ msgid ""
#~ "Restoring the implicit generic function for %s from package %s\n"
#~ "    into package %s; the generic differs from the default conversion (%s)"
#~ msgstr ""
#~ "Wiederherstellung der impliziten generischen Funktion für %s aus Paket \"%s\" \n"
#~ "in das Paket %s; die Generische unterscheidet sich von der Standardkonvertierung (%s)"

#~ msgid ""
#~ "Creating a generic for %s in package %s\n"
#~ "    (the supplied definition differs from and overrides the implicit generic\n"
#~ "    in package %s: %s)"
#~ msgstr ""
#~ "Erzeugung einer Generischen für \"%s\" im Paket \"%s\"\n"
#~ "          (die angegebene Definition unterschiedet sich von und überschreibt \n"
#~ "          die implizite Generische im Paket \"%s\": %s)"

#~ msgid "\" is not a known action (warn, stop, once, ignore); no action recorded for function \""
#~ msgstr ""
#~ "\" ist keine bekannte Aktion (warn, stop, once, ignore); keine Aktion aufgenommen für\n"
#~ "function \""

#~ msgid "Value supplied for field \"%s\" (with class \"%s\") is not a subclass of required class \"%s\""
#~ msgstr "Der übergebene  Wert für Feld \"%s\" (mit Klasse \"%s\") ist keine Unterklasse der verlangten Klasse \"%s\""

#~ msgid "Some elements of the list (e.g., %d) are not functions"
#~ msgstr "Einige Elemente der Liste (z. B. %d) sind keine Funktionen"

#~ msgid "Interface class \"%s\"  was an explicitly specified superclass as well"
#~ msgstr "Auch die Interfaceklasse \"%s\" war eine expizit spezifizierte Oberklasse"

#~ msgid "The fieldReadOnly argument must be the names of the read-only fields; got an object of class \"%s\""
#~ msgstr "Das fieldReadOnly Argument muss den Namen der read-only Felder entsprechen; bekam ein Objekt der Klasse \"%s\""

#~ msgid "Some fieldReadOnly names are not fields: %s"
#~ msgstr "Einige fieldReadOnly Namen bezeichenen keine Felder: %s"

#~ msgid "Prototypes supplied for non-fields: %s"
#~ msgstr "Prototypen für etwas anderes als ein Feld angegeben: %s"

#~ msgid "Field classes undefined: %s"
#~ msgstr "Feldklassen undefiniert: %s"

#~ msgid "Trying to set a read-only field ("
#~ msgstr "Versuch ein read-only feld zu setzen ("

#~ msgid ")"
#~ msgstr ")"

#, fuzzy
#~ msgid "\"%s\" is not a known reference class"
#~ msgstr "\"%s\" ist keine definierte Klasse"

#, fuzzy
#~ msgid "Invalid accessor function list: %s"
#~ msgstr "unzulässiger Index für Funktionsargument"

#~ msgid "Defining type \"%s\" as a superclass via class \"%s\""
#~ msgstr "Definiere den Typ \"%s\" als eine Superklasse über Klasse \"%s\""

#, fuzzy
#~ msgid "invalid argument 'f', expected a function or its name, got an object of class %s"
#~ msgstr "unzulässiges Argument \"f\", erwartet ist eine Funktion oder deren Name, bekam Objekt der Klasse \"%s\""

#~ msgid "in the method signature for function \"%s\" no definition for class: %s"
#~ msgid_plural "in the method signature for function \"%s\" no definition for classes: %s"
#~ msgstr[0] "in der Methodensignatur für Funktion \"%s\" keine Definition für Klasse: %s"
#~ msgstr[1] "in der Methodensignatur für Funktion \"%s\" keine Definition für Klassen: %s"

#~ msgid "None of the orderings of the superclasses of class \"%s\" is consistent with the superclass ordering of  its direct superclasses; using an ordering which conflicts with %s"
#~ msgstr "Keine der Anordnungen der Superklassen von Klasse \"%s\" ist konsistent der Anordnung der Superklassen der direkten Superklassen; nutze eine Anordnung, die inkonsistent ist mit %s"

#~ msgid "Some of the superclasses in the definition of class \""
#~ msgstr "Einige der Superklassen in der Definition von Klasse \""

#~ msgid ""
#~ "S3 methods written for S4 classes will fail inheritance!\n"
#~ "Package"
#~ msgstr ""
#~ "S3 Methoden für S4 Klassen werden bei Vererbung versagen\n"
#~ "Paket"

#~ msgid "apparently has"
#~ msgstr "hat anscheinend"

#~ msgid "such methods  for the functions"
#~ msgstr "solche Methoden für die Funktionen"

#~ msgid "Possible dangerous methods:"
#~ msgstr "Möglicherweise gefährliche Methoden:"

#~ msgid "(Warnings generated once per package per session)"
#~ msgstr "(Warnungen einmal pro Sitzung und Paket erzeugt)"

#~ msgid "There are apparent S3 methods for class \""
#~ msgstr "Es gibt anscheinend S3 Methoden für Klasse \""

#~ msgid ""
#~ "\"\n"
#~ "DANGER: any subclasses of this class will not inherit the methods"
#~ msgstr ""
#~ "\"\n"
#~ "Achtung: keine Unterklasse dieser Klasse wird Methoden erben"

#~ msgid ""
#~ "\" have apparent S3 methods.\n"
#~ "\n"
#~ "DANGER: the new class will not inherit these methods.\n"
#~ "Complain to the author of the superclass definitions."
#~ msgstr ""
#~ "\" haben anscheinend S3 Methoden.\n"
#~ "\n"
#~ "Achtung: die neue Klasse wird diese Methoden nicht erben.\n"
#~ "Beschwerden bitte an den Autor der Superklassendefinition."

#~ msgid "signature must be a vector of classes or an environment"
#~ msgstr "Signatur muss ein Vektor von Klassen oder eine Umgebung sein"

#~ msgid "selectMethod(): .SelectMethodOn - old stuff - please report"
#~ msgstr "selectMethod(): .SelectMethodOn - altes Zeug - bitte melden"

#~ msgid "no unique method corresponding to this signature"
#~ msgstr "keine eindeutige Methode Korrespondiert mit dieser Signatur"

#~ msgid "unable to match signature to methods"
#~ msgstr "kann Signatur nicht mit Methoden in Übereinstimmung bringen"

#~ msgid "class \"%s\" cannot be used as the data part of another class"
#~ msgstr "Klasse \"%s\" kann nicht als Datenteil einer anderen Klasse genutzt werden"

#~ msgid "internal error: bad code for 'setPrimitiveMethods': %s"
#~ msgstr "interner Fehler: unzulässiger Code für 'setPrimitiveMethods': %s"

#~ msgid "Ambiguous method selection for \"%s\", target \"%s\""
#~ msgstr "Zweideutige Methodenauswahl für \"%s\", Ziel \"%s\""

#~ msgid ""
#~ "(the first of the signatures shown will be used)\n"
#~ "%s"
#~ msgstr ""
#~ "(die erste der gezeigten Signaturen wird benutzt)\n"
#~ "%s"

#~ msgid "Couldn't find methods table for \"%s\", package \"%s\" may be out of date"
#~ msgstr "Konnte keine Methodentabelle für \"%s\" finden, Paket \"%s\" evtl. veraltet"

#~ msgid "The class to be removed  (\""
#~ msgstr "Die zu entfernende Klasse (\""

#~ msgid "\") has defined subclasses that should also be removed: ("
#~ msgstr "\" hat Unterklassen definiert, die ebenfalls entfernt werden sollten ("

#~ msgid "'NextMethod' not defined because the current method is not a 'MethodDefinition' object"
#~ msgstr "NextMethod: nicht definiert, da das aktuelle Methodenobjekt kein 'MethodDefinition'-Objekt ist"

#~ msgid "expected a list of signature objects, got \"%s\""
#~ msgstr "erwartet war eine Liste von Signaturobjekten, bekam \"%s\""

#~ msgid "New generic for \"%s\" does not agree with implicit generic from package \"%s\"; a new generic will be assigned with package \"%s\""
#~ msgstr "Neue geneerische Funktion für \"%s\" stimmt nicht mit der impliziten generischen Funktione aus Paket \"%s\" überein; eine neue generische Funktion wird mit dem Paket \"%s\" zugewiesen"

#~ msgid "Function \"%s\" may not be used as a generic (implicitly prohibited)"
#~ msgstr "Funktion \"%s\" darf nicht als generisch benutzt werde (implizit verboten)"

#~ msgid "Implicit generic exists for \"%s\", but will be overriden by explicit call to setGeneric()"
#~ msgstr "Es existiert eine implizite Generische für \"%s\", wird aber durch expliziten Aufruf von setGeneric() überschrieben"

#~ msgid "Unable to find package environment for class \"%s\" to revise subclass information"
#~ msgstr "Kann die Paketinformation für Klasse \"%s\"nicht auffinden, um die Teilkalssen Information zu überprüfen"

#~ msgid "No generic function found for \"%s\"; no action taken in removeMethodsObject"
#~ msgstr "Keine generische Funktion für \"%s\" gefunden; keine Aktion in removeMethodsObject durchgeführt"

#~ msgid "the environment/package \"%s\" is locked; cannot remove methods data for \"%s\""
#~ msgstr "die Umgebung/das Paket \"%s\" ist gesichert; kann Methodendaten für \"%s\" nicht entfernen"

#~ msgid "the methods object name for \"%s\" must include the name of the package that contains the generic function, but no generic function of this name was found"
#~ msgstr "der Methodenobjektname für \"%s\" muss den Namen des Pakets mit der generischen Funktion enthalten, aber keine generische Funktion dieses Namens gefunden "

#~ msgid "no way to associate a generic function with an object of class \"%s\""
#~ msgstr "kann generische Funktion nicht mit einem Objekt der Klasse \"%s\" assoziieren"

#~ msgid "Could not find generic function \"%s\" to initialize cached methods"
#~ msgstr "Konnte keine generische Funktion \"%s\" finden, um die gepufferten Methoden zu initialisieren"

#~ msgid "trying to change the argument list of %s with %d arguments to have arguments (%s)"
#~ msgstr "versuche die Argumentliste von %s mit %d Argumenten auf Argumente (%s) zu ändern"

#~ msgid "get rid of variables in definition %s (%s); they conflict with the needed change to argument names (%s)"
#~ msgstr "verwerfe Variablen aus der Definition %s (%s): Konflikt mit der notwendigen Änderung der Argumentnamen (%s)"

#~ msgid "arguments in definition %s changed from (%s) to (%s)"
#~ msgstr "Argumente in Definition %s geändert von (%s) nach (%s)"

#~ msgid "no methods found for generic \"%s\""
#~ msgstr "keine Methoden für Generische \"%s\" gefunden"

#~ msgid "\"%s\" is not one of the basic functions"
#~ msgstr "\"%s\" ist keine der Grundfunktionen"

#~ msgid "cannot reset \"%s\", the definition is not a generic function object"
#~ msgstr "kann \"%s\" nicht zurücksetzen, Definition ist keine generisches Funktionsobjekt"

#~ msgid "No nongeneric version of function \"%s\" exists to be restored"
#~ msgstr "Es existiert keine nichtgenerische Version der Funktion \"%s\" zur Wiederherstellung"

#~ msgid "\"%s\" from \"%s\" is a non-generic function; no methods available"
#~ msgstr "\"%s\" aus \"%s\" ist eine nicht-generische Funktion; keine Methoden vorhanden"

#~ msgid "invalid 'fdef' for \"%s\" in 'getAllMethods'; expected either a 'genericFunction object' or a primitive function, got an object of class \"%s\""
#~ msgstr "ungültige 'fdef' für \"%s\" in 'getAllMethods'; erwarte entweder ein 'genericFunctionobject' oder eine primitive Funktion, bekam ein Objekt der Klasse \"%s\""

#~ msgid "Methods list for generic \""
#~ msgstr "Methodenliste für die Generische \""

#~ msgid "\" not found"
#~ msgstr "\" nicht gefunden"

#~ msgid ".UsingMethodsTables: 'onOff' is not TRUE or FALSE"
#~ msgstr ".UsingMethodsTables: 'onOff' ist weder TRUE noch FALSE"

#~ msgid "Package \"%s\" is not loaded"
#~ msgstr "Paket \"%s\" nicht geladen"
