# Translation of R-methods.pot to French
# Copyright (C) 2005-2021 The R Foundation
# This file is distributed under the same license as the methods R package.
# Philippe Grosjean <phgrosjean@sciviews.org>, 2005.
#
msgid ""
msgstr ""
"Project-Id-Version: R 4.2.0\n"
"Report-Msgid-Bugs-To: bugs.r-project.org\n"
"POT-Creation-Date: 2025-06-15 11:12\n"
"PO-Revision-Date: 2025-07-06 15:40+0200\n"
"Last-Translator: Philippe Grosjean <phgrosjean@sciviews.org>\n"
"Language-Team: French <R-core@r-project.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"X-Generator: Poedit 3.6\n"
"X-Poedit-SourceCharset: UTF-8\n"

#. R/RMethodUtils.R: warning("\"MethodsList\" is defunct; allMethods now are empty")
#: R/RMethodUtils.R:0
msgid "\"MethodsList\" is defunct; allMethods now are empty"
msgstr "“MethodsList” est obsolète ; allMethods sont maintenant vides"

#. R/RClassUtils.R: stop("\"class\" is a reserved slot name and cannot be redefined")
#: R/RClassUtils.R:0
msgid "\"class\" is a reserved slot name and cannot be redefined"
msgstr "\"class\" est un nom de slot réservé et ne peut être redéfini"

#. R/MethodsListClass.R: gettextf("%d: target \"%s\": chose \"%s\" (others: %s)", i, target[[i]],     selected[[i]], paste0("\"", these, "\"", collapse = ", "))
#: R/MethodsListClass.R:0
msgid "%d: target \"%s\": chose \"%s\" (others: %s)"
msgstr "%d : cible \"%s\" : choix \"%s\" (autres : %s)"

#. R/RMethodUtils.R: gettextf("%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list",     .renderSignature(generic@generic, signature), paste(sQuote(trailingArgs),         collapse = ", "), sQuote("..."))
#: R/RMethodUtils.R:0
msgid "%s arguments (%s) after %s in the generic must appear in the method, in the same place at the end of the argument list"
msgstr "%s arguments (%s) après %s dans la fonction générique doivent apparaitre dans la méthode, à la même place à la fin de la liste des arguments"

#. R/Methods.R: gettextf("%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed.",     sQuote(name))
#: R/Methods.R:0
msgid "%s dispatches internally;  methods can be defined, but the generic function is implicit, and cannot be changed."
msgstr "%s dispatcher en interne ; Les méthodes peuvent être définies, mais la fonction générique est implicite et ne peut être modifiée."

#. R/SClasses.R: gettextf("%s has a sealed class definition and cannot be redefined",     dQuote(Class))
#: R/SClasses.R:0
msgid "%s has a sealed class definition and cannot be redefined"
msgstr "%s a une définition de classe scellée et ne peut donc pas être redéfinie"

#. R/Methods.R: gettextf("%s has no methods defined", sQuote(f))
#: R/Methods.R:0
msgid "%s has no methods defined"
msgstr "%s n'a aucune méthode définie"

#. R/Methods.R: gettextf("%s is a primitive function; its generic form cannot be redefined",     sQuote(name))
#: R/Methods.R:0
msgid "%s is a primitive function; its generic form cannot be redefined"
msgstr "%s est une fonction primitive ; sa forme générique ne peut être redéfinie"

#. R/SClasses.R: gettextf("%s is not a defined class", dQuote(Class))
#: R/SClasses.R:0
msgid "%s is not a defined class"
msgstr "%s n'est pas une classe définie"

#. R/refClass.R: gettextf("%s is not a defined class in this environment", dQuote(Class))
#: R/refClass.R:0
msgid "%s is not a defined class in this environment"
msgstr "%s n'est pas une classe définie dans cet environnement"

#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(field), dQuote(thisClass@className))
#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(what), dQuote(def@className))
#. R/refClass.R: gettextf("%s is not a field in class %s", sQuote(what), dQuote(className))
#: R/refClass.R:0
msgid "%s is not a field in class %s"
msgstr "%s n'est pas un champ de la classe %s"

#. R/refClass.R: gettextf("%s is not a field in this class", sQuote(name))
#: R/refClass.R:0
msgid "%s is not a field in this class"
msgstr "%s n'est pas un champ de cette classe"

#. R/RMethodUtils.R: gettextf("%s is not a generic function (or not visible here)",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "%s is not a generic function (or not visible here)"
msgstr "%s n'est pas une fonction générique (ou elle n'est pas visible)"

#. R/trace.R: gettextf("%s is not a method for reference class %s", sQuote(as.character(if (is.symbol(thisName)) thisName else what)),     dQuote(class(where)))
#: R/trace.R:0
msgid "%s is not a method for reference class %s"
msgstr "%s n'est pas une méthode pour la référence de classe %s"

#. R/refClass.R: gettextf("%s is not a reference class", dQuote(Class))
#. R/refClass.R: gettextf("%s is not a reference class", dQuote(def@className))
#: R/refClass.R:0
msgid "%s is not a reference class"
msgstr "%s n'est pas une classe de référence"

#. R/SClasses.R: gettextf("%s is not a slot in class %s", sQuote(name), dQuote(cl))
#: R/SClasses.R:0
msgid "%s is not a slot in class %s"
msgstr "%s n'est pas un slot de la classe %s"

#. R/refClass.R: gettextf("%s is not a valid field or method name for reference class %s",     sQuote(field), dQuote(thisClass@className))
#: R/refClass.R:0
msgid "%s is not a valid field or method name for reference class %s"
msgstr "%s n'est pas un champ correct ou le nom d'une méthode pour la classe de référence %s"

#. R/refClass.R: gettextf("%s is not a valid field or method name for this class",     sQuote(what))
#: R/refClass.R:0
msgid "%s is not a valid field or method name for this class"
msgstr "%s n'est pas un champ correct ou le nom d'une méthode pour cette classe"

#. R/Methods.R: gettextf("%s is not an S4 generic function in %s; methods not removed",     sQuote(f), sQuote(getPackageName(where)))
#: R/Methods.R:0
msgid "%s is not an S4 generic function in %s; methods not removed"
msgstr "%s n'est pas une fonction générique S4 dans %s ; Les méthodes ne sont pas éliminées"

#. R/Methods.R: gettextf("%s is not currently a generic:  define it first to create a non-default implicit form",     sQuote(name))
#: R/Methods.R:0
msgid "%s is not currently a generic:  define it first to create a non-default implicit form"
msgstr "%s n'est pas actuellement générique : définissez-le d'abord avant de créer une forme implicite qui n'est pas la forme par défaut"

#. R/RClassUtils.R: gettextf("%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)",     dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "%s is not eligible to be the data part of another class (must be a basic class or a virtual class with no slots)"
msgstr "%s ne peut être utilisé comme partie de données d'une autre classe (doit être une classe basique ou une classe virtuelle sans slots)"

#. R/addedFunctions.R: gettextf("%s is not one of the element names", sQuote(name))
#: R/addedFunctions.R:0
msgid "%s is not one of the element names"
msgstr "%s n'est pas un des noms des éléments"

#. R/refClass.R: gettextf("%s is not one of the reference super classes for this object",     dQuote(Class))
#: R/refClass.R:0
msgid "%s is not one of the reference super classes for this object"
msgstr "%s n'est pas une des références à des superclasses pour cet objet"

#. R/trace.R: gettextf("%s() is not a generic function in the target environment -- methods will not be inserted",     f)
#: R/trace.R:0
msgid "%s() is not a generic function in the target environment -- methods will not be inserted"
msgstr "%s() n'est pas une fonction générique dans l'environnement cible -- Les méthodes ne sont pas insérées"

#. R/MethodsList.R: gettextf("%s, along with other use of the \"MethodsList\" metadata objects, is defunct.",     dQuote(this))
#: R/MethodsList.R:0
msgid "%s, along with other use of the \"MethodsList\" metadata objects, is defunct."
msgstr "%s, ainsi que d'autres utilisations des objets metadonnées \"MethodList\", sont obsolètes."

#. R/MethodsList.R: gettextf("%s, along with other use of the \"MethodsList\" metadata objects, is deprecated.",     dQuote(this))
#: R/MethodsList.R:0
msgid "%s, along with other use of the \"MethodsList\" metadata objects, is deprecated."
msgstr "%s, ainsi que d'autres utilisations des objets metadonnées \"MethodList\", sont obsolètes."

#. R/Methods.R: gettextf("'%s' is not a known generic function {and 'package' not specified}",     f)
#: R/Methods.R:0
msgid "'%s' is not a known generic function {and 'package' not specified}"
msgstr "'%s' ne correspond pas à une fonction générique connue {et le 'package' n'est pas spécifié}"

#. R/RClassUtils.R: stop("'Class' must be a valid class definition or class")
#: R/RClassUtils.R:0
msgid "'Class' must be a valid class definition or class"
msgstr "'Class' doit être le nom d'une classe ou d'une définition de classe"

#. R/oldClass.R: gettextf("'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s",     dQuote(class(object)))
#: R/oldClass.R:0
msgid "'S3Class' can only assign to S4 objects that extend \"oldClass\"; not true of class %s"
msgstr "'S3Class' ne peut seulement être attribuée qu'à des objets S4 qui étendent \"oldClass\" ; ce n'est pas le cas de la classe %s"

#. R/oldClass.R: gettextf("'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s",     dQuote("oldClass"), dQuote(class(object)))
#: R/oldClass.R:0
msgid "'S3Class' only defined for extensions of %s or classes with a data part:  not true of class %s"
msgstr "'S3Class' est seulement défini pour des extensions de %s ou des classes ayant une partie 'data' : ce n'est pas le cas de la classe %s"

#. R/as.R: gettextf("'as' method should have one argument, or match the arguments of coerce(): got  (%s)",     paste(formalArgs(def), collapse = ", "))
#: R/as.R:0
msgid "'as' method should have one argument, or match the arguments of coerce(): got  (%s)"
msgstr "la méthode 'as' doit avoir un seul argument, ou correspondre aux arguments de coerce(), trouvé : (%s)"

#. R/is.R: stop("'class1' must be the name of a class or a class definition")
#: R/is.R:0
msgid "'class1' must be the name of a class or a class definition"
msgstr "'class1' doit être le nom d'une classe ou d'une définition de classe"

#. R/is.R: stop("'class2' must be the name of a class or a class definition")
#: R/is.R:0
msgid "'class2' must be the name of a class or a class definition"
msgstr "'class2' doit être le nom d'une classe ou d'une définition de classe"

#. R/RClassUtils.R: stop("'externalptr' objects cannot be initialized from new()")
#: R/RClassUtils.R:0
msgid "'externalptr' objects cannot be initialized from new()"
msgstr "les objets 'externalptr' ne peuvent être intialisés avec new()"

#. R/Methods.R: stop("'file' must be a character string or a connection")
#: R/Methods.R:0
msgid "'file' must be a character string or a connection"
msgstr "'file' doit être une chaîne de caractères ou une connexion"

#. R/MethodsListClass.R: gettextf("'initialize' method returned an object of class %s instead of the required class %s",     paste(dQuote(class(value)), collapse = ", "), dQuote(class(.Object)))
#: R/MethodsListClass.R:0
msgid "'initialize' method returned an object of class %s instead of the required class %s"
msgstr "la méthode 'initialize' a renvoyé un objet de classe %s au lieu de la classe requise %s"

#. R/RClassUtils.R: gettextf("(class %s)", .dQ(unlist(properties, recursive = FALSE)[undefClasses]))
#: R/RClassUtils.R:0
msgid "(class %s)"
msgstr "(classe %s)"

#. R/RMethodUtils.R: message("--- caching class ", sQuote(cl))
#: R/RMethodUtils.R:0
msgid "--- caching class"
msgstr "--- mise en cache des classes"

#. R/RMethodUtils.R: gettextf("--- done caching class %s", sQuote(cl))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "--- done caching class %s"
msgstr "--- mise en cache des classes terminée"

#. R/RMethodUtils.R: message("--- done getting generic ", sQuote(f))
#: R/RMethodUtils.R:0
msgid "--- done getting generic"
msgstr "--- récupération des fonctions génériques terminée"

#. R/RMethodUtils.R: gettextf("--- getting generic %s (and methods)", sQuote(f))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "--- getting generic %s (and methods)"
msgstr "--- récupération des fonctions génériques"

#. R/SClasses.R: gettextf("All %s names must be distinct in:\n(%s)", what, paste(sQuote(propNames),     collapse = ", "))
#: R/SClasses.R:0
msgid ""
"All %s names must be distinct in:\n"
"(%s)"
msgstr ""
"Tous les noms %s doivent être distincts dans :\n"
"(%s)"

#. R/SClasses.R: gettextf("All %s names must be nonempty in:\n(%s)", what, paste(sQuote(propNames),     collapse = ", "))
#: R/SClasses.R:0
msgid ""
"All %s names must be nonempty in:\n"
"(%s)"
msgstr ""
"Aucun des noms %s ne peut être vide dans :\n"
"(%s)"

#. R/RClassUtils.R: message("Also defined by ", paste(sQuote(pkgs[-1]), collapse = " "))
#: R/RClassUtils.R:0
msgid "Also defined by"
msgstr "Aussi défini par"

#. R/show.R: gettextf("An object of class %s", dQuote(class(object)))
#: R/show.R:0
msgid "An object of class %s"
msgstr "Un objet de classe %s"

#. R/SClasses.R: stop("Argument \"representation\" cannot be used if argument \"slots\" is supplied")
#: R/SClasses.R:0
msgid "Argument \"representation\" cannot be used if argument \"slots\" is supplied"
msgstr "L'argument \"representation\" ne peut être utilisé is l'argument \"slot\" est fournis"

#. R/refClass.R: gettextf("Class %s is not a subclass of %s; functional semantics not defined for this class",     dQuote(class(object)), dQuote("envRefClass"))
#: R/refClass.R:0
msgid "Class %s is not a subclass of %s; functional semantics not defined for this class"
msgstr "La classe %s n'est pas une sous-classe de %s ; sémantiques fonctionnelles non définies pour cette classe"

#. R/Methods.R: gettextf("Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)",     sQuote(f), sQuote(getPackageName(where)), sQuote(getPackageName(gwhere)))
#: R/Methods.R:0
msgid "Copying the generic function %s to environment %s, because the previous version was in a sealed namespace (%s)"
msgstr "La fonction générique %s est recopiée dans l'environnement %s parce que la version originale est dans un espace de noms verrouillé (%s)"

#. R/refClass.R: stop("Could not find local object in supplied environment")
#: R/refClass.R:0
msgid "Could not find local object in supplied environment"
msgstr "Impossible de trouver l'objet local dans l'environnement fourni"

#. R/packageName.R: gettextf("Created a package name, %s, when none found", sQuote(pkg))
#: R/packageName.R:0
msgid "Created a package name, %s, when none found"
msgstr "Le nom de package, %s, est créé alors qu'aucun n'est trouvé"

#. R/Methods.R: gettextf("Creating a generic function for %s from %s in %s\n    (from the saved implicit definition)",     sQuote(name), sQuote(package), thisPName)
#: R/Methods.R:0
msgid ""
"Creating a generic function for %s from %s in %s\n"
"    (from the saved implicit definition)"
msgstr ""
"Création d'une fonction générique pour %s à partir de %s dans %s\n"
"    (à partir de la définition implicite sauvegardée)"

#. R/Methods.R: gettextf("Creating a generic function for %s from package %s in %s",     sQuote(f), sQuote(fdef@package), thisPName)
#: R/Methods.R:0
msgid "Creating a generic function for %s from package %s in %s"
msgstr "Une nouvelle fonction générique est créée pour %s du package %s dans %s"

#. R/Methods.R: gettextf("Creating a generic function from function %s in %s",     sQuote(f), thisPName)
#: R/Methods.R:0
msgid "Creating a generic function from function %s in %s"
msgstr "Une nouvelle fonction générique est créée pour %s dans %s"

#. R/Methods.R: gettextf("Creating a new generic function for %s in %s", sQuote(name),     thisPName)
#: R/Methods.R:0
msgid "Creating a new generic function for %s in %s"
msgstr "Une nouvelle fonction générique est créée pour %s dans %s"

#. R/RClassUtils.R: stop("Data part is undefined for general S4 object")
#: R/RClassUtils.R:0
msgid "Data part is undefined for general S4 object"
msgstr "La partie 'data' n'est pas définie pour un objet général S4"

#. R/RClassUtils.R: gettextf("Debugging .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);\nE := environment(): %s; parent.env(E): %s",     what, format(cwhere), format(E <- environment()), format(parent.env(E)))
#: R/RClassUtils.R:0
#, fuzzy
msgid ""
"Debugging .checkSubclasses(): assignClassDef(what=\"%s\", *, where=%s, force=TRUE);\n"
"E := environment(): %s; parent.env(E): %s"
msgstr "Débogage .checkSubclasses() : assignClassDef(what=“%s”, *, where=%s, force=TRUE);"

#. R/RClassUtils.R: gettextf("Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s",     sQuote(dup), dQuote(name), dQuote(elNamed(allProps, dup)),     dQuote(cl), dQuote(elNamed(theseProperties, dup)))
#: R/RClassUtils.R:0
msgid "Definition of slot %s, in class %s, as %s conflicts with definition, inherited from class %s, as %s"
msgstr "La définition du slot %s de la classe %s comme %s est en conflit avec sa définition, héritée de la classe %s, comme %s"

#. R/RMethodUtils.R: message("Empty function name in .getGeneric")
#: R/RMethodUtils.R:0
msgid "Empty function name in .getGeneric"
msgstr "Nom de fonction vide dans .getGeneric"

#. R/trace.R: gettextf("Environment of class %s is locked; using global environment for new class",     dQuote(className))
#: R/trace.R:0
msgid "Environment of class %s is locked; using global environment for new class"
msgstr "L'environnement de laclasse %s est verrouillé ; Utilisation de l'environnement global pour la nouvelle classe"

#. R/Methods.R: gettextf("For function %s, signature %s: argument in method definition changed from (%s) to (%s)",     sQuote(f), sQuote(signature), mnames, fnames)
#: R/Methods.R:0
msgid "For function %s, signature %s: argument in method definition changed from (%s) to (%s)"
msgstr "Pour la fonction %s, signature %s : l'argument dans la définition de méthode est changé de (%s) vers (%s)"

#. R/RClassUtils.R: gettextf("Found more than one class \"%s\" in cache; using the first, from namespace '%s'",     value[[1]]@className, pkgs[1])
#: R/RClassUtils.R:0
msgid "Found more than one class \"%s\" in cache; using the first, from namespace '%s'"
msgstr "Plus d’une classe \"%s\" est trouvée en cache : Utilisation de la première, depuis l’espace de noms '%s'"

#. R/Methods.R: gettextf("Function %s is a group generic; do not call it directly",     sQuote(name))
#: R/Methods.R:0
msgid "Function %s is a group generic; do not call it directly"
msgstr "La fonction %s est un groupe générique ; Ne l'appelez pas directement"

#. R/Methods.R: gettextf("Function %s is already a group generic; no change",     sQuote(name))
#: R/Methods.R:0
msgid "Function %s is already a group generic; no change"
msgstr "La fonction %s est déjà un groupe générique ; Pas de changement"

#. R/MethodsList.R: gettextf("In %s: use of \"MethodsList\" metadata objects is defunct.",     deparse(this))
#: R/MethodsList.R:0
msgid "In %s: use of \"MethodsList\" metadata objects is defunct."
msgstr "Dans %s : l'utilisation des objets de métadonnée \"MethodList\" est obsolète."

#. R/MethodsList.R: gettextf("In %s: use of \"MethodsList\" metadata objects is deprecated.",     deparse(this))
#: R/MethodsList.R:0
msgid "In %s: use of \"MethodsList\" metadata objects is deprecated."
msgstr "Dans %s : l'utilisation des objets de métadonnée \"MethodList\" est obsolète."

#. R/trace.R: gettextf("Methods inserted for function %s(): %s", f, paste(methodsInserted,     collapse = ", "))
#: R/trace.R:0
msgid "Methods inserted for function %s(): %s"
msgstr "Méthodes insérées pour la fonction %s() : %s"

#. R/RMethodUtils.R: gettextf("Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information",     sQuote(fdef@generic))
#: R/RMethodUtils.R:0
msgid "Methods list objects are not maintained in this version of R:  request for function %s may return incorrect information"
msgstr "Les objets de liste de méthodes ne sont pas maintenus dans cette version de R : la requête pour la fonction %s produit peut-être une information incorrecte"

#. R/refClass.R: gettextf("Methods not found: %s", paste(dQuote(methods[missing]),     collapse = ", "))
#: R/refClass.R:0
msgid "Methods not found: %s"
msgstr "Méthodes introuvables : %s"

#. R/trace.R: gettextf("Modified functions inserted through trace(): %s", paste(objectsDone,     collapse = ", "))
#: R/trace.R:0
msgid "Modified functions inserted through trace(): %s"
msgstr "Fonctions modifiées insérées par l'intermédiaire de trace() : %s"

#. R/trace.R: gettextf("New functions are not currently inserted (not untraceable): %s",     paste(newObjects, collapse = ", "))
#: R/trace.R:0
msgid "New functions are not currently inserted (not untraceable): %s"
msgstr "Les nouvelles fonctions ne sont pas encore insérées (impossible de les détraçer) : %s"

#. R/SClasses.R: gettextf("No %s names supplied", what)
#: R/SClasses.R:0
msgid "No %s names supplied"
msgstr "Aucuns noms %s fournis"

#. R/NextMethod.R: stop("No next method available")
#: R/NextMethod.R:0
msgid "No next method available"
msgstr "Pas de méthode suivante disponible"

#. R/methodsTable.R: gettextf("No simply inherited methods found for function %s; using non-simple method",     sQuote(fdef@generic))
#: R/methodsTable.R:0
msgid "No simply inherited methods found for function %s; using non-simple method"
msgstr "Aucune méthode de simple héritage n'est trouvée pour la fonction %s ; utilisation d'une méthode à héritage plus complexe"

#. R/trace.R: gettextf("Non-function objects are not currently inserted (not traceable): %s",     paste(notTraceable, collapse = ", "))
#: R/trace.R:0
msgid "Non-function objects are not currently inserted (not traceable): %s"
msgstr "Les objets qui ne sont pas des fonctions ne peuvent pas être insérés pour l'instant (ils ne sont pas traçables) : %s"

#. R/methodsTable.R: gettextf("Note: method with signature %s chosen for function %s,\n target signature %s.\n %s would also be valid",     sQuote(selected), sQuote(attr(cond, "generic")), sQuote(attr(cond,         "target")), paste0("\"", possible[is.na(match(possible,         selected))], "\"", collapse = ", "))
#: R/methodsTable.R:0
msgid ""
"Note: method with signature %s chosen for function %s,\n"
" target signature %s.\n"
" %s would also be valid"
msgstr ""
"Note : méthode avec la signature %s choisie pour la fonction %s,\n"
"signature cible %s.\n"
"%s aurait aussi pu être acceptée"

#. R/RClassUtils.R: gettextf("Note: some superclasses of class %s in package %s have duplicate definitions.  This definition is not being treated as equivalent to that from package %s",     dQuote(def@className), sQuote(def@package), sQuote(prev@package))
#: R/RClassUtils.R:0
msgid "Note: some superclasses of class %s in package %s have duplicate definitions.  This definition is not being treated as equivalent to that from package %s"
msgstr "Note : quelques super-classes de la classe %s dans le package %s ont des définitions dupliquées. Cette définition n'est pas considérée équivalente à celle du package %s"

#. R/RClassUtils.R: gettextf("Note: the specification for class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class.",     dQuote(def@className), sQuote(def@package), sQuote(prev@package))
#: R/RClassUtils.R:0
msgid "Note: the specification for class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class."
msgstr "Note : une spécification de la classe %s du package %s semble équivalente de celle du package %s et ne conduit donc pas à une définition dupliquée pour cette classe."

#. R/MethodsListClass.R: gettextf("\n    Notes: %s.\n", notei)
#: R/MethodsListClass.R:0
msgid "Notes: %s."
msgstr "Notes : %s."

#. R/BasicClasses.R: gettextf("OOPS: something wrong with '.OldClassesPrototypes[[%d]]'",     i)
#: R/BasicClasses.R:0
msgid "OOPS: something wrong with '.OldClassesPrototypes[[%d]]'"
msgstr "OOPS : il y a un problème avec '.OldClassesPrototypes[[‘%d]]'"

#. R/refClass.R: gettextf("Reference superclasses must come from the same package for the environment to be defined:  got %s and %s",     .nQuote(clRefMethods$.objectPackage), .nQuote(pkg))
#: R/refClass.R:0
msgid "Reference superclasses must come from the same package for the environment to be defined:  got %s and %s"
msgstr "Une super classe de référence doit provenir du même package pour que l’environnement soit défini : j’ai %s et %s"

#. R/Methods.R: gettextf("Restoring default function definition of %s", sQuote(f))
#: R/Methods.R:0
msgid "Restoring default function definition of %s"
msgstr "Rétablissement de la définition par défaut de la fonction %s"

#. R/ClassExtensions.R: gettextf("S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s",     dQuote(class(object)))
#: R/ClassExtensions.R:0
msgid "S3Part() is only defined for classes set up by setOldCLass(), basic classes or subclasses of these:  not true of class %s"
msgstr "S3Part() est défini uniquement pour des classes créées par setOldClass(), des classes de base ou leurs sous-classes : ce n'est pas le cas pour la classe %s"

#. R/method.skeleton.R: gettextf("Skeleton of method written to %s", if (is.character(file)) file else "connection")
#: R/method.skeleton.R:0
msgid "Skeleton of method written to %s"
msgstr "Le squelette de la méthode est écrite dans %s"

#. R/RClassUtils.R: gettextf("The prototype for class %s has undefined slot(s): %s",     dQuote(name), paste0("'", undefinedPrototypeSlots, "'", collapse = ", "))
#: R/RClassUtils.R:0
msgid "The prototype for class %s has undefined slot(s): %s"
msgstr "Le prototype pour la classe %s à un ou des spots non définis : %s"

#. R/MethodsList.R: gettextf("Use %s instead. ", dQuote(instead))
#: R/MethodsList.R:0
msgid "Use %s instead."
msgstr "Utilisez %s à la place."

#. R/as.R: gettextf("a 'replace' method definition in 'setAs' must be a function of two arguments, got %d",     length(args))
#: R/as.R:0
msgid "a 'replace' method definition in 'setAs' must be a function of two arguments, got %d"
msgstr "une définition de méthode 'replace' dans 'setAs' doit être une fonction à deux arguments, or elle en a %d"

#. R/NextMethod.R: gettextf("a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'",     sQuote(f))
#: R/NextMethod.R:0
msgid "a call to callNextMethod() appears in a call to %s, but the call does not seem to come from either a generic function or another 'callNextMethod'"
msgstr "un appel à callNextMethod() apparaît dans un appel à %s, mais l'appel ne semble pas provenir d'une fonction générique ou d'un autre 'callNextMethod'"

#. R/refClass.R: gettextf("a call to superClass() is in the method %s but there is no superclass definition of this method for class %s",     sQuote(me), dQuote(thisClass@className))
#: R/refClass.R:0
msgid "a call to superClass() is in the method %s but there is no superclass definition of this method for class %s"
msgstr "un appel à superClass() est trouvé dans la méthode %s mais aucune superclasse n'est définie pour cette méthode pour la classe %s"

#. R/Methods.R: stop("a function for argument 'f' must be a generic function")
#: R/Methods.R:0
msgid "a function for argument 'f' must be a generic function"
msgstr "une fonction pour l'argument 'f' doit être générique"

#. R/RClassUtils.R: gettextf("a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s",     dQuote(class(prototype@object)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "a prototype object was supplied with object slot of class %s, but the class definition requires an object that is class %s"
msgstr "un objet prototype est fourni avec le slot objet de classe %s, mais la définition de classe nécessite un objet de classe %s"

#. R/RClassUtils.R: gettextf("a prototype was supplied of class %s, but the class definition requires an object that is class %s",     dQuote(class(prototype)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "a prototype was supplied of class %s, but the class definition requires an object that is class %s"
msgstr "un prototype de classe %s est fourni, mais la définition de classe nécessite un objet de classe %s"

#. R/refClass.R: gettextf("a single class name is needed for field %s, got a character vector of length %d",     sQuote(thisName), length(thisField))
#: R/refClass.R:0
msgid "a single class name is needed for field %s, got a character vector of length %d"
msgstr "un nom de classe unique est nécessaire pour le champ %s, un vecteur de chaîne de caractères de longueur %d est fourni"

#. R/RClassUtils.R: gettextf("a validity method must be a function of one argument, got an object of class %s",     dQuote(class(validity)))
#: R/RClassUtils.R:0
msgid "a validity method must be a function of one argument, got an object of class %s"
msgstr "une méthode de validation doit être une fonction a un seul argument, un objet de classe %s est trouvé"

#. R/SClasses.R: gettextf("abnormal type %s is not supported as a superclass of a class definition",     dQuote(type))
#: R/SClasses.R:0
msgid "abnormal type %s is not supported as a superclass of a class definition"
msgstr "désolé, le type %s anormal n'est pas supporté comme superclasse d'une définition de classe"

#. R/RMethodUtils.R: gettextf("action function %s has no arguments, should have at least 1",     sQuote(fname))
#: R/RMethodUtils.R:0
msgid "action function %s has no arguments, should have at least 1"
msgstr "la fonction d'action %s n'a pas d'arguments, elle doit en avoir au moins 1"

#. R/as.R: warning("ambiguous object (length != 1) to coerce to \"name\"")
#: R/as.R:0
msgid "ambiguous object (length != 1) to coerce to \"name\""
msgstr "objet ambigu (longueur différente de 1) à convertir automatiquement en \"name\""

#. R/zzz.R: warning("apparently bad method or class metadata in saved environment;\n",     "move the file or remove the class/method")
#: R/zzz.R:0
msgid "apparently bad method or class metadata in saved environment;"
msgstr "apparemment des métadonnées erronées de classe ou de méthode sont sauvées dans l'environnement ;"

#. R/Methods.R: gettextf("argument %s is not S4", deparse1(substitute(f1)))
#. R/Methods.R: gettextf("argument %s is not S4", deparse1(substitute(f2)))
#: R/Methods.R:0
msgid "argument %s is not S4"
msgstr "l'argument %s n'est pas un objet S4"

#. R/Methods.R: gettextf("argument %s must be a generic function or a single character string; got an object of class %s",     sQuote("f"), dQuote(class(f)))
#: R/Methods.R:0
msgid "argument %s must be a generic function or a single character string; got an object of class %s"
msgstr "l'argument %s doit être une fonction générique ou une chaîne de caractères ; un objet de classe %s est obtenu"

#. R/SClasses.R: gettextf("argument %s must be a list or a character vector; got an object of class %s",     dQuote(what), dQuote(class(fields)))
#: R/SClasses.R:0
msgid "argument %s must be a list or a character vector; got an object of class %s"
msgstr "l'argument %s doit être une liste ou un vecteur de chaîne de caractères ; un objet de classe %s est obtenu"

#. R/oldClass.R: gettextf("argument 'Classes' must be a vector of two classes; got an argument of length %d",     length(Classes))
#: R/oldClass.R:0
msgid "argument 'Classes' must be a vector of two classes; got an argument of length %d"
msgstr "l'argument 'Classes' doit être un vecteur contenant deux classes ; un argument de longueur %d est obtenu à la place"

#. R/oldClass.R: gettextf("argument 'S4Class' must be a class definition: got an object of class %s",     dQuote(class(S4Class)))
#: R/oldClass.R:0
msgid "argument 'S4Class' must be a class definition: got an object of class %s"
msgstr "l'argument 'S4Class' doit être une définition de classe : un objet de classe %s est obtenu à la place"

#. R/RClassUtils.R: stop("argument 'abbreviate' must be 0, 1, 2, or 3")
#: R/RClassUtils.R:0
msgid "argument 'abbreviate' must be 0, 1, 2, or 3"
msgstr "l'argument 'abbreviate' doit être 0, 1, 2 ou 3"

#. R/SClasses.R: stop("argument 'classDef' must be a class definition or the name of a class")
#: R/SClasses.R:0
msgid "argument 'classDef' must be a class definition or the name of a class"
msgstr "l'argument 'classDef' doit être une définition de classe ou le nom d'une classe"

#. R/SClasses.R: gettextf("argument 'classDef' must be a string or a class representation; got an object of class %s",     dQuote(class(classDef)))
#: R/SClasses.R:0
msgid "argument 'classDef' must be a string or a class representation; got an object of class %s"
msgstr "l'argument 'classDef' doit être une chaîne de caractères ou une représentation de classe ; Un objet de classe %s est obtenu"

#. R/Methods.R: gettextf("argument 'f' must be a generic function or %s", .notSingleString(f))
#: R/Methods.R:0
msgid "argument 'f' must be a generic function or %s"
msgstr "l'argument 'f' doit être une fonction générique ou %s"

#. R/RMethodUtils.R: stop("argument 'f' must be a string, generic function, or primitive: got an ordinary function")
#: R/RMethodUtils.R:0
msgid "argument 'f' must be a string, generic function, or primitive: got an ordinary function"
msgstr "l’argument 'f' doit être une chaîne de caractères, une fonction générique, ou une primitive : il s'agit d'une fonction ordinaire"

#. R/RClassUtils.R: stop("argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'")
#: R/RClassUtils.R:0
msgid "argument 'includeSubclasses' must be a logical, either one value or a vector of the same length as argument 'classes'"
msgstr "l'argument 'includeSubclasses' doit être un booléen (logical), soit une valeur unique, ou un vecteur de même longueur que l'argument 'classes'"

#. R/trace.R: stop("argument 'signature' is not meaningful for tracing reference methods")
#: R/trace.R:0
msgid "argument 'signature' is not meaningful for tracing reference methods"
msgstr "l'argument 'signature' n'a aucune signification pour tracer les méthodes de référence"

#. R/Methods.R: warning("argument 'signature' is not meaningful with the current implementation and is ignored \n(extract a subset of the methods list instead)")
#: R/Methods.R:0
msgid ""
"argument 'signature' is not meaningful with the current implementation and is ignored \n"
"(extract a subset of the methods list instead)"
msgstr ""
"l'argument 'signature' n'est pas utilisable dans l'implémentation actuelle et est ignoré\n"
"(extraction d'un sous-ensemble de la liste de méthodes à la place)"

#. R/methodsTable.R: stop("argument 'signatures' must be a character matrix whose rows are method signatures")
#: R/methodsTable.R:0
msgid "argument 'signatures' must be a character matrix whose rows are method signatures"
msgstr "l'argument 'signatures' doit être une matrice de chaînes de caractères dont les lignes sont les signatures de méthode"

#. R/trace.R: stop("argument 'what' should be the name of a function")
#: R/trace.R:0
msgid "argument 'what' should be the name of a function"
msgstr "l'argument 'what' devrait être le nom d'une fonction"

#. R/RMethodUtils.R: stop("argument f must be a generic function with signature \"...\"")
#: R/RMethodUtils.R:0
msgid "argument f must be a generic function with signature \"...\""
msgstr "l'argument f doit être une fonction générique ayant une signature \"...\""

#. R/as.R: gettextf("argument names in 'replace' changed to agree with 'coerce<-' generic:\n%s",     paste(deparse(replace), sep = "\n    "))
#: R/as.R:0
msgid ""
"argument names in 'replace' changed to agree with 'coerce<-' generic:\n"
"%s"
msgstr ""
"les noms des arguments dans 'replace' sont modifiés pour être en accord avec la fonction générique 'coerce<-' :\n"
"%s"

#. R/MethodsList.R: stop("arguments 'names' and 'signature' must have the same length")
#: R/MethodsList.R:0
msgid "arguments 'names' and 'signature' must have the same length"
msgstr "les arguments 'names' et 'signature' doivent être de même taille"

#. R/refClass.R: stop("arguments must all be character string names of fields")
#: R/refClass.R:0
msgid "arguments must all be character string names of fields"
msgstr "les arguments doivent tous être des noms sous forme de chaînes de caractères des champs"

#. R/refClass.R: stop("arguments to methods() must be named, or one named list")
#: R/refClass.R:0
msgid "arguments to methods() must be named, or one named list"
msgstr "les arguments à methods() doivent être nommés, ou dans une liste nommée"

#. R/RClassUtils.R: gettextf("assigning as %s a class representation with internal name %s",     dQuote(Class), dQuote(def@className))
#: R/RClassUtils.R:0
msgid "assigning as %s a class representation with internal name %s"
msgstr "assignation comme %s d'une représentation de classe avec un nom interne %s"

#. R/trace.R: gettextf("assigning over the binding of symbol %s in environment/package %s",     sQuote(what), sQuote(pname))
#: R/trace.R:0
msgid "assigning over the binding of symbol %s in environment/package %s"
msgstr "affectation à travers un lien du symbole %s dans l'environnement/le package %s"

#. R/SClasses.R: gettextf("assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE",     dQuote(valueClass), sQuote(name), dQuote(cl), slotClass)
#: R/SClasses.R:0
msgid "assignment of an object of class %s is not valid for @%s in an object of class %s; is(value, \"%s\") is not TRUE"
msgstr "l'affectation d'un objet de classe %s n'est pas permise pour @%s dans un objet de classe %s ; is(value, \"%s\") ne renvoie pas TRUE"

#. R/SClasses.R: gettextf("assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE",     dQuote(valueClass), sQuote(name), dQuote(cl), slotClass)
#: R/SClasses.R:0
msgid "assignment of an object of class %s is not valid for slot %s in an object of class %s; is(value, \"%s\") is not TRUE"
msgstr "l'affectation d'un objet de classe %s n'est pas permise pour le slot %s dans un objet de classe %s ; is(value, \"%s\") ne renvoie pas TRUE"

#. R/Methods.R: gettextf("bad class specified for element %d (should be a single character string)",     i)
#: R/Methods.R:0
msgid "bad class specified for element %d (should be a single character string)"
msgstr "mauvaise classe spécifiée pour l'élément %d (doit être une simple chaîne de caractères)"

#. R/methodsTable.R: gettextf("bad method object stored in method table, class %s",     dQuote(class(current)))
#: R/methodsTable.R:0
msgid "bad method object stored in method table, class %s"
msgstr "mauvais objet trouvé comme méthode dans la table des méthodes, class %s"

#. R/NextMethod.R: gettextf("bad object found as method (class %s)", dQuote(class(method)))
#: R/NextMethod.R:0
msgid "bad object found as method (class %s)"
msgstr "mauvais objet trouvé comme méthode (class %s)"

#. R/is.R: gettext("both classes must be defined")
#: R/is.R:0
msgid "both classes must be defined"
msgstr "les deux classes doivent être définies"

#. R/NextMethod.R: stop("call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context")
#: R/NextMethod.R:0
msgid "call to 'callNextMethod' does not appear to be in a 'method' or 'callNextMethod' context"
msgstr "l'appel à 'callNextMethod' ne semble pas être dans un contexte 'method' ou 'callNextMethod'"

#. R/Methods.R: stop("callGeneric() must be called from within a method body")
#: R/Methods.R:0
msgid "callGeneric() must be called from within a method body"
msgstr "callGeneric() doit être appelé depuis le code d’une méthode"

#. R/is.R: gettextf("cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package",     dQuote(class1), dQuote(class2))
#: R/is.R:0
msgid "cannot create a 'setIs' relation when neither of the classes (%s and %s) is local and modifiable in this package"
msgstr "impossible de créer une relation 'setIs' lorsqu'aucune des deux classes (%s et %s) n'est locale et modifiable dans ce package"

#. R/trace.R: gettextf("cannot find an environment corresponding to package name '%s\"",     package)
#: R/trace.R:0
msgid "cannot find an environment corresponding to package name '%s\""
msgstr "impossible de trouver un environnement correspondant au nom de package \"%s\""

#. R/BasicClasses.R: stop("cannot have more than one unnamed argument as environment")
#: R/BasicClasses.R:0
msgid "cannot have more than one unnamed argument as environment"
msgstr "impossible d'utiliser plus d'un argument non nommé comme environnement"

#. R/trace.R: gettextf("cannot insert methods for these functions (methods table not found in source): %s",     paste0("\"", methods[notThere], "\"", collapse = ", "))
#: R/trace.R:0
msgid "cannot insert methods for these functions (methods table not found in source): %s"
msgstr "impossible d'insérer les méthodes pour ces fonctions (table de méthodes introuvable dans le source) : %s"

#. R/trace.R: gettextf("cannot insert these (not found in source): %s", paste0("\"",     functions[notThere], "\"", collapse = ", "))
#: R/trace.R:0
msgid "cannot insert these (not found in source): %s"
msgstr "insertion de ceci impossible (introuvable dans les sources) : %s"

#. R/Methods.R: gettextf("cannot remove methods for %s in locked environment/package %s",     sQuote(f), sQuote(getPackageName(db)))
#: R/Methods.R:0
msgid "cannot remove methods for %s in locked environment/package %s"
msgstr "impossible d'éliminer la méthode pour %s dans l'environnement / le package %s verrouillé"

#. R/BasicClasses.R: stop("cannot specify array() arguments when specifying '.Data'")
#: R/BasicClasses.R:0
msgid "cannot specify array() arguments when specifying '.Data'"
msgstr "impossible de spécifier des arguments array() lorsque .Data est spécifié"

#. R/BasicClasses.R: stop("cannot specify matrix() arguments when specifying '.Data'")
#: R/BasicClasses.R:0
msgid "cannot specify matrix() arguments when specifying '.Data'"
msgstr "impossible de spécifier des arguments matrix() lorsque .Data est spécifié"

#. R/trace.R: gettextf("cannot untrace method for %s; no method defined for this signature: %s",     sQuote(what), paste(signature, collapse = ", "))
#: R/trace.R:0
msgid "cannot untrace method for %s; no method defined for this signature: %s"
msgstr "impossible d'éliminer le traçage de méthode pour %s ; Aucune méthode n'est définie pour cette signature : %s"

#. R/trace.R: stop("cannot use 'at' argument unless the function body has the form '{ ... }'")
#: R/trace.R:0
msgid "cannot use 'at' argument unless the function body has the form '{ ... }'"
msgstr "impossible d'utiliser l'argument 'at', à moins que le corps de la fonction n'ait la forme '{ ... }'"

#. R/trace.R: stop("cannot use 'at' argument without a trace expression")
#: R/trace.R:0
msgid "cannot use 'at' argument without a trace expression"
msgstr "impossible d'utiliser l'argument 'at' sans une expression de déboguage"

#. R/SClasses.R: gettextf("cannot use object of class %s in new():  class %s does not extend that class",     dQuote(Classi), dQuote(Class))
#: R/SClasses.R:0
msgid "cannot use object of class %s in new():  class %s does not extend that class"
msgstr "impossible d'utiliser un objet de classe %s dans new() : la classe %s n'étend pas cette classe"

#. R/is.R: gettextf("class %s cannot extend class %s", dQuote(class1), dQuote(class2))
#: R/is.R:0
msgid "class %s cannot extend class %s"
msgstr "la classe %s ne peut étendre la classe %s"

#. R/RClassUtils.R: gettextf("class %s does not have a data part (a .Data slot) defined",     dQuote(class(object)))
#: R/RClassUtils.R:0
msgid "class %s does not have a data part (a .Data slot) defined"
msgstr "la classe %s n'a pas de partie de données définie (un slot .Data)"

#. R/BasicClasses.R: gettextf("class %s does not have an S3 data part, and so is of type \"S4\"; no S3 equivalent",     dQuote(class(from)))
#: R/BasicClasses.R:0
msgid "class %s does not have an S3 data part, and so is of type \"S4\"; no S3 equivalent"
msgstr "la classe %s n'a pas de partie de données S3 définie (un slot .Data), elle est donc de type \"S4\" ; pas d'équivalent S3"

#. R/RClassUtils.R: gettextf("class %s extends an undefined class (%s)", dQuote(name),     dQuote(cl))
#: R/RClassUtils.R:0
msgid "class %s extends an undefined class (%s)"
msgstr "la classe %s étend une classe non définie (%s)"

#. R/RClassUtils.R: gettextf("class %s extends an undefined class, %s", dQuote(ClassDef@className),     dQuote(what))
#: R/RClassUtils.R:0
msgid "class %s extends an undefined class, %s"
msgstr "la classe %s étend une classe non définie, %s"

#. R/refClass.R: gettextf("class %s for field %s is not defined", dQuote(thisField),     sQuote(thisName))
#: R/refClass.R:0
msgid "class %s for field %s is not defined"
msgstr "la classe %s pour le champ %s n'est pas définie"

#. R/RClassUtils.R: gettextf("class %s has a locked definition in package %s", dQuote(Class),     sQuote(getPackageName(where)))
#: R/RClassUtils.R:0
msgid "class %s has a locked definition in package %s"
msgstr "la classe %s a une définition verrouillée dans le package %s"

#. R/SClasses.R: gettextf("class %s has multiple definitions visible; only the first removed",     dQuote(Class))
#: R/SClasses.R:0
msgid "class %s has multiple definitions visible; only the first removed"
msgstr "la classe %s a plusieurs définitions visibles ; Seule la première est détruite"

#. R/is.R: gettextf("class %s has no visible definition from package or environment %s",     dQuote(class2), sQuote(getPackageName(where)))
#: R/is.R:0
msgid "class %s has no visible definition from package or environment %s"
msgstr "la classe %s n'a pas de définition visible depuis le package ou l'environnement %s"

#. R/BasicClasses.R: gettextf("class %s is VIRTUAL; not meaningful to create an S4 object from this class",     dQuote(cl))
#: R/BasicClasses.R:0
msgid "class %s is VIRTUAL; not meaningful to create an S4 object from this class"
msgstr "la classe %s est VIRTUELLE ; créer un objet S4 pour cette classe n'a pas de sens"

#. R/as.R: gettextf("class %s is a class union: 'coerce' relations to a class union are not meaningful",     dQuote(to))
#: R/as.R:0
msgid "class %s is a class union: 'coerce' relations to a class union are not meaningful"
msgstr "la classe %s est une classe d'union : des relations de type 'coerce' vers une classe d'union n'ont pas de sens"

#. R/is.R: gettextf("class %s is defined (with package slot %s) but no metadata object found to revise %s information---not imported?  Making a copy in package %s",     .dQ(class), sQuote(classDef@package), purpose, sQuote(getPackageName(where,         FALSE)))
#: R/is.R:0
msgid "class %s is defined (with package slot %s) but no metadata object found to revise %s information---not imported?  Making a copy in package %s"
msgstr "la classe %s est définie (avec le slot %s du package) mais aucun objet de métadonnées n'est trouvé pour réviser l'information %s --- il n'est pas exporté ? Une copie est réalisée dans le package %s"

#. R/refClass.R: gettextf("class %s is defined but is not a reference class",     dQuote(Class))
#: R/refClass.R:0
msgid "class %s is defined but is not a reference class"
msgstr "la classe %s est définie mais n'est pas une classe de référence"

#. R/SClasses.R: gettextf("class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)",     dQuote(Class), sQuote(classDef@package))
#: R/SClasses.R:0
msgid "class %s is defined, with package %s, but no corresponding metadata object was found (not exported?)"
msgstr "la classe %s est définie, avec le package %s, mais aucun objet de métadonnées correspondant n'est trouvé (il n'est pas exporté, peut-être ?)"

#. R/RClassUtils.R: gettextf("class %s is inheriting an inconsistent superclass structure from class %s, inconsistent with %s",     .dQ(className), .dQ(by), paste(.dQ(coni), collapse = ", "))
#: R/RClassUtils.R:0
msgid "class %s is inheriting an inconsistent superclass structure from class %s, inconsistent with %s"
msgstr "la classe %s hérite d'une structure de superclasse incohérente de la classe %s, incohérente avec %s"

#. R/as.R: gettextf("class %s is not defined in this environment", dQuote(to))
#: R/as.R:0
msgid "class %s is not defined in this environment"
msgstr "la classe %s n'est pas définie dans cet environnement"

#. R/SClasses.R: gettextf("class %s is sealed; 'resetClass' will have no effect",     dQuote(Class))
#: R/SClasses.R:0
msgid "class %s is sealed; 'resetClass' will have no effect"
msgstr "la classe %s est scellée ; 'resetClass' n'aura aucun effet"

#. R/is.R: gettextf("class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'",     dQuote(class1))
#: R/is.R:0
msgid "class %s is sealed; new superclasses can not be defined, except by 'setClassUnion'"
msgstr "la classe %s est scellée ; De nouvelles superclasses ne peuvent être définies, à l'exception de 'setClassUnion'"

#. R/SClasses.R: gettextf("class %s not found on %s; 'resetClass' will have no effect",     dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "class %s not found on %s; 'resetClass' will have no effect"
msgstr "la classe %s est introuvable dans %s ; 'resetClass' n'aura aucun effet"

#. R/RClassUtils.R: stop("class cannot have both an ordinary and hidden data type")
#: R/RClassUtils.R:0
msgid "class cannot have both an ordinary and hidden data type"
msgstr "une classe ne peut avoir simultanément un type 'data' ordinaire et caché"

#. R/SClasses.R: gettextf("class definition cannot extend more than one of these data types: %s",     paste0("\"", type, "\"", collapse = ", "))
#: R/SClasses.R:0
msgid "class definition cannot extend more than one of these data types: %s"
msgstr "la définition de classe ne peut être étendue à plus d'un de ces types de données : %s"

#. R/SClasses.R: gettextf("class definition for %s not found (no action taken)",     dQuote(Class))
#: R/SClasses.R:0
msgid "class definition for %s not found (no action taken)"
msgstr "la définition de classe pour %s est introuvable (aucune action n'est prise)"

#. R/MethodsListClass.R: gettextf("class generator function for class %s from package %s\n",     dQuote(object@className), sQuote(object@package))
#: R/MethodsListClass.R:0
msgid "class generator function for class %s from package %s"
msgstr "fonction génératrice de classe pour la classe %s du package %s"

#. R/refClass.R: gettextf("class must be a reference class representation or a character string; got an object of class %s",     dQuote(class(Class)))
#: R/refClass.R:0
msgid "class must be a reference class representation or a character string; got an object of class %s"
msgstr "la classe doit être une représentation de classe de référence ou une chaine de caractères ; Un objet de classe %s est obtenu à la place"

#. R/refClass.R: gettextf("code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)",     dQuote(Class), sQuote("codetools"))
#: R/refClass.R:0
msgid "code for methods in class %s was not checked for suspicious field assignments (recommended package %s not available?)"
msgstr "le code des méthodes de la classe %s n'a pas été vérifié pour les affectations de champs suspectes (package recommandé %s indisponible ?)"

#. R/RClassUtils.R: gettextf("conflicting definition of data part: .Data = %s, superclass implies %s",     dQuote(elNamed(properties, ".Data")), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "conflicting definition of data part: .Data = %s, superclass implies %s"
msgstr "définition conflictuelle de la partie de données : .Data = %s, or la superclasse implique %s"

#. R/MethodsList.R: gettextf("default method must be a method definition, a primitive or NULL: got an object of class %s",     dQuote(class(method)))
#: R/MethodsList.R:0
msgid "default method must be a method definition, a primitive or NULL: got an object of class %s"
msgstr "la méthode par défaut doit être une définition de méthode, une primitive ou NULL ; c'est un objet de classe %s"

#. R/refClass.R: stop("direct calls to callSuper() are invalid:  should only be called from another method")
#: R/refClass.R:0
msgid "direct calls to callSuper() are invalid:  should only be called from another method"
msgstr "les appels directs à callSuper() ne sont pas autorisés : ils ne peuvent être réalisés qu'à partir d'une autre méthode"

#. R/trace.R: gettextf("does not seem to be a method table for generic %s in tracing environment",     sQuote(what))
#: R/trace.R:0
msgid "does not seem to be a method table for generic %s in tracing environment"
msgstr "ne semble pas être une table de méthode pour le générique %s dans l'environnement de traçage"

#. R/SClasses.R: gettextf("duplicate class names among superclasses: %s", paste(.dQ(includes[duplicated(includes)]),     collapse = ", "))
#: R/SClasses.R:0
msgid "duplicate class names among superclasses: %s"
msgstr "noms de classes dupliqués dans les superclasses : %s"

#. R/MethodsList.R: gettextf("duplicate element names in 'MethodsList' at level %d: %s",     level, paste("\"", unique(mnames[duplicated(mnames)]), "\"",         collapse = ", "))
#: R/MethodsList.R:0
msgid "duplicate element names in 'MethodsList' at level %d: %s"
msgstr "noms d'éléments dupliqués dans 'MethodsList' au niveau %d : %s"

#. R/SClasses.R: gettextf("duplicated slot names: %s", paste(sQuote(snames[duplicated(snames)]),     collapse = ", "))
#: R/SClasses.R:0
msgid "duplicated slot names: %s"
msgstr "noms de slots dupliqués : %s"

#. R/MethodsList.R: gettextf("element %d at level %d (class %s) cannot be interpreted as a function or named list",     i, level, dQuote(class(eli)))
#: R/MethodsList.R:0
msgid "element %d at level %d (class %s) cannot be interpreted as a function or named list"
msgstr "l'élément %d au niveau %d (classe %s) ne peut être interprété comme une fonction ou une liste nommée"

#. R/SClasses.R: gettextf("element %d of the representation was not a single character string",     i)
#: R/SClasses.R:0
msgid "element %d of the representation was not a single character string"
msgstr "l'élément %d de la représentation n'est pas une chaîne de caractères unique"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s and unable to remove definition from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s and unable to remove definition from %s"
msgstr "erreur dans les classes contenues (%s) pour la classe %s et impossible d'éliminer la définition pour %s"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s and unable to restore previous definition from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s and unable to restore previous definition from %s"
msgstr "erreur dans les classes contenues (%s) pour la classe %s et impossible de récupérer la définition précédente depuis %s"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s; class definition removed from %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s; class definition removed from %s"
msgstr "erreur dans les classes contenues (%s) pour la classe %s ; Définition de classe éliminées pour %s"

#. R/SClasses.R: gettextf("error in contained classes (%s) for class %s; previous definition restored to %s",     msg, dQuote(Class), sQuote(getPackageName(where)))
#: R/SClasses.R:0
msgid "error in contained classes (%s) for class %s; previous definition restored to %s"
msgstr "erreur dans les classes contenues (%s) pour la classe %s ; Définition précédente récupérée vers %s"

#. R/RMethodUtils.R: gettextf("error in load action %s for package %s: %s: %s", aname,     getPackageName(where), callString, value$message)
#: R/RMethodUtils.R:0
msgid "error in load action %s for package %s: %s: %s"
msgstr "erreur dans l'action de chargement %s pour le package %s : %s : %s"

#. R/Methods.R: gettextf("error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)",     sQuote(f), dQuote(class(fdef)))
#: R/Methods.R:0
msgid "error in updating S4 generic function %s; the function definition is not an S4 generic function (class %s)"
msgstr "erreur lors de la mise-à-jour de la fonction générique S4 %s ; La définition de fonction n'est pas une fonction générique S4 (classe %s)"

#. R/RMethodUtils.R: gettextf("expanding the signature to include omitted arguments in definition: %s",     paste(sigNames[omittedSig], "= \"missing\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "expanding the signature to include omitted arguments in definition: %s"
msgstr "développement de la signature pour y inclure les arguments omis dans la définition : %s"

#. R/addedFunctions.R: gettextf("expected a non-empty character string for argument 'name'")
#: R/addedFunctions.R:0
#, fuzzy
msgid "expected a non-empty character string for argument 'name'"
msgstr "une chaîne de caractères non vide est attendue pour l'argument name"

#. R/Methods.R: gettextf("expected a non-empty character string for argument name")
#: R/Methods.R:0
msgid "expected a non-empty character string for argument name"
msgstr "une chaîne de caractères non vide est attendue pour l'argument name"

#. R/oldClass.R: gettextf("explicit coercion of old-style class (%s) is not defined",     paste(class(from), collapse = ", "))
#: R/oldClass.R:0
msgid "explicit coercion of old-style class (%s) is not defined"
msgstr "la conversion explicite de classes d'ancien style (%s) n'est pas définie"

#. R/oldClass.R: gettextf("explicit replacement not defined for as(x, \"%s\") <- value for old-style class %s",     to, dQuote(class(from)[1L]))
#: R/oldClass.R:0
msgid "explicit replacement not defined for as(x, \"%s\") <- value for old-style class %s"
msgstr "un remplacement explicite n'est pas défini pour as(x, \"%s\") <- value pour la classe d'ancien style %s"

#. R/methodsTable.R: stop("failed to find expected group generic function: ", what)
#: R/methodsTable.R:0
msgid "failed to find expected group generic function:"
msgstr "impossible de trouver la fonction générique du groupe attendu :"

#. R/Methods.R: gettextf("fdef appears to be a generic function, but with generic name %s instead of %s",     sQuote(gen), sQuote(f))
#: R/Methods.R:0
#, fuzzy
msgid "fdef appears to be a generic function, but with generic name %s instead of %s"
msgstr "la fonction %s semble être une fonction générique, mais avec le nom générique %s"

#. R/refClass.R: gettextf("field %s is already locked", sQuote(what))
#: R/refClass.R:0
msgid "field %s is already locked"
msgstr "le champ \"%s est déjà verrouillé"

#. R/refClass.R: gettextf("field %s of class %s has a non-default binding and cannot be locked",     sQuote(what), dQuote(className))
#: R/refClass.R:0
msgid "field %s of class %s has a non-default binding and cannot be locked"
msgstr "le champ %s de la classe %s a un lien non standard et ne peut être verrouillé"

#. R/refClass.R: gettextf("field %s was supplied as an object of class %s; must be a class name or a binding function",     sQuote(thisName), dQuote(class(thisField)))
#: R/refClass.R:0
msgid "field %s was supplied as an object of class %s; must be a class name or a binding function"
msgstr "le champ %s est fourni comme étant un objet de classe %s ; il doit être un nom de classe ou une fonction de lien"

#. R/Methods.R: gettextf("first argument should be the names of one of more generic functions (got object of class %s)",     dQuote(class(f)))
#: R/Methods.R:0
msgid "first argument should be the names of one of more generic functions (got object of class %s)"
msgstr "le premier argument doit être le ou les noms des fonctions génériques (un objet de classe %s est fourni)"

#. R/RMethodUtils.R: gettextf("formal arguments (%s) omitted in the method definition cannot be in the signature",     bad2)
#: R/RMethodUtils.R:0
msgid "formal arguments (%s) omitted in the method definition cannot be in the signature"
msgstr "les arguments formels (%s) omis dans la définition de la méthode ne peuvent figurer dans la signature"

#. R/Methods.R: gettext("formal arguments differ (in default values?)")
#: R/Methods.R:0
msgid "formal arguments differ (in default values?)"
msgstr "les arguments formels diffèrents (pour les valeurs par défaut ?)"

#. R/Methods.R: gettextf("formal arguments differ: (%s), (%s)", paste(a1, collapse = ", "),     paste(a2, collapse = ", "))
#: R/Methods.R:0
msgid "formal arguments differ: (%s), (%s)"
msgstr "les arguments formels diffèrent : (%s), (%s)"

#. R/RMethodUtils.R: stop(.renderSignature(f, signature), "formal arguments in method and generic do not appear in the same order",     call. = FALSE)
#. R/RMethodUtils.R: stop(.renderSignature(generic@generic, signature), "formal arguments in method and generic do not appear in the same order",     call. = FALSE)
#: R/RMethodUtils.R:0
msgid "formal arguments in method and generic do not appear in the same order"
msgstr "les arguments formels n'apparaissent pas dans le même ordre dans la méthode et dans la fonction générique"

#. R/Methods.R: stop("function supplied as argument 'f' must be a generic")
#: R/Methods.R:0
msgid "function supplied as argument 'f' must be a generic"
msgstr "la fonction fournie dans l'argument 'f' doit être générique"

#. R/Methods.R: gettextf("generic function %s not found for removal", sQuote(f))
#: R/Methods.R:0
msgid "generic function %s not found for removal"
msgstr "la fonction générique %s est introuvable pour son élimination"

#. R/Methods.R: gettextf("generic function supplied was not created for %s",     sQuote(name))
#: R/Methods.R:0
msgid "generic function supplied was not created for %s"
msgstr "la fonction générique fournie n'est pas créée pour %s"

#. R/Methods.R: gettextf("generic names differ: %s, %s", .dQ(f1@generic), .dQ(f2@generic))
#: R/Methods.R:0
msgid "generic names differ: %s, %s"
msgstr "les noms génériques diffèrent : %s, %s"

#. R/RMethodUtils.R: stop("got a negative maximum number of frames to look at")
#: R/RMethodUtils.R:0
msgid "got a negative maximum number of frames to look at"
msgstr "une valeur négative est trouvée pour le nombre maximum de contextes (frames) à rechercher"

#. R/Methods.R: gettextf("groups differ: %s, %s", .dQ(gpString(f1@group)), .dQ(gpString(f2@group)))
#: R/Methods.R:0
msgid "groups differ: %s, %s"
msgstr "les groupes diffèrent : %s, %s"

#. R/Methods.R: gettextf("if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default",     name)
#: R/Methods.R:0
msgid "if the 'def' argument is supplied, it must be a function that calls standardGeneric(\"%s\") or is the default"
msgstr "si l'argument 'def' est fourni, il doit être une fonction appelant standardGeneric(\"%s\") ou être la valeur par défaut"

#. R/RMethodUtils.R: gettextf("in changing formal arguments in %s, some of the old names are not in fact arguments: %s",     msg, paste0("\"", old[is.na(match(old, names(dlist)))], "\"",         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "in changing formal arguments in %s, some of the old names are not in fact arguments: %s"
msgstr "lors de la modification des arguments formels dans %s, quelques uns des anciens noms ne sont en réalité pas des arguments : %s"

#. R/RClassUtils.R: gettextf("in constructing the prototype for class %s, slots in prototype and not in class: %s",     dQuote(className), paste(extra, collapse = ", "))
#: R/RClassUtils.R:0
msgid "in constructing the prototype for class %s, slots in prototype and not in class: %s"
msgstr "lors de la construction du prototype pour la classe %s, des slots sont dans le prototype mais pas dans la classe : %s"

#. R/RClassUtils.R: gettextf("in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s",     dQuote(className), dQuote(.class1(prototype)), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "in constructing the prototype for class %s: prototype has class %s, but the data part specifies class %s"
msgstr "lors de la construction du prototype pour la classe %s : le prototype est de classe %s, mais les données spécifient la classe %s"

#. R/RClassUtils.R: gettextf("in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)",     dQuote(name), dQuote(dataPartClass))
#: R/RClassUtils.R:0
msgid "in defining class %s, the supplied data part class, %s is not valid (must be a basic class or a virtual class combining basic classes)"
msgstr "lors de la définition de classe %s, la classe fournie pour la partie de données, %s, n'est pas correcte (doit être une classe basique ou une classe virtuelle qui combine des classes basiques)"

#. R/RClassUtils.R: gettextf("in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")",     dQuote(ClassDef@className), dQuote(what), dQuote(class(exti)))
#: R/RClassUtils.R:0
msgid "in definition of class %s, information for superclass %s is of class %s (expected \"SClassExtension\")"
msgstr "dans la définition de classe %s, l'information de superclasse %s est de classe %s (attendu \"SClassExtension\")"

#. R/RClassUtils.R: gettextf("in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s",     dQuote(className), paste(pnames[check], "(class", .dQ(slotDefs[match(pnames[check],         slotNames)]), ")", collapse = ", "))
#: R/RClassUtils.R:0
msgid "in making the prototype for class %s elements of the prototype failed to match the corresponding slot class: %s"
msgstr "lors de la construction du prototype pour la classe %s, des éléments du prototype ne correspondent pas aux slots de la classe : %s"

#. R/RMethodUtils.R: gettextf("in method for %s with signature %s: ", sQuote(f), sQuote(msig))
#: R/RMethodUtils.R:0
msgid "in method for %s with signature %s:"
msgstr "dans la méthode pour %s avec la signature %s :"

#. R/oldClass.R: gettextf("inconsistent old-style class information for %s (maybe mixing old and new classes?)",     dQuote(cl))
#: R/oldClass.R:0
msgid "inconsistent old-style class information for %s (maybe mixing old and new classes?)"
msgstr "information d'une classe d'ancien style (S3) incompatible pour %s (un mélange entre des anciennes et nouvelles classes est peut-être fait ?)"

#. R/oldClass.R: gettextf("inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part",     dQuote(cl), dQuote(prevClass))
#: R/oldClass.R:0
msgid "inconsistent old-style class information for %s; the class is defined but does not extend %s and is not valid as the data part"
msgstr "information d'une classe d'ancien style (S3) incompatible pour %s ; la classe est définie mais n'étend pas %s et n'est pas utilisable comme sa partie 'data'"

#. R/RClassUtils.R: gettextf("initializing objects from class %s with these arguments is not supported",     dQuote(Class))
#: R/RClassUtils.R:0
msgid "initializing objects from class %s with these arguments is not supported"
msgstr "l'initialisation d'objets de la classe %s avec ces arguments n'est pas supportée"

#. R/MethodsList.R: stop("inserting method corresponding to empty signature")
#: R/MethodsList.R:0
msgid "inserting method corresponding to empty signature"
msgstr "insertion d'une méthode correspondant à une signature vide"

#. R/MethodsList.R: gettextf("inserting method into non-methods-list object (class %s)",     dQuote(.class1(mlist)))
#: R/MethodsList.R:0
msgid "inserting method into non-methods-list object (class %s)"
msgstr "insertion d'une méthode dans un objet qui n'est pas une liste de méthodes (classe %s)"

#. R/MethodsList.R: gettextf("inserting method with invalid signature matching argument '...' to class %s",     dQuote(signature[[1L]]))
#: R/MethodsList.R:0
msgid "inserting method with invalid signature matching argument '...' to class %s"
msgstr "insertion d'une méthode ayant une signature incorrecte correspondante à l'argument '...' pour la classe %s"

#. R/refClass.R: stop("invalid 'Class' argument:  should be a single string")
#: R/refClass.R:0
msgid "invalid 'Class' argument:  should be a single string"
msgstr "mauvais argument 'Class' :  doit être une chaîne de caractères unique"

#. R/show.R: gettextf("invalid 'ignore' argument; should be a class definition or a character vector, got an object of class %s",     dQuote(class(ignore)))
#: R/show.R:0
msgid "invalid 'ignore' argument; should be a class definition or a character vector, got an object of class %s"
msgstr "argument 'ignore' incorrect ; doit être une définition de classe ou un vecteur de chaînes de caractères ; un objet de classe %s est obtenu"

#. R/MethodsList.R: stop("invalid 'package' slot or attribute, wrong length")
#: R/MethodsList.R:0
msgid "invalid 'package' slot or attribute, wrong length"
msgstr "slot ou attribut 'package' incorrect, longueur erronée"

#. R/trace.R: gettextf("invalid 'source' argument: expected file names or a connection but got an object of class %s",     dQuote(class(source)[[1L]]))
#: R/trace.R:0
msgid "invalid 'source' argument: expected file names or a connection but got an object of class %s"
msgstr "argument 'source' incorrect : un ou des noms de fichiers ou une connexion sont attendus, un objet de classe %s est fourni"

#. R/oldClass.R: gettextf("invalid S4 class corresponding to S3 class: slots in S4 version must extend corresponding slots in S3 version: fails for %s",     paste0("\"", bad, "\"", collapse = ", "))
#: R/oldClass.R:0
#, fuzzy
msgid "invalid S4 class corresponding to S3 class: slots in S4 version must extend corresponding slots in S3 version: fails for %s"
msgstr "classe S4 incorrecte en correspondance à une classe S3 : les slots dans la version S4 doivent étendre les slots correspondants de la version S3 : échec pour %s"

#. R/Methods.R: gettextf("invalid argument 'name': %s", .isSingleName(name))
#: R/Methods.R:0
msgid "invalid argument 'name': %s"
msgstr "argument 'name' erroné : %s"

#. R/refClass.R: gettextf("invalid assignment for reference class field %s, should be from class %s or a subclass (was class %s)",     sQuote(fieldName), dQuote(fieldClass), dQuote(class(value)))
#: R/refClass.R:0
msgid "invalid assignment for reference class field %s, should be from class %s or a subclass (was class %s)"
msgstr "le remplaçant pour le champ de la classe de référence %s doit être de la classe %s ou d'une sous-classe (une classe %s est obtenue à la place)"

#. R/show.R: gettextf("invalid call to 'classLabel': expected a name or a class definition, got an object of class %s",     classLabel(class(Class)))
#: R/show.R:0
msgid "invalid call to 'classLabel': expected a name or a class definition, got an object of class %s"
msgstr "appel incorrect à 'classLabel' : un nom ou une classe de définition est attendu, un objet de classe %s est obtenu"

#. R/SClasses.R: gettextf("invalid class %s object", dQuote(Class))
#: R/SClasses.R:0
msgid "invalid class %s object"
msgstr "objet de classe %s incorrect"

#. R/MethodsList.R: gettextf("invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name",     i)
#: R/MethodsList.R:0
msgid "invalid element in a list for \"signature\" argument; element %d is neither a class definition nor a class name"
msgstr "élément incorrect dans une liste pour l'argument \"signature\" ; l'élément %d n'est ni une définition de classe ni son nom"

#. R/RMethodUtils.R: gettextf("invalid element in the \"groupMembers\" slot (class %s)",     dQuote(class(x)))
#: R/RMethodUtils.R:0
msgid "invalid element in the \"groupMembers\" slot (class %s)"
msgstr "élément incorrect dans le slot \"groupMembers\" (classe %s)"

#. R/MethodsList.R: stop("invalid first argument: should be the name of the first argument in the dispatch")
#: R/MethodsList.R:0
msgid "invalid first argument: should be the name of the first argument in the dispatch"
msgstr "premier argument incorrect : il doit être le nom du premier argument dans le dispatching"

#. R/methodsTable.R: gettextf("invalid group generic function in search for inherited method (class %s)",     dQuote(class(gen)))
#: R/methodsTable.R:0
msgid "invalid group generic function in search for inherited method (class %s)"
msgstr "fonction générique de groupe incorrecte lors de la recherche de méthode héritée (classe %s)"

#. R/languageEl.R: stop("invalid index for function argument")
#: R/languageEl.R:0
msgid "invalid index for function argument"
msgstr "indice incorrect pour l'argument de fonction"

#. R/Methods.R: gettextf("invalid method definition: expected a function, got an object of class %s",     dQuote(class(definition)))
#: R/Methods.R:0
msgid "invalid method definition: expected a function, got an object of class %s"
msgstr "définition de méthode incorrecte : une fonction est attendue et un objet de classe %s est fourni"

#. R/methodsTable.R: gettextf("invalid method element for signature %s at level %d (should be MethodDefinition or .Primitive, had class %s)",     sQuote(classes[[j]]), i, dQuote(class(el)))
#: R/methodsTable.R:0
#, fuzzy
msgid "invalid method element for signature %s at level %d (should be MethodDefinition or .Primitive, had class %s)"
msgstr "élément mlist incorrect pour la signature %s au niveau %d (devrait être MethodDefinition ou .Primitive, a la classe %s)"

#. R/methodsTable.R: stop("invalid methods table request")
#: R/methodsTable.R:0
msgid "invalid methods table request"
msgstr "demande de table de méthodes incorrecte"

#. R/MethodsListClass.R: gettextf("invalid object for formal method definition: type %s",     dQuote(typeof(def)))
#: R/MethodsListClass.R:0
msgid "invalid object for formal method definition: type %s"
msgstr "objet incorrect pour la définition formelle de méthode : type %s"

#. R/methodsTable.R: gettextf("invalid object in meta table of methods for %s, label %s, had class %s",     sQuote(generic@generic), sQuote(what), dQuote(class(obj)))
#: R/methodsTable.R:0
msgid "invalid object in meta table of methods for %s, label %s, had class %s"
msgstr "objet incorrect dans la table de métadonnées des méthodes pour %s, l'étiquette %s, avait la classe %s"

#. R/methodsTable.R: gettextf("invalid object in methods table (%s), expected a method, got an object of class %s",     sQuote(what), dQuote(class(method)))
#: R/methodsTable.R:0
msgid "invalid object in methods table (%s), expected a method, got an object of class %s"
msgstr "objets incorrects dans la table des méthodes (%s) : une méthode est attendue et un objet de classe %s est fourni"

#. R/methodsTable.R: gettextf("invalid or unset methods table in generic function %s",     sQuote(fdef@generic))
#: R/methodsTable.R:0
msgid "invalid or unset methods table in generic function %s"
msgstr "table de méthodes incorrecte ou non définie pour la fonction générique %s"

#. R/refClass.R: gettextf("invalid replacement: reference class field %s is read-only",     sQuote(fieldName))
#: R/refClass.R:0
msgid "invalid replacement: reference class field %s is read-only"
msgstr "remplacement incorrect : le champ de la classe de référence %s est en lecture seule"

#. R/RMethodUtils.R: gettextf("invalid value from generic function %s, class %s, expected %s",     sQuote(fname), dQuote(class(object)), paste(dQuote(classes),         collapse = " or "))
#: R/RMethodUtils.R:0
msgid "invalid value from generic function %s, class %s, expected %s"
msgstr "valeur incorrecte pour la fonction générique %s, classe %s, mais attendu %s"

#. R/refClass.R: gettextf("local assignment to field name will not change the field:\n    %s\n Did you mean to use \"<<-\"? ( in method %s for class %s)",     paste(unlist(assigned$locals)[localsAreFields], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"local assignment to field name will not change the field:\n"
"    %s\n"
" Did you mean to use \"<<-\"? ( in method %s for class %s)"
msgstr ""
"une affectation locale vers le nom de champ ne change pas ce champ :\n"
"    %s\n"
"Vouliez-vous utiliser \"<<-\" ? (dans la méthode %s de la classe %s)"

#. R/RMethodUtils.R: gettextf("making a generic for special function %s", sQuote(f))
#: R/RMethodUtils.R:0
msgid "making a generic for special function %s"
msgstr "création d'un fonction générique pour la fonction spéciale %s"

#. R/trace.R: warning("making a traced version of a special; arguments may be altered")
#: R/trace.R:0
msgid "making a traced version of a special; arguments may be altered"
msgstr "création d'une version de déboguage d'une fonction spéciale ; Les arguments peuvent être altérés"

#. R/debug.R: warning("method is not being debugged")
#: R/debug.R:0
msgid "method is not being debugged"
msgstr "la méthode n’est pas déboguée"

#. R/RMethodUtils.R: gettextf("methods can add arguments to the generic %s only if '...' is an argument to the generic",     sQuote(generic@generic))
#: R/RMethodUtils.R:0
msgid "methods can add arguments to the generic %s only if '...' is an argument to the generic"
msgstr "les méthodes peuvent ajouter des arguments à la fonction générique %s seulement si '...' est un argument de cette fonction générique"

#. R/as.R: gettextf("methods currently exist for coercing from %s to %s; they will be replaced.",     dQuote(from), dQuote(to))
#: R/as.R:0
msgid "methods currently exist for coercing from %s to %s; they will be replaced."
msgstr "des méthodes existent actuellement pour convertir automatiquement de %s vers %s ; Elles seront remplacées."

#. R/refClass.R: gettextf("methods declared in usingMethods() but not found: %s",     paste0(declared[!declared %in% allMethods], collapse = ", "))
#: R/refClass.R:0
msgid "methods declared in usingMethods() but not found: %s"
msgstr "des méthodes sont déclarées dans usingMethods() mais elles sont introuvables : %s"

#. R/BasicFunsList.R: gettextf("methods may not be defined for primitive function %s in this version of R",     sQuote(f))
#: R/BasicFunsList.R:0
msgid "methods may not be defined for primitive function %s in this version of R"
msgstr "les méthodes ne sont peut-être pas définies pour la fonction primitive %s dans cette version de R"

#. R/Defunct.R: stop("methods:::bind_activation() is defunct;\n rather provide methods for cbind2() / rbind2()")
#: R/Defunct.R:0
msgid ""
"methods:::bind_activation() is defunct;\n"
" rather provide methods for cbind2() / rbind2()"
msgstr ""
"methods:::bind_activation() is défunte ;\n"
" Fournissez plutôt des méthodes pour cbind2() / rbind2()"

#. R/RMethodUtils.R: gettextf("missing function for load action: %s", what)
#: R/RMethodUtils.R:0
msgid "missing function for load action: %s"
msgstr "aucune définition n'existe pour la fonction load : %s"

#. R/MethodsListClass.R: gettextf("missing package slot (%s) in object of class %s (package info added)",     packageSlot(co), dQuote(class(.Object)))
#: R/MethodsListClass.R:0
msgid "missing package slot (%s) in object of class %s (package info added)"
msgstr "slot (%s) package manquant dans l'objet de classe %s (info 'package' ajoutée)"

#. R/MethodsList.R: gettextf("more elements in the method signature (%d) than in the generic signature (%d) for function %s",     length(signature), length(anames), sQuote(fun@generic))
#: R/MethodsList.R:0
msgid "more elements in the method signature (%d) than in the generic signature (%d) for function %s"
msgstr "plus d'éléments dans la signature de méthode (%d) que dans la signature du générique (%d) pour la fonction %s"

#. R/RClassUtils.R: gettextf("more than one possible class for the data part: using %s rather than %s",     .dQ(prevDataPartClass), .dQ(value))
#: R/RClassUtils.R:0
msgid "more than one possible class for the data part: using %s rather than %s"
msgstr "plus d'une classe possible pour la partie de données : utilisation de %s au lieu de %s"

#. R/zzz.R: warning("apparently bad method or class metadata in saved environment;\n",     "move the file or remove the class/method")
#: R/zzz.R:0
msgid "move the file or remove the class/method"
msgstr "déplacez le fichier ou éliminez la classe / méthode"

#. R/SClasses.R: gettextf("multiple class definitions for %s from packages: %s; picking the first",     dQuote(className), paste(sQuote(pkgs), collapse = ", "))
#: R/SClasses.R:0
msgid "multiple class definitions for %s from packages: %s; picking the first"
msgstr "définitions de classe multiples pour %s depuis les packages : %s ; la première est utilisée"

#. R/RMethodUtils.R: gettextf("multiple definitions exist for class %s, but the supplied package (%s) is not one of them (%s)",     dQuote(classi), sQuote(pkgi), paste(dQuote(get(classi, envir = .classTable)),         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "multiple definitions exist for class %s, but the supplied package (%s) is not one of them (%s)"
msgstr "il existe plusieurs définitions pour la classe %s, mais le package fourni (%s) ne contient pas l'une d'elles (%s)"

#. R/RMethodUtils.R: gettextf("multiple definitions exist for class %s; should specify one of them (%s), e.g. by className()",     dQuote(classi), paste(dQuote(get(classi, envir = .classTable)),         collapse = ", "))
#: R/RMethodUtils.R:0
msgid "multiple definitions exist for class %s; should specify one of them (%s), e.g. by className()"
msgstr "il existe plusieurs définitions pour la classe %s, l'une d'entre elles (%s) doit être spécifiée, e.g. en utilisant className()"

#. R/promptClass.R: gettextf("multiple definitions of %s found; using the one on %s",     dQuote(clName), whereClass)
#: R/promptClass.R:0
msgid "multiple definitions of %s found; using the one on %s"
msgstr "plusieurs définition de %s sont trouvées ; Celle dans %s est utilisée"

#. R/RMethodUtils.R: gettextf("multiple direct matches: %s; using the first of these",     .pasteC(classes))
#: R/RMethodUtils.R:0
msgid "multiple direct matches: %s; using the first of these"
msgstr "correspondances directes multiples : %s ; utilisation de la première d'entre elles"

#. R/RMethodUtils.R: gettextf("multiple equivalent inherited matches: %s; using the first of these",     .pasteC(classes))
#: R/RMethodUtils.R:0
msgid "multiple equivalent inherited matches: %s; using the first of these"
msgstr "correspondances héritées équivalentes multiples : %s ; utilisation de la première d'entre elles"

#. R/trace.R: gettextf("multiple generics match pattern, using table %s", table)
#: R/trace.R:0
msgid "multiple generics match pattern, using table %s"
msgstr "plusieurs génériques correespondent au masque, utilisation de la table %s"

#. R/Methods.R: gettextf("must provide an environment table; got class %s", dQuote(class(what)))
#: R/Methods.R:0
msgid "must provide an environment table; got class %s"
msgstr "il fallait fournir une table d'environnement, et c'est un objet de classe %s"

#. R/Methods.R: stop("must supply 'generic.function' or 'class'")
#: R/Methods.R:0
msgid "must supply 'generic.function' or 'class'"
msgstr "il faut fournir 'generic.function' or 'class'"

#. R/Methods.R: gettextf("must supply a function skeleton for %s, explicitly or via an existing function",     sQuote(name))
#: R/Methods.R:0
msgid "must supply a function skeleton for %s, explicitly or via an existing function"
msgstr "il faut fournir le squelette d'une fonction pour %s, de manière explicite ou via une fonction existante"

#. R/RMethodUtils.R: gettextf("must supply either a generic function or a function as default for %s",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "must supply either a generic function or a function as default for %s"
msgstr "il faut fournir soit une fonction générique, soit une fonction par défaut pour %s"

#. R/method.skeleton.R: stop("need a definition for the method here")
#: R/method.skeleton.R:0
msgid "need a definition for the method here"
msgstr "une définition est nécessaire ici pour la méthode"

#. R/RClassUtils.R: gettextf("needed the supplied labels vector of length %d, got %d",     length(nodes), length(short))
#: R/RClassUtils.R:0
msgid "needed the supplied labels vector of length %d, got %d"
msgstr "il fallait suppléer un vecteur d'étiquettes de longueur %d, mais sa longueur est %d"

#. R/RClassUtils.R: gettextf("no '.Data' slot defined for class %s", dQuote(class(object)))
#: R/RClassUtils.R:0
msgid "no '.Data' slot defined for class %s"
msgstr "pas de slot '.Data' defini pour la classe %s"

#. R/ClassExtensions.R: gettextf("no 'replace' method was defined for 'as(x, \"%s\") <- value' for class %s",     to, dQuote(class(from)))
#: R/ClassExtensions.R:0
msgid "no 'replace' method was defined for 'as(x, \"%s\") <- value' for class %s"
msgstr "pas de méthode 'replace' définie pour 'as(x, \"%s\") <- value' pour la classe %s"

#. R/trace.R: gettextf("no definition for object %s found in tracing environment",     sQuote(what))
#: R/trace.R:0
msgid "no definition for object %s found in tracing environment"
msgstr "la définition de l'objet %s est introuvable dans l'environnement de traçage"

#. R/fixPrevious.R: gettextf("no definition for the class of %s (class %s) found",     sQuote(what), dQuote(class))
#: R/fixPrevious.R:0
msgid "no definition for the class of %s (class %s) found"
msgstr "pas de définition trouvée pour la classe de %s (classe %s)"

#. R/RMethodUtils.R: gettextf("no definition found for class %s", dQuote(classi))
#: R/RMethodUtils.R:0
msgid "no definition found for class %s"
msgstr "aucune définition de la classe %s n'est trouvée"

#. R/refClass.R: gettextf("no definition found for inherited class: %s", paste0("\"",     contains[missingDefs], "\"", collapse = ", "))
#: R/refClass.R:0
msgid "no definition found for inherited class: %s"
msgstr "aucune définition de la classe héritée n'est trouvée : %s"

#. R/SClasses.R: gettextf("no definition of %s to use for %s", dQuote(Class),     unique)
#: R/SClasses.R:0
msgid "no definition of %s to use for %s"
msgstr "aucune définition de %s à utiliser pour %s"

#. R/promptClass.R: gettextf("no definition of class %s found", dQuote(clName))
#: R/promptClass.R:0
msgid "no definition of class %s found"
msgstr "aucune définition de la classe %s n'est trouvée"

#. R/RClassUtils.R: gettextf("no definition of inheritance from %s to %s, though the relation was implied by the setIs() from %s",     .dQ(what), .dQ(def2@className), .dQ(class))
#: R/RClassUtils.R:0
msgid "no definition of inheritance from %s to %s, though the relation was implied by the setIs() from %s"
msgstr "pas de définition d'héritage de %s à %s, bien qu'une telle relation était supposée par setIs() de %s"

#. R/RClassUtils.R: gettextf("no definition was found for superclass %s in the specification of class %s",     dQuote(cl), dQuote(name))
#: R/RClassUtils.R:0
msgid "no definition was found for superclass %s in the specification of class %s"
msgstr "aucune définition de la super-classe %s n'existe dans la spécification de la classe %s"

#. R/Methods.R: gettextf("no environment or package corresponding to argument where=%s",     deparse(where))
#: R/Methods.R:0
msgid "no environment or package corresponding to argument where=%s"
msgstr "pas d'environnement ou de package correspondant à l'argument where=%s"

#. R/Methods.R: gettextf("no existing definition for function %s", sQuote(f))
#: R/Methods.R:0
msgid "no existing definition for function %s"
msgstr "aucune définition n'existe pour la fonction %s"

#. R/addedFunctions.R: gettextf("no function %s found", sQuote(name))
#: R/addedFunctions.R:0
msgid "no function %s found"
msgstr "fonction %s introuvable"

#. R/trace.R: gettextf("no function definition for %s found", sQuote(what))
#: R/trace.R:0
msgid "no function definition for %s found"
msgstr "aucune définition de fonction n'est trouvée pour %s"

#. R/method.skeleton.R: gettextf("no function definition found for %s", sQuote(generic))
#: R/method.skeleton.R:0
msgid "no function definition found for %s"
msgstr "aucune définition de fonction n'est trouvée pour %s"

#. R/Methods.R: gettextf("no generic function %s found", sQuote(f))
#: R/Methods.R:0
msgid "no generic function %s found"
msgstr "aucune fonction générique %s n'est trouvée"

#. R/MethodsList.R: gettextf("no generic function found corresponding to %s", sQuote(f))
#: R/MethodsList.R:0
msgid "no generic function found corresponding to %s"
msgstr "aucune fonction générique ne correspond à %s"

#. R/RMethodUtils.R: gettextf("no generic function found for %s", sQuote(f))
#: R/RMethodUtils.R:0
msgid "no generic function found for %s"
msgstr "aucune fonction générique n'est trouvée pour %s"

#. R/Methods.R: gettextf("no generic function found for '%s'", f)
#: R/Methods.R:0
msgid "no generic function found for '%s'"
msgstr "aucune fonction générique n'est trouvée pour '%s'"

#. R/Methods.R: gettextf("no generic version of %s on package %s is allowed;\n   a new generic will be assigned for %s",     sQuote(name), sQuote(package), thisPName)
#: R/Methods.R:0
msgid ""
"no generic version of %s on package %s is allowed;\n"
"   a new generic will be assigned for %s"
msgstr ""
"pas de version du générique de %s permise dans le package %s ;\n"
"    un nouveau générique sera attribué pour %s"

#. R/Methods.R: gettextf("no method for %s matches class %s", sQuote("..."),     dQuote(signature))
#: R/Methods.R:0
msgid "no method for %s matches class %s"
msgstr "pas de méthode pour %s correspondant à la classe %s"

#. R/Methods.R: gettextf("no method found for function %s and signature %s",     sQuote(fdef@generic), paste(.dQ(signature), collapse = ", "))
#: R/Methods.R:0
msgid "no method found for function %s and signature %s"
msgstr "aucune méthode n'est trouvée pour la fonction %s et la signature %s"

#. R/Methods.R: gettextf("no method found for function '%s' and signature %s",     f, paste(signature, collapse = ", "))
#: R/Methods.R:0
msgid "no method found for function '%s' and signature %s"
msgstr "aucune méthode n'est trouvée pour la fonction '%s' et la signature %s"

#. R/Methods.R: gettextf("no method found for signature %s", paste(signature,     collapse = ", "))
#: R/Methods.R:0
msgid "no method found for signature %s"
msgstr "aucune méthode trouvée pour la signature %s"

#. R/trace.R: gettextf("no method in methods table for %s for signature %s",     sQuote(what), sQuote(signature))
#: R/trace.R:0
msgid "no method in methods table for %s for signature %s"
msgstr "pas de méthode définie dans la table de méthodes pour %s pour la signature %s"

#. R/as.R: gettextf("no method or default for as() replacement of %s with Class=\"%s\"",     dQuote(thisClass), Class)
#: R/as.R:0
msgid "no method or default for as() replacement of %s with Class=\"%s\""
msgstr "pas de méthode ou de fonction par défaut pour le remplacement avec as() de %s avec Class = \"%s\""

#. R/as.R: gettextf("no method or default for coercing %s to %s", dQuote(thisClass),     dQuote(Class))
#: R/as.R:0
msgid "no method or default for coercing %s to %s"
msgstr "pas de méthode ou de fonction par défaut pour la conversion automatique de %s en %s"

#. R/RMethodUtils.R: gettextf("no method or default matching the \"...\" arguments in %s",     deparse(sys.call(sys.parent()), nlines = 1))
#: R/RMethodUtils.R:0
msgid "no method or default matching the \"...\" arguments in %s"
msgstr "pas de méthode ou de fonction par défaut correspondant à l'argument \"...\" dans %s"

#. R/RMethodUtils.R: gettextf("no methods found for %s; cacheGenericsMetaData() will have no effect",     sQuote(f))
#: R/RMethodUtils.R:0
msgid "no methods found for %s; cacheGenericsMetaData() will have no effect"
msgstr "aucune méthode n'est trouvée pour %s ; cacheGenericMetaData() n'aura aucun effet"

#. R/methodsTable.R: gettextf("no methods table for generic %s from package %s in package %s",     sQuote(generic@generic), sQuote(generic@package), sQuote(getPackageName(where)))
#: R/methodsTable.R:0
msgid "no methods table for generic %s from package %s in package %s"
msgstr "impossible de trouver la table des méthodes pour le générique %s du package %s dans le package %s"

#. R/addedFunctions.R: gettextf("no non-generic function %s found", sQuote(name))
#: R/addedFunctions.R:0
msgid "no non-generic function %s found"
msgstr "aucune fonction %s non générique n'est trouvée"

#. R/SClasses.R: gettextf("no package name supplied and no class definition found for %s",     dQuote(className))
#: R/SClasses.R:0
msgid "no package name supplied and no class definition found for %s"
msgstr "aucun nom de package fourni et pas de définition de classe trouvée pour %s"

#. R/RMethodUtils.R: stop("no suitable arguments to dispatch methods in this function")
#: R/RMethodUtils.R:0
msgid "no suitable arguments to dispatch methods in this function"
msgstr "pas d'arguments corrects pour dispatcher les méthodes de cette fonction"

#. R/RMethodUtils.R: gettext("non-empty string; got \"\"")
#: R/RMethodUtils.R:0
msgid "non-empty string; got \"\""
msgstr ""

#. R/RMethodUtils.R: gettextf("non-function action: %s", sQuote(fname))
#: R/RMethodUtils.R:0
msgid "non-function action: %s"
msgstr "action qui n'est pas une fonction : %s"

#. R/Methods.R: gettextf("non-generic function '%s' given to findMethods()",     f)
#: R/Methods.R:0
msgid "non-generic function '%s' given to findMethods()"
msgstr "fonction non générique '%s' fournie à findMethods()"

#. R/refClass.R: gettextf("non-local assignment to method names is not allowed\n    %s\n( in method %s for class %s)",     paste(unlist(assigned$globals)[globalsInMethods], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"non-local assignment to method names is not allowed\n"
"    %s\n"
"( in method %s for class %s)"
msgstr ""
"l'affectation non-locale à des noms de méthodes n'est pas autorisée\n"
"    %s\n"
"(dans la méthode %s de la classe %s)"

#. R/refClass.R: gettextf("non-local assignment to non-field names (possibly misspelled?)\n    %s\n( in method %s for class %s)",     paste(unlist(assigned$globals)[globalsNotFields], collapse = "; "),     methodName, className)
#: R/refClass.R:0
msgid ""
"non-local assignment to non-field names (possibly misspelled?)\n"
"    %s\n"
"( in method %s for class %s)"
msgstr ""
"affectation non-locale à des noms qui ne sont pas des champs (coquille possible ?)\n"
"    %s\n"
"(dans la méthode %s de la classe %s)"

#. R/trace.R: stop("none of the objects in the source code could be found:  need to attach or specify the package")
#: R/trace.R:0
msgid "none of the objects in the source code could be found:  need to attach or specify the package"
msgstr "aucuns des objets utilisés dans le code source ne peuvent être trouvés : il faut attacher ou spécifier un package"

#. R/refClass.R: gettextf("not a reference class: %s", ClassDef@name)
#: R/refClass.R:0
msgid "not a reference class: %s"
msgstr "ceci n'est pas une classe de référence : %s"

#. R/oldClass.R: stop("not allowed to have test==TRUE and an S4Class definition")
#: R/oldClass.R:0
msgid "not allowed to have test==TRUE and an S4Class definition"
msgstr "avoir à la fois test == TRUE et une définition S4Class n'est pas permis"

#. R/Methods.R: gettext("not both functions!")
#: R/Methods.R:0
msgid "not both functions!"
msgstr "au moins l'une des deux n'est pas une fonction !"

#. R/fixPrevious.R: gettextf("object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)",     sQuote(what))
#: R/fixPrevious.R:0
msgid "object %s not changed (it does not appear to be from a version of R earlier than 1.8.0)"
msgstr "objet %s inchangé (il ne semble pas être originaire d'une version de R antérieure à 1.8.0)"

#. R/fixPrevious.R: gettextf("object %s not changed (it is not consistent with the current definition of class %s from %s)",     sQuote(what), dQuote(Class), sQuote(ClassDef@package))
#: R/fixPrevious.R:0
msgid "object %s not changed (it is not consistent with the current definition of class %s from %s)"
msgstr "objet %s inchangé (il n'est pas compatible avec la définition actuelle de la classe %s de %s)"

#. R/fixPrevious.R: gettextf("object %s not found", sQuote(what))
#: R/fixPrevious.R:0
msgid "object %s not found"
msgstr "objet %s introuvable"

#. R/BasicClasses.R: gettextf("object must be a valid data part for class %s; not true of type %s",     dQuote(cl), dQuote(class(data)))
#: R/BasicClasses.R:0
msgid "object must be a valid data part for class %s; not true of type %s"
msgstr "l'objet doit être une partie 'data' correcte pour la classe %s ; ce n'est pas le cas pour un type %s"

#. R/MethodsList.R: gettextf("object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object",     sQuote(fun@generic), length(sigClasses), length(signature))
#: R/MethodsList.R:0
msgid "object to use as a method signature for function %s does not look like a legitimate signature (a vector of single class names): there were %d class names, but %d elements in the signature object"
msgstr "l'objet à utiliser comme signature de méthode pour la fonction %s ne semble pas être une signature correcte (un vecteur de noms de classes uniques) : il y a %d noms de classes, mais seulement %d éléments dans l'objet signature"

#. R/trace.R: gettextf("objects found in multiple packages: using %s and ignoring %s",     sQuote(names(possible[[1L]])), paste(sQuote(names(possible[-1L])),         collapse = ", "))
#: R/trace.R:0
msgid "objects found in multiple packages: using %s and ignoring %s"
msgstr "objects trouvés dans plusieurs packages : utilisation de celui dans %s sans tenir compte de %s"

#. R/Methods.R: gettextf("only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)",     inherited)
#: R/Methods.R:0
msgid "only FALSE is meaningful for 'inherited', when 'where' is supplied (got %s)"
msgstr "seul FALSE a un sens pour 'inherited', lorsque 'where' est fourni (j’ai %s)"

#. R/SClasses.R: stop("only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object")
#: R/SClasses.R:0
msgid "only arguments 'Class' and 'where' can be supplied when argument 'representation' is a 'classRepresentation' object"
msgstr "seuls les arguments 'Class' et 'where' peuvent être fournis lorsque l'argument 'representation' est un objet de type 'classRepresentation'"

#. R/SClasses.R: stop("only one data object (unnamed argument to prototype) allowed")
#: R/SClasses.R:0
msgid "only one data object (unnamed argument to prototype) allowed"
msgstr "un seul objet est permis (argument non nommé vers prototype)"

#. R/Methods.R: gettext("original function is prohibited as a generic function")
#: R/Methods.R:0
msgid "original function is prohibited as a generic function"
msgstr "la fonction originale ne peut être utilisée comme fonction générique"

#. R/trace.R: gettextf("package %s is not attached and no namespace found for it",     sQuote(package))
#: R/trace.R:0
msgid "package %s is not attached and no namespace found for it"
msgstr "le package %s n'est pas attaché et ne possède aucun espace de noms"

#. R/Methods.R: gettextf("package slots  differ: %s, %s", .dQ(gpString(f1@package)),     .dQ(gpString(f2@package)))
#: R/Methods.R:0
msgid "package slots  differ: %s, %s"
msgstr "les slots package diffèrent : %s, %s"

#. R/RClassUtils.R: gettextf("potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)",     dQuote(Class), paste(bad, collapse = ", "))
#: R/RClassUtils.R:0
msgid "potential cycle in class inheritance: %s has duplicates in superclasses and subclasses (%s)"
msgstr "référence circulaire possible dans l'héritage de classe : %s est dupliqué dans les superclasses et les sous-classes (%s)"

#. R/Methods.R: stop("primitive functions cannot be methods; they must be enclosed in a regular function")
#: R/Methods.R:0
msgid "primitive functions cannot be methods; they must be enclosed in a regular function"
msgstr "les fonctions primitives ne peuvent être des méthodes ; Elles doivent être encapsulées dans des fonctions régulières"

#. R/RClassUtils.R: warning("prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble.")
#: R/RClassUtils.R:0
msgid "prototype is a list with named elements (could be ambiguous):  better to use function prototype() to avoid trouble."
msgstr "le prototype est une liste d'éléments nommés (ce peut être ambigu) : il vaut mieux utiliser la fonction prototype() pour éviter les problèmes."

#. R/ClassExtensions.R: gettextf("replacement value must be of class %s, got one of class %s",     dQuote(CLASS), dQuote(class(value)[[1L]]))
#: R/ClassExtensions.R:0
msgid "replacement value must be of class %s, got one of class %s"
msgstr "la valeur de remplacement doit étendre la classe %s, pas la classe %s"

#. R/ClassExtensions.R: gettextf("replacement value must extend class %s, got %s", dQuote(needClass),     dQuote(S3Class[[1L]]))
#: R/ClassExtensions.R:0
msgid "replacement value must extend class %s, got %s"
msgstr "la valeur de remplacement doit étendre la classe %s, pas la classe %s"

#. R/oldClass.R: gettextf("restoring definition of class %s", dQuote(cl))
#: R/oldClass.R:0
msgid "restoring definition of class %s"
msgstr "récupération de la définition de classe %s"

#. R/trace.R: gettextf("setting a method over the binding of symbol %s in environment/package %s",     sQuote(what), sQuote(getPackageName(where)))
#: R/trace.R:0
msgid "setting a method over the binding of symbol %s in environment/package %s"
msgstr "création d'une méthode à travers un lien du symbole %s dans l'environnement/le package %s"

#. R/Methods.R: gettextf("signatures differ:  (%s), (%s)", paste(f1@signature,     collapse = ", "), paste(f2@signature, collapse = ", "))
#: R/Methods.R:0
msgid "signatures differ:  (%s), (%s)"
msgstr "les signatures diffèrent : (%s), (%s)"

#. R/RMethodUtils.R: gettextf("single string; got a character vector of length %s",     length(what))
#: R/RMethodUtils.R:0
#, fuzzy
msgid "single string; got a character vector of length %s"
msgstr "chaîne de caractères unique ; mais l'objet est de classe %s"

#. R/RMethodUtils.R: gettextf("single string; got an object of class %s", dQuote(class(what)[[1L]]))
#: R/RMethodUtils.R:0
msgid "single string; got an object of class %s"
msgstr "chaîne de caractères unique ; mais l'objet est de classe %s"

#. R/oldClass.R: gettextf("slot %s: class %s should extend class %s", sQuote(what),     dQuote(slots1[[what]]), dQuote(slots2[[what]]))
#: R/oldClass.R:0
msgid "slot %s: class %s should extend class %s"
msgstr "slot %s : la classe %s doit étendre la classe %s"

#. R/RMethodUtils.R: gettextf("some actions are missing: %s", paste(actions[!allExists],     collapse = ", "))
#: R/RMethodUtils.R:0
msgid "some actions are missing: %s"
msgstr "quelques actions sont manquantes : %s"

#. R/trace.R: gettextf("supplied package, %s, differs from package inferred from source, %s",     sQuote(package), sQuote(envPackage))
#: R/trace.R:0
msgid "supplied package, %s, differs from package inferred from source, %s"
msgstr "le package fourni, %s, diffère du package déduit des sources, %s"

#. R/methodsTable.R: gettextf("the \"ambiguousMethodSelection\" option should be a function to be called as the condition action; got an object of class %s",     dQuote(class(condAction)))
#: R/methodsTable.R:0
msgid "the \"ambiguousMethodSelection\" option should be a function to be called as the condition action; got an object of class %s"
msgstr "l'option \"ambiguousMethodSelection\" doit être une fonction à appeler comme action de condition ; un objet de classe %s est fourni à la place"

#. R/RMethodUtils.R: gettextf("the %s argument must be NULL or a generic function object; got an object of class %s",     sQuote("genericFunction"), dQuote(class(genericFunction)))
#: R/RMethodUtils.R:0
msgid "the %s argument must be NULL or a generic function object; got an object of class %s"
msgstr "l'argument %s doit être soit NULL, soit un objet de type fonction générique ; Un objet de classe %s est trouvé"

#. R/RClassUtils.R: gettextf("the '%s' list for class %s, includes an undefined class %s",     if (superClassCase) "superClass" else "subClass", dQuote(className),     dQuote(.className(by)))
#: R/RClassUtils.R:0
msgid "the '%s' list for class %s, includes an undefined class %s"
msgstr "la liste '%s' pour la classe %s inclut une classe non définie %s"

#. R/ClassExtensions.R: gettextf("the 'S3Class' argument must be a superclass of %s:  not true of class %s",     dQuote(class(object)), dQuote(S3Class))
#: R/ClassExtensions.R:0
msgid "the 'S3Class' argument must be a superclass of %s:  not true of class %s"
msgstr "l'argument 'S3Class' doit être une super-classe de %s : ce n'est pas le cas pour la classe %s"

#. R/ClassExtensions.R: gettextf("the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s",     dQuote(class(coerce)))
#: R/ClassExtensions.R:0
msgid "the 'coerce' argument to 'setIs' should be a function of one argument, got an object of class %s"
msgstr "l'argument 'coerce' de 'setIs' doit être une fonction à un seul argument et un objet de la classe %s est défini"

#. R/refClass.R: gettextf("the 'contains' argument should be the names of superclasses:  got an element of class %s",     dQuote(class(what)))
#: R/refClass.R:0
msgid "the 'contains' argument should be the names of superclasses:  got an element of class %s"
msgstr "l'argument 'contains' doit renseigner les noms de superclasses : un objet de classe %s est fourni"

#. R/ClassExtensions.R: gettextf("the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s",     dQuote(class(replace)))
#: R/ClassExtensions.R:0
msgid "the 'replace' argument to setIs() should be a function of 2 or 3 arguments, got an object of class %s"
msgstr "l'argument 'replace' de setIs() doit être une fonction à 2 ou 3 arguments alors qu'un objet de classe %s est défini"

#. R/Methods.R: gettextf("the 'where' environment (%s) is a locked namespace; cannot assign methods there",     getPackageName(where))
#: R/Methods.R:0
msgid "the 'where' environment (%s) is a locked namespace; cannot assign methods there"
msgstr "l'environnement dans 'where' (%s) est un espace de noms verrouillé ; Impossible d'y assigner des méthodes"

#. R/oldClass.R: gettextf("the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")",     .class1(prototype), mainClass)
#: R/oldClass.R:0
msgid "the S3 class of the prototype, \"%s\", is undefined; only allowed when this is the S3 class being registered (\"%s\")"
msgstr "la classe S3 du prototype, \"%s\", est définie ; ceci est autorisé uniquement lorsque la classe S3 est enregistrée (\"%s\")"

#. R/RMethodUtils.R: gettextf("the body of the generic function for %s calls 'standardGeneric' to dispatch on a different name (\"%s\")!",     sQuote(fname), paste(as.character(x[[2L]]), collapse = "\n"))
#: R/RMethodUtils.R:0
msgid "the body of the generic function for %s calls 'standardGeneric' to dispatch on a different name (\"%s\")!"
msgstr "le corps de la fonction générique pour %s appelle 'standardGeneric' pour dispatcher vers un nom différent (\"%s\") !"

#. R/refClass.R: gettextf("the class of field %s in the object is not compatible with the desired class %s in the target",     sQuote(field), dQuote(fieldClasses[[field]]))
#: R/refClass.R:0
msgid "the class of field %s in the object is not compatible with the desired class %s in the target"
msgstr "la classe du champ %s dans l'objet n'est pas compatible avec la classe souhaitée %s pour la cible"

#. R/ClassExtensions.R: gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n",     TO, dQuote(FROM), TO, dQuote(class(value)))
#: R/ClassExtensions.R:0
msgid "the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)"
msgstr "l'instruction : 'as(object, \"%s\") <- value' est valable lorsque l'objet est de la classe %s seulement si 'is(value, \"%s\")' est vrai ('class(value)' est %s)"

#. R/refClass.R: gettextf("the definition of class %s in package %s is locked so fields may not be modified",     dQuote(def@className), sQuote(def@package))
#: R/refClass.R:0
msgid "the definition of class %s in package %s is locked so fields may not be modified"
msgstr "la définition de classe %s dans le package %s est verrouillée, les champs ne peuvent être redéfinis"

#. R/refClass.R: gettextf("the definition of class %s in package %s is locked, methods may not be redefined",     dQuote(def@className), sQuote(def@package))
#: R/refClass.R:0
msgid "the definition of class %s in package %s is locked, methods may not be redefined"
msgstr "la définition de classe %s dans le package %s est verrouillée, les méthodes ne peuvent être redéfinies"

#. R/trace.R: stop("the editing in trace() can only change the body of the function, not the arguments or defaults")
#: R/trace.R:0
msgid "the editing in trace() can only change the body of the function, not the arguments or defaults"
msgstr "l'édition dans trace() ne peut changer que le corps de la fonction, pas les arguments ou les valeurs par défaut"

#. R/trace.R: gettextf("the editing in trace() can only change the body of the function; got an object of class %s",     dQuote(class(def2)))
#: R/trace.R:0
msgid "the editing in trace() can only change the body of the function; got an object of class %s"
msgstr "l'édition dans trace() ne peut changer que le corps de la fonction ; Un objet de classe %s est obtenu"

#. R/Methods.R: gettextf("the environment %s is locked; cannot assign methods for function %s",     sQuote(getPackageName(where)), sQuote(f))
#: R/Methods.R:0
msgid "the environment %s is locked; cannot assign methods for function %s"
msgstr "l'environnement %s est verrouillé ; Impossible d'y assigner des méthodes pour la fonction %s"

#. R/RMethodUtils.R: gettextf("the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed",     what, sQuote(f))
#: R/RMethodUtils.R:0
msgid "the function being used as %s in making a generic function for %s is currently traced; the function used will have tracing removed"
msgstr "la fonction utilisée comme %s dans l'établissement d'une fonction générique pour %s est actuellement en cours de déboguage (tracing) ; La fonction ne sera plus déboguée"

#. R/ClassUnion.R: gettextf("the member classes must be defined: not true of %s",     paste(.dQ(as(members[!membersDefined], "character")), collapse = ", "))
#: R/ClassUnion.R:0
msgid "the member classes must be defined: not true of %s"
msgstr "les classes membres doivent être définies : Ce n'est pas le cas pour %s"

#. R/trace.R: gettextf("the method for %s for this signature was not being traced",     sQuote(what))
#: R/trace.R:0
msgid "the method for %s for this signature was not being traced"
msgstr "la méthode pour %s pour cette signature ne sera pas déboguée (tracée)"

#. R/Methods.R: gettextf("the method for function %s and signature %s is sealed and cannot be re-defined",     sQuote(f), .signatureString(fdef, signature))
#: R/Methods.R:0
msgid "the method for function %s and signature %s is sealed and cannot be re-defined"
msgstr "la méthode pour la fonction %s, ainsi que la signature %s, sont verrouillées et ne peuvent être redéfinies"

#. R/MethodsListClass.R: gettext("the names in signature for method (%s) do not match %s's arguments (%s)",     domain = "R-methods")
#: R/MethodsListClass.R:0
msgid "the names in signature for method (%s) do not match %s's arguments (%s)"
msgstr "les noms dans la signature pour la méthode (%s) ne correspondent pas aux arguments de la fonction %s (%s)"

#. R/MethodsListClass.R: gettext("the names in signature for method (%s) do not match function's arguments (%s)",     domain = "R-methods")
#: R/MethodsListClass.R:0
msgid "the names in signature for method (%s) do not match function's arguments (%s)"
msgstr "les noms dans la signature pour la méthode (%s) ne correspondent pas aux arguments de la fonction (%s)"

#. R/refClass.R: gettextf("the overriding class (\"%s\") of field %s is not a subclass of the existing field definition (\"%s\")",     value[[field]], sQuote(field), fieldList[[field]])
#: R/refClass.R:0
msgid "the overriding class (\"%s\") of field %s is not a subclass of the existing field definition (\"%s\")"
msgstr "la redéfinition de classe (\"%s\") pour le champ %s n'est pas une sous-classe de la définition de champ existante (\"%s\")"

#. R/ClassExtensions.R: gettextf("there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error",     to, dQuote(Class))
#: R/ClassExtensions.R:0
msgid "there is no automatic definition for 'as(object, \"%s\") <- value' when object has class %s and no 'replace' argument was supplied; replacement will be an error"
msgstr "il n'y a pas de définition automatique pour 'as(object, \"%s\") <- value' lorsque 'object' est de classe %s et aucun argument 'replace' n'a été fourni ; Le remplacement génère une erreur"

#. R/refClass.R: gettextf("topic %s is not a method name in class %s\nThe class definition follows\n",     sQuote(topic), dQuote(className))
#: R/refClass.R:0
msgid ""
"topic %s is not a method name in class %s\n"
"The class definition follows"
msgstr ""
"l'item %s n'est pas un nom de méthode dans la classe %s\n"
"La définition de classe est la suivante"

#. R/trace.R: gettextf("tracing the internal function %s is not allowed", sQuote(what))
#: R/trace.R:0
msgid "tracing the internal function %s is not allowed"
msgstr "le traçage de la fonction interne %s n'est pas autorisé"

#. R/RClassUtils.R: gettextf("trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object",     dQuote(class(def)), dQuote(Class))
#: R/RClassUtils.R:0
msgid "trying to assign an object of class %s as the definition of class %s: must supply a \"classRepresentation\" object"
msgstr "essai d'assignation d'un objet de classe %s comme définition de la classe %s : il faut un objet \"classRepresentation\""

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s in an object of class %s; expected a function definition",     msg, dQuote(class(def)))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s in an object of class %s; expected a function definition"
msgstr "tentative de modification des arguments formels de %s, vers un objet de classe %s ; Une définition de fonction était attendue"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but getting the new formals from an object of class %s; expected a function definition",     msg, dQuote(class(def)))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but getting the new formals from an object of class %s; expected a function definition"
msgstr "tentative de modification des arguments formels de %s, mais les nouveaux arguments formels sont obtenus depuis l'objet de classe %s ; Une définition de fonction était attendue"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but the number of existing arguments is greater than the number of new arguments (the extra arguments won't be used): (%s) vs (%s)",     msg, paste0("\"", old, "\"", collapse = ", "), paste0("\"",         new, "\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but the number of existing arguments is greater than the number of new arguments (the extra arguments won't be used): (%s) vs (%s)"
msgstr "tentative de modification des arguments formels de %s, mais le nombre d'arguments existants est supérieur au nombre de nouveaux arguments (les arguments additionnels seront ignorés) : (%s) contre (%s)"

#. R/RMethodUtils.R: gettextf("trying to change the formal arguments in %s, but the number of existing arguments is less than the number of new arguments: (%s) vs (%s)",     msg, paste0("\"", old, "\"", collapse = ", "), paste0("\"",         new, "\"", collapse = ", "))
#: R/RMethodUtils.R:0
msgid "trying to change the formal arguments in %s, but the number of existing arguments is less than the number of new arguments: (%s) vs (%s)"
msgstr "tentative de modification des arguments formels de %s, mais le nombre d'arguments existants est inférieur au nombre de nouveaux arguments : (%s) contre (%s)"

#. R/methodsTable.R: gettextf("trying to check signature length of generic '%s', but it is not a generic function: i = %d, funs = %s, gnames = %s",     what, i, paste(unlist(funs), collapse = ", "), paste(as.character(gnames),         collapse = ", "))
#: R/methodsTable.R:0
msgid "trying to check signature length of generic '%s', but it is not a generic function: i = %d, funs = %s, gnames = %s"
msgstr "tentative de vérification de la longueur de signature du générique '%s', mais ce n'est pas un générique : i = %d, funs = %s, gnames = %s"

#. R/methodsTable.R: gettextf("trying to check signature length of group generic '%s', but it is not a group generic",     what)
#: R/methodsTable.R:0
msgid "trying to check signature length of group generic '%s', but it is not a group generic"
msgstr "essai de vérification de la longueur de la signature pour le groupe générique '%s', mais ce n'est pas un groupe générique"

#. R/methodsTable.R: stop("trying to find a methods table in a non-generic function")
#: R/methodsTable.R:0
msgid "trying to find a methods table in a non-generic function"
msgstr "tentative de recherche d'une table de méthodes dans une fonction non générique"

#. R/MethodsList.R: gettextf("trying to match a method signature of class %s; expects a list or a character vector",     dQuote(class(signature)))
#: R/MethodsList.R:0
msgid "trying to match a method signature of class %s; expects a list or a character vector"
msgstr "tentative d'application d'une signature de classe %s ; Une liste ou un vecteur de chaînes de caractères est attendu"

#. R/MethodsList.R: gettextf("trying to match a method signature to an object (of class %s) that is not a generic function",     dQuote(class(fun)))
#: R/MethodsList.R:0
msgid "trying to match a method signature to an object (of class %s) that is not a generic function"
msgstr "tentative d'application d'une signature à un objet (de classe %s) qui n'est pas une fonction générique"

#. R/as.R: gettextf("trying to set an 'as' relation from %s to itself",     dQuote(.class1(from)))
#: R/as.R:0
msgid "trying to set an 'as' relation from %s to itself"
msgstr "tentative de définition d'une relation 'as' de %s vers lui-même"

#. R/ClassUnion.R: gettextf("unable to create union class:  could not set members %s",     paste(.dQ(failed), collapse = ", "))
#: R/ClassUnion.R:0
msgid "unable to create union class:  could not set members %s"
msgstr "impossible de créer une classe d'union : Les membres %s sont indéfinissables"

#. R/RClassUtils.R: gettextf("unable to find a consistent ordering of superclasses for class %s: order chosen is inconsistent with the superclasses of %s",     .dQ(className), paste(.dQ(setdiff(newconflicts, conflicts)),         collapse = ", "))
#: R/RClassUtils.R:0
msgid "unable to find a consistent ordering of superclasses for class %s: order chosen is inconsistent with the superclasses of %s"
msgstr "impossible de déterminer un ordre cohérent des superclasses pour la classe %s : l'ordre choisi est incohérent avec la superclasse de %s"

#. R/RClassUtils.R: gettextf("unable to find an environment containing class %s",     dQuote(Class))
#: R/RClassUtils.R:0
msgid "unable to find an environment containing class %s"
msgstr "impossible de trouver un environnement contenant la classe %s"

#. R/methodsTable.R: gettextf("unable to find an inherited method for function %s for signature %s",     sQuote(fdef@generic), sQuote(cnames))
#: R/methodsTable.R:0
msgid "unable to find an inherited method for function %s for signature %s"
msgstr "impossible de trouver une méthode héritée pour la fonction %s pour la signature %s"

#. R/RClassUtils.R: gettextf("unable to load required package %s", sQuote(package))
#: R/RClassUtils.R:0
#, fuzzy
msgid "unable to load required package %s"
msgstr "impossible de trouver le package %s nécessaire"

#. R/as.R: stop("undefined 'coerce' method")
#: R/as.R:0
msgid "undefined 'coerce' method"
msgstr "méthode de conversion automatique 'coerce' non définie"

#. R/methodsTable.R: gettextf("undefined classes (%s) will be ignored for argument '%s'",     paste0("\"", unique(.undefClasses), "\"", collapse = ", "),     colnames(sigs)[[j]])
#: R/methodsTable.R:0
msgid "undefined classes (%s) will be ignored for argument '%s'"
msgstr "les classes non définies (%s) seront ignorées pour l'argument '%s'"

#. R/RClassUtils.R: gettext("undefined slot classes in definition of %s: %s", domain = "R-methods")
#: R/RClassUtils.R:0
msgid "undefined slot classes in definition of %s: %s"
msgstr "slot non défini dans la définition de classe de %s : %s"

#. R/RClassUtils.R: gettextf("undefined subclass %s of class %s; definition not updated",     .dQ(what), .dQ(def@className))
#: R/RClassUtils.R:0
msgid "undefined subclass %s of class %s; definition not updated"
msgstr "sous-classe indéfinie, %s, de la classe %s ; la définition n'est pas mise à jour"

#. R/zzz.R: message("unloading 'methods' package ...")
#: R/zzz.R:0
msgid "unloading 'methods' package ..."
msgstr "déchargement du package 'methods' ..."

#. R/BasicClasses.R: gettextf("unnamed argument must extend either the S3 class or the class of the data part; not true of class %s",     dQuote(Classi))
#: R/BasicClasses.R:0
msgid "unnamed argument must extend either the S3 class or the class of the data part; not true of class %s"
msgstr "un argument non nommé doit étendre soit la classe S3, soit la classe de la partie 'data' ; ce n'est pas le cas pour la classe %s"

#. R/BasicClasses.R: gettextf("unnamed argument to initialize() for S3 class must have a class definition; %s does not",     dQuote(Classi))
#: R/BasicClasses.R:0
msgid "unnamed argument to initialize() for S3 class must have a class definition; %s does not"
msgstr "un argument non nommé de initialize() pour une classe S3 doit avoir une définition de classe ; %s n'en a pas"

#. R/BasicClasses.R: stop("unnamed argument to new() must be an environment for the new object")
#: R/BasicClasses.R:0
msgid "unnamed argument to new() must be an environment for the new object"
msgstr "l'argument non nommé de new() doit être un environnement pour le nouvel objet"

#. R/refClass.R: gettextf("unnamed arguments to $new() must be objects from a reference class; got an object of class %s",     dQuote(class(super)))
#: R/refClass.R:0
msgid "unnamed arguments to $new() must be objects from a reference class; got an object of class %s"
msgstr "les arguments non nommés de $new() doivent être des objets d'une classe de référence ;  Un objet de classe %s est trouvé"

#. R/SClasses.R: stop("validity method must be NULL or a function of one argument")
#: R/SClasses.R:0
msgid "validity method must be NULL or a function of one argument"
msgstr "la méthode de validation doit être soit NULL, soit une fonction à un seul argument"

#. R/Methods.R: gettextf("value classes differ: %s, %s", .dQ(gpString(f1@valueClass)),     .dQ(gpString(f2@valueClass)))
#: R/Methods.R:0
msgid "value classes differ: %s, %s"
msgstr "les classes valeur diffèrent : %s, %s"

#. R/methodsTable.R: ngettext(length(candidates), "Choosing method %s from %d ambiguous possibility",     "Choosing method %s from %d ambiguous possibilities")
#: R/methodsTable.R:0
msgid "Choosing method %s from %d ambiguous possibility"
msgid_plural "Choosing method %s from %d ambiguous possibilities"
msgstr[0] "Choix de la méthode %s de %d possibilité ambigüe"
msgstr[1] "Choix de la méthode %s de %d possibilités ambigües"

#. R/MethodsListClass.R: ngettext(nreport, "Reported %d ambiguous selection out of %d for function %s\n",     "Reported %d ambiguous selections out of %d for function %s\n")
#: R/MethodsListClass.R:0
msgid "Reported %d ambiguous selection out of %d for function %s\n"
msgid_plural "Reported %d ambiguous selections out of %d for function %s\n"
msgstr[0] "%d sélection ambigüe reportée depuis %d pour la fonction %s\n"
msgstr[1] "%d sélections ambigües reportées depuis %d pour la fonction %s\n"

#. R/methodsTable.R: ngettext(which2, "Selecting %d method of minimum distance", "Selecting %d methods of minimum distance")
#: R/methodsTable.R:0
msgid "Selecting %d method of minimum distance"
msgid_plural "Selecting %d methods of minimum distance"
msgstr[0] "Section de %d méthode de distance minimale"
msgstr[1] "Section de %d méthodes de distance minimale"

#. R/methodsTable.R: ngettext(length(which), "Selecting %d non-group method", "Selecting %d non-group methods")
#: R/methodsTable.R:0
msgid "Selecting %d non-group method"
msgid_plural "Selecting %d non-group methods"
msgstr[0] "Sélection de %d méthode qui n'est pas un groupe"
msgstr[1] "Sélection de %d méthodes qui ne sont pas des groupes"

#. R/methodsTable.R: ngettext(length(which), "Selecting %d partially exact-matching method",     "Selecting %d partially exact-matching methods")
#: R/methodsTable.R:0
msgid "Selecting %d partially exact-matching method"
msgid_plural "Selecting %d partially exact-matching methods"
msgstr[0] "Sélection de %d méthode à concordance partielle"
msgstr[1] "Sélection de %d méthodes à concordance partielle"

#. R/is.R: ngettext(sum(is.na(match(n2, n1))), "class %s is missing slot from class %s (%s), and no coerce method was supplied",     "class %s is missing slots from class %s (%s), and no coerce method was supplied")
#: R/is.R:0
msgid "class %s is missing slot from class %s (%s), and no coerce method was supplied"
msgid_plural "class %s is missing slots from class %s (%s), and no coerce method was supplied"
msgstr[0] "la classe %s a un slot manquant de la classe %s (%s), et aucune méthode de conversion automatique n'est fournie"
msgstr[1] "la classe %s a des slots manquants de la classe %s (%s), et aucune méthode de conversion automatique n'est fournie"

#. R/SClasses.R: ngettext(length(dslots), "duplicated slot name: %s", "duplicated slot names: %s")
#: R/SClasses.R:0
msgid "duplicated slot name: %s"
msgid_plural "duplicated slot names: %s"
msgstr[0] "nom de slot dupliqué : %s"
msgstr[1] "noms de slots dupliqués : %s"

#. R/methodsTable.R: ngettext(length(methods), "found %d equally good next method",     "found %d equally good next methods")
#: R/methodsTable.R:0
msgid "found %d equally good next method"
msgid_plural "found %d equally good next methods"
msgstr[0] "%d méthode est aussi bonne que la méthode suivante"
msgstr[1] "%d méthodes sont aussi bonnes que la méthode suivante"

#. R/MethodsList.R: ngettext(sum(is.na(which)), "in the method signature for function %s invalid argument name in the signature: %s",     "in the method signature for function %s invalid argument names in the signature: %s")
#: R/MethodsList.R:0
msgid "in the method signature for function %s invalid argument name in the signature: %s"
msgid_plural "in the method signature for function %s invalid argument names in the signature: %s"
msgstr[0] "dans la signature de méthode pour la fonction %s, il y a un noms d'argument incorrect dans cette signature : %s"
msgstr[1] "dans la signature de méthode pour la fonction %s, il y a des noms d'arguments incorrects dans cette signature : %s"

#. R/SClasses.R: ngettext(sum(is.na(which)), "invalid name for slot of class %s: %s",     "invalid names for slots of class %s: %s")
#: R/SClasses.R:0
msgid "invalid name for slot of class %s: %s"
msgid_plural "invalid names for slots of class %s: %s"
msgstr[0] "nom incorrect pour un slot de la classe %s : %s"
msgstr[1] "noms incorrects pour des slots de la classe %s : %s"

#. R/SClasses.R: ngettext(length(pkgs), "multiple definition of class %s visible (%s); using the definition\n   in package %s for %s",     "multiple definitions of class %s visible (%s); using the definition\n   in package %s for %s")
#: R/SClasses.R:0
msgid ""
"multiple definition of class %s visible (%s); using the definition\n"
"   in package %s for %s"
msgid_plural ""
"multiple definitions of class %s visible (%s); using the definition\n"
"   in package %s for %s"
msgstr[0] ""
"définition multiple de la classe %s est visible (%s) ; utilisation de la définition\n"
"   du package %s pour %s"
msgstr[1] ""
"plusieurs définitions de la classe %s sont visibles (%s) ; utilisation de la définition\n"
"   du package %s pour %s"

#. R/RClassUtils.R: ngettext(sum(is.na(match(pnames, slots))), "named elements of prototype do not correspond to slot name: %s",     "named elements of prototype do not correspond to slot names: %s")
#: R/RClassUtils.R:0
msgid "named elements of prototype do not correspond to slot name: %s"
msgid_plural "named elements of prototype do not correspond to slot names: %s"
msgstr[0] "les éléments nommés du prototype ne correspondent pas au nom d'un slot : %s"
msgstr[1] "les éléments nommés du prototype ne correspondent pas aux noms des slots : %s"

#. R/MethodsList.R: ngettext(length(unknown), "no definition for class %s", "no definition for classes %s")
#: R/MethodsList.R:0
msgid "no definition for class %s"
msgid_plural "no definition for classes %s"
msgstr[0] "aucune définition de la classe %s n'est trouvée"
msgstr[1] "aucune définition des classes %s n'est trouvée"

#. R/promptClass.R: ngettext(length(whereClass), "no definition of class %s in the specified position, %s, definition on : %s",     "no definition of class %s in the specified position, %s, definitions on : %s")
#: R/promptClass.R:0
msgid "no definition of class %s in the specified position, %s, definition on : %s"
msgid_plural "no definition of class %s in the specified position, %s, definitions on : %s"
msgstr[0] "aucune définition de la classe %s n'existe à la position spécifiée, %s, définition dans : %s"
msgstr[1] "aucune définition de la classe %s n'existe à la position spécifiée, %s, définitions dans : %s"

#. R/RMethodUtils.R: ngettext(sum(not.s.in.a), "non-argument found in the signature: %s",     "non-arguments found in the signature: %s")
#: R/RMethodUtils.R:0
msgid "non-argument found in the signature: %s"
msgid_plural "non-arguments found in the signature: %s"
msgstr[0] "un item qui n'est pas un argument est trouvé dans la signature : %s"
msgstr[1] "des items qui ne sont pas des arguments sont trouvés dans la signature : %s"

#. R/is.R: ngettext(length(bad), "slot in class %s must extend corresponding slot in class %s: fails for %s",     "slots in class %s must extend corresponding slots in class %s: fails for %s")
#: R/is.R:0
msgid "slot in class %s must extend corresponding slot in class %s: fails for %s"
msgid_plural "slots in class %s must extend corresponding slots in class %s: fails for %s"
msgstr[0] "un slot de la classe %s doit étendre le slot correspondant de la classe %s : échec pour %s"
msgstr[1] "les slots de la classe %s doivent étendre les slots correspondants de la classe %s : échec pour %s"

#. R/RMethodUtils.R: ngettext(length(fdef), "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)",     "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)")
#: R/RMethodUtils.R:0
msgid "the formal argument of the generic function for %s (%s) differs from that of the non-generic to be used as the default (%s)"
msgid_plural "the formal arguments of the generic function for %s (%s) differ from those of the non-generic to be used as the default (%s)"
msgstr[0] "l'argument formel de la fonction générique pour %s (%s) diffère de celui de la fonction non générique à utiliser par défaut (%s)"
msgstr[1] "les arguments formels de la fonction générique pour %s (%s) diffèrent de ceux de la fonction non générique à utiliser par défaut (%s)"

#~ msgid "E := environment(): %s; parent.env(E): %s"
#~ msgstr "E := environment(): %s; parent.env(E): %s"

#~ msgid "(and methods)"
#~ msgstr "(et des méthodes)"

#~ msgid "Function must be an S4 generic"
#~ msgstr "La fonction doit être un générique S4"

#~ msgid "invalid method sublist"
#~ msgstr "liste de méthodes incorrecte"

#~ msgid "%f is not a valid generic function: methods list was an object of class %s"
#~ msgstr "%f n'est pas une fonction générique valide : la liste des méthodes est un objet de classe %s"

#~ msgid "%s must be TRUE, FALSE, or a named logical vector of those values; got an object of class %s"
#~ msgstr "%s doit être TRUE, FALSE, ou un vecteur nommé de valeurs logiques ; Un objet de classe %s est fourni"

#~ msgid "skipping methods list element %s of unexpected class %s"
#~ msgstr "l'élément %s de classe inattendue %s dans la liste de méthodes est ignoré"

#~ msgid "invalid call in method dispatch to '%s' (no default method)"
#~ msgstr "appel incorrect dans le dispatcheur de méthodes vers '%s' (pas de méthode par défaut)"

#~ msgid "subclass %s of class %s is not local and cannot be updated for new inheritance information; consider setClassUnion()"
#~ msgstr "La sous-classe %s de la classe %s n'est pas locale et ne peut être mise à jour pour une nouvelle information d'héritage ; considérez setClassUnion()"

#~ msgid "Note: the specification for S3 class %s in package %s seems equivalent to one from package %s: not turning on duplicate class definitions for this class."
#~ msgstr "Note: une spécification de classe S3 %s dans le package %s semble équivalente de celle dans le package %s et ne conduit pas à une définition dupliquée de classe"

#~ msgid "methods cannot be defined for the primitive function %s"
#~ msgstr "des méthodes ne peuvent être définies pour la fonction primitive %s"

#~ msgid "package %s seems to have out-of-date methods; need to reinstall from source"
#~ msgstr "le package %s semble avoir des méthodes périmées ; il faut le réinstaller depuis ses sources"

#~ msgid "trying to execute load actions without 'methods' package"
#~ msgstr "tentative d'exécution les actions de chargement sans le package 'methods'"

#~ msgid "special function %s is not permitted to have methods"
#~ msgstr "la fonction spéciale %s ne peut recevoir des définitions de méthodes"

#~ msgid "special function %s has no known argument list; will assume '(x, ...)'"
#~ msgstr "la fonction spéciale %s n'a pas de liste d'arguments connue ; les arguments '(x, ...)' seront considérés par défaut"

#~ msgid "'callGeneric' with a primitive needs explicit arguments (no formal args defined)"
#~ msgstr "'callGeneric' avec une primitive nécessite des arguments explicites (pas d'arguments formels définis)"

#~ msgid "\""
#~ msgstr "\""

#~ msgid "could not find superclass %s to clean up when removing subclass references to class %s"
#~ msgstr "Superclasse %s introuvable pour son nettoyage lors de l'élimination des références à la sous-classe %s"

#~ msgid "no class %s found as expected in removing subclass %s"
#~ msgstr "La classe %s est introuvable, pourtant elle est attendue lors de l'élimination de la sous-classe %s"

#~ msgid "replacement value is not a matrix"
#~ msgstr "la valeur de remplacement n'est pas une matrice"

#~ msgid "field %s is read-only"
#~ msgstr "champ %s en lecture seule"

#~ msgid "not a package name: %s"
#~ msgstr "ceci n'est pas un nom de package : %s"

#, fuzzy
#~ msgid "a list argument for 'fields' must have nonempty names for all the fields"
#~ msgstr "Un argument liste pour les champs ne peut avoir de champs non nommés"

#, fuzzy
#~ msgid "argument 'fields' must be a list of the field classes or definitions or the names of the fields; got an object of class %s"
#~ msgstr "L'arguments champs doit être une liste des champs de classe ou des définitions, ou bien juste les noms des champs  ; Un objet de classe %s est obtenu"

#~ msgid "Warning:  using defunct methods list search"
#~ msgstr "Avis : la recherche dans une liste de méthodes n'est plus supportée"

#~ msgid "apparent inconsistency in the methods for function %s; argument %s in the signature corresponds to %s in the methods list object"
#~ msgstr "inconsistence apparente pour les méthodes de la fonction %s ; L'argument %s dans la signature correspond à %s dans la liste des méthodes de l'objet"

#~ msgid "no S4 method for function %s and signature %s; consider getS3method() if you wanted the S3 method"
#~ msgstr "pas de méthode S4 pour la fonction %s et la signature %s ; Considérez getS3method() si vous recherchez une méthode S3"

#~ msgid "no method defined in methods list object for function %s and signature %s"
#~ msgstr "pas de méthode définie dans l'objet de liste des méthodes pour la fonction %s et la signature %s"

#~ msgid "multiple equivalent inherited matches:"
#~ msgstr "correspondances multiples en héritage :"

#~ msgid "; using the first of these"
#~ msgstr " ; utilisation de la première d'entre elles"

#~ msgid "'traceOn' is deprecated: use the function 'trace' in the 'methods' package instead"
#~ msgstr "'traceOn' est obsolète : utilisez la fonction 'trace' du package 'methods' à la place"

#~ msgid "'traceOff' is deprecated: use the function 'untrace' in the 'methods' package instead"
#~ msgstr "'traceOff' est obsolète : utilisez la fonction 'untrace' du package 'methods' à la place"

#, fuzzy
#~ msgid "The class of field %s in the object is not compatible with the desired class %s in the target"
#~ msgstr "La classe du champ \"%s\" dans l'objet n'est pas compatible avec la classe souhaitée %s pour la cible"

#~ msgid "in .OldClassesPrototypes"
#~ msgstr "dans .OldClassesPrototypes"

#~ msgid "internal error: did not get a valid generic function object for function %s"
#~ msgstr "erreur interne : une fonction générique valide n'est pas fournie pour la fonction %s"

#~ msgid "apparent internal error: a generic function was found for \"%s\", but no corresponding object was found searching from \"%s\""
#~ msgstr "erreur interne apparente : une fonction générique est trouvée pour \"%s\", mais aucun objet correspondant n'est trouvé en recherchant dans \"%s\""

#~ msgid "selectMethod(): mlist is not an environment or NULL :"
#~ msgstr "selectMethod() : mlist n'est pas un environnement ou NULL :"

#~ msgid "** should no longer happen!"
#~ msgstr "** ne devrait plus se produire !"

#~ msgid "Classes: %s, %s"
#~ msgstr "Classes : %s, %s"

#~ msgid "internal error: Bad methods list object in fixing methods for primitive function %s"
#~ msgstr "erreur interne : l'object contenant la liste des méthodes est corrompu pour la fonction primitive %s"

#~ msgid "botched namespace: failed to find 'base' namespace in its parents"
#~ msgstr "espace de noms corrompu : impossible de trouver l'espace de noms 'base' dans ses parents"

#~ msgid "multiple direct matches:"
#~ msgstr "correspondances directes multiples :"

#, fuzzy
#~ msgid "Internal error: definition of class %s not properly assigned"
#~ msgstr "Erreur interne : aucune définition de la classe \"%s\" n'est attribuée"

#, fuzzy
#~ msgid "internal problem in as(): %s is(object, \"%s\") is TRUE, but the metadata asserts that the 'is' relation is FALSE"
#~ msgstr "problème interne dans as() : \"%s\" is(object, \"%s\") renvoie 'TRUE', mais les métadonnées indiquent que la relation 'is' doit être fausse"

#~ msgid "connection"
#~ msgstr "connexion"

#~ msgid "Internal error in finding inherited methods; didn't return a unique method"
#~ msgstr "Erreur interne dans la recherche des méthodes héritées ; une méthode unique n'a pas été renvoyée"

#~ msgid "\", but it is not a group generic"
#~ msgstr "\", mais celui-ci n'est pas un groupe générique"

#~ msgid "Trying to check signature length of generic \""
#~ msgstr "Essai de vérification de la longueur de la signature pour la fonction générique \""

#~ msgid "\", but it is not a  generic function: i ="
#~ msgstr "\", mais ce n'est pas une fonction générique : i ="

#~ msgid ", funs ="
#~ msgstr ", funs ="

#~ msgid ","
#~ msgstr ","

#~ msgid "; gnames ="
#~ msgstr "; gnames ="

#~ msgid "Something weird:  inconsistent number of args in methods table strings:"
#~ msgstr "Quelque chose d'étrange s'est produit : nombre d'arguments inconsistent pour args dans la table des méthodes"

#~ msgid "(using the largest value)"
#~ msgstr "(utilisation d'une value importante)"

#~ msgid "Undefined classes ("
#~ msgstr "Les classes non définies ("

#~ msgid "Method %s from class %s was not processed into a class method until being installed.  Possible corruption of the methods in the class."
#~ msgstr "La méthode %s de la classe %s n'a pas été traitée comme méthode de classe avant installation. Les méthodes de la classe sont peut-être corrompues."

#~ msgid ".TraceWithMethods: after computing what, whereF"
#~ msgstr ".TraceWithMethods : après calcul de 'what', 'whereF'"

#~ msgid ".TraceWithMethods: untrace case"
#~ msgstr ".TraceWithMethods : les cas sont détracés"

#~ msgid ".TraceWithMethods: about to assign or setMethod"
#~ msgstr ".TraceWithMethods : prêt à effectuer l'assignation ou setMethod"

#, fuzzy
#~ msgid "Constructing traceable class %s"
#~ msgstr "La construction de la classe traçable \""

#~ msgid "Pretend we inserted class"
#~ msgstr "Faisons comme si la classe est insérée"

#~ msgid "= \"missing\""
#~ msgstr "\"manquant\""

#~ msgid "found"
#~ msgstr "trouvé"

#~ msgid "Invalid mlist element for signature \""
#~ msgstr "Elément mlist incorrect pour la signature \""

#~ msgid "\" at level"
#~ msgstr "\" au niveau"

#~ msgid "\")"
#~ msgstr "\")"

#~ msgid "Invalid object in methods table (\""
#~ msgstr "Mauvais objet trouvé comme méthode (\""

#~ msgid "\"), expected a method, got an object of class \""
#~ msgstr "\"), une méthode est attendue et un objet est fourni de classe \""

#~ msgid "Environment of class \""
#~ msgstr "Un environnement de classe \""

#~ msgid "Replacement value must be of class \""
#~ msgstr "La valeur de remplacement doit être de classe \""

#~ msgid "\", got one of class \""
#~ msgstr "\", or il s'agit d'un objet de classe \""

#~ msgid "\", for signature"
#~ msgstr "\", pour la signature"

#~ msgid "Field \""
#~ msgstr "Champ \""

#~ msgid "the supplied generic function definition for"
#~ msgstr "la fonction de définition de générique fournie pour"

#~ msgid "does not seem to call 'standardGeneric'; no methods will be dispatched!"
#~ msgstr "ne semble par appeler 'standardGeneric' ; aucune méthode n'est disponible pour le dispatching !"

#~ msgid "no generic function \"'%s\" found"
#~ msgstr "aucune fonction générique \"%s\" n'est trouvée"

#~ msgid ""
#~ "Restoring the implicit generic function for %s from package %s\n"
#~ "    into package %s; the generic differs from the default conversion (%s)"
#~ msgstr ""
#~ "Recupération de la fonction générique implicite pour %s depuis le package %s\n"
#~ "    dans le package %s ; le générique diffère de la conversion par défaut (%s)"

#~ msgid ""
#~ "Creating a generic for %s in package %s\n"
#~ "    (the supplied definition differs from and overrides the implicit generic\n"
#~ "    in package %s: %s)"
#~ msgstr ""
#~ "Création d'une fonction générique pour %s dans le package %s\n"
#~ "    (la définition fournie diffère de et remplace le générique explicite\n"
#~ "    dans le package %s : %s)"

#~ msgid "\" is not a known action (warn, stop, once, ignore); no action recorded for function \""
#~ msgstr "\" n'est pas une action connue (warn, stop, once, ignore) ; aucune action enregistrée pour la fonction \""

#~ msgid "must give named list of refdefined fields"
#~ msgstr "nécessite une liste nommée de redéfinition de champs"

#~ msgid "Only accessor fields can be replaced:  field \"%s\" has class \"%s\""
#~ msgstr "Seuls les champs d'accès peuvent être remplacés : le champ \"%s\" a la classe \"%s\""

#, fuzzy
#~ msgid "Value supplied for field \"%s\" (with class \"%s\") is not a subclass of required class \"%s\""
#~ msgstr "la méthode d'initialisation a renvoyé un objet de classe \"%s\" au lieu de la classe requise \"%s\""

#, fuzzy
#~ msgid "The fieldReadOnly argument must be the names of the read-only fields; got an object of class \"%s\""
#~ msgstr "le premier argument doit être le ou les nom(s) des fonctions génériques (un objet de classe \"%s\" est fourni)"

#, fuzzy
#~ msgid "Field classes undefined: %s"
#~ msgstr "Les classes valeur diffèrent : %s, %s"

#, fuzzy
#~ msgid "Trying to set a read-only field ("
#~ msgstr "tentative de définition d'une relation 'as' de \"%s\" vers lui-même"

#, fuzzy
#~ msgid ")"
#~ msgstr "\")"

#, fuzzy
#~ msgid "\"%s\" is not a known reference class"
#~ msgstr "\"%s\" n'est pas une classe définie"

#, fuzzy
#~ msgid "Invalid accessor function list: %s"
#~ msgstr "indice incorrect pour l'argument de fonction"

#~ msgid "Defining type \"%s\" as a superclass via class \"%s\""
#~ msgstr "Définition du type \"%s\" comme une superclasse par l'intermédiaire de la classe \"%s\""
